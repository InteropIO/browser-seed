(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Tick42CRM", [], factory);
	else if(typeof exports === 'object')
		exports["Tick42CRM"] = factory();
	else
		root["Tick42CRM"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@glue42/desktop/dist/desktop.browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/@glue42/desktop/dist/desktop.browser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, Buffer, process) {(function (global, factory) {
     true ? module.exports = factory() :
    undefined;
}(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$1 = function(d, b) {
        extendStatics$1 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$1(d, b);
    };

    function __extends$1(d, b) {
        extendStatics$1(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$1 = function() {
        __assign$1 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };

    function __awaiter$1(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$1(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var MetricTypes = {
        STRING: 1,
        NUMBER: 2,
        TIMESTAMP: 3,
        OBJECT: 4
    };

    function getMetricTypeByValue(metric) {
        if (metric.type === MetricTypes.TIMESTAMP) {
            return "timestamp";
        }
        else if (metric.type === MetricTypes.NUMBER) {
            return "number";
        }
        else if (metric.type === MetricTypes.STRING) {
            return "string";
        }
        else if (metric.type === MetricTypes.OBJECT) {
            return "object";
        }
        return "unknown";
    }
    function getTypeByValue(value) {
        if (value.constructor === Date) {
            return "timestamp";
        }
        else if (typeof value === "number") {
            return "number";
        }
        else if (typeof value === "string") {
            return "string";
        }
        else if (typeof value === "object") {
            return "object";
        }
        else {
            return "string";
        }
    }
    function serializeMetric(metric) {
        var serializedMetrics = {};
        var type = getMetricTypeByValue(metric);
        if (type === "object") {
            var values = Object.keys(metric.value).reduce(function (memo, key) {
                var innerType = getTypeByValue(metric.value[key]);
                if (innerType === "object") {
                    var composite = defineNestedComposite(metric.value[key]);
                    memo[key] = {
                        type: "object",
                        description: "",
                        context: {},
                        composite: composite,
                    };
                }
                else {
                    memo[key] = {
                        type: innerType,
                        description: "",
                        context: {},
                    };
                }
                return memo;
            }, {});
            serializedMetrics.composite = values;
        }
        serializedMetrics.name = normalizeMetricName(metric.path.join("/") + "/" + metric.name);
        serializedMetrics.type = type;
        serializedMetrics.description = metric.description;
        serializedMetrics.context = {};
        return serializedMetrics;
    }
    function defineNestedComposite(values) {
        return Object.keys(values).reduce(function (memo, key) {
            var type = getTypeByValue(values[key]);
            if (type === "object") {
                memo[key] = {
                    type: "object",
                    description: "",
                    context: {},
                    composite: defineNestedComposite(values[key]),
                };
            }
            else {
                memo[key] = {
                    type: type,
                    description: "",
                    context: {},
                };
            }
            return memo;
        }, {});
    }
    function normalizeMetricName(name) {
        if (typeof name !== "undefined" && name.length > 0 && name[0] !== "/") {
            return "/" + name;
        }
        else {
            return name;
        }
    }
    function getMetricValueByType(metric) {
        var type = getMetricTypeByValue(metric);
        if (type === "timestamp") {
            return Date.now();
        }
        else {
            return publishNestedComposite(metric.value);
        }
    }
    function publishNestedComposite(values) {
        if (typeof values !== "object") {
            return values;
        }
        return Object.keys(values).reduce(function (memo, key) {
            var value = values[key];
            if (typeof value === "object" && value.constructor !== Date) {
                memo[key] = publishNestedComposite(value);
            }
            else if (value.constructor === Date) {
                memo[key] = new Date(value).getTime();
            }
            else if (value.constructor === Boolean) {
                memo[key] = value.toString();
            }
            else {
                memo[key] = value;
            }
            return memo;
        }, {});
    }
    function flatten(arr) {
        return arr.reduce(function (flat, toFlatten) {
            return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
        }, []);
    }
    function getHighestState(arr) {
        return arr.sort(function (a, b) {
            if (!a.state) {
                return 1;
            }
            if (!b.state) {
                return -1;
            }
            return b.state - a.state;
        })[0];
    }
    function aggregateDescription(arr) {
        var msg = "";
        arr.forEach(function (m, idx, a) {
            var path = m.path.join(".");
            if (idx === a.length - 1) {
                msg += path + "." + m.name + ": " + m.description;
            }
            else {
                msg += path + "." + m.name + ": " + m.description + ",";
            }
        });
        if (msg.length > 100) {
            return msg.slice(0, 100) + "...";
        }
        else {
            return msg;
        }
    }
    function composeMsgForRootStateMetric(system) {
        var aggregatedState = system.root.getAggregateState();
        var merged = flatten(aggregatedState);
        var highestState = getHighestState(merged);
        var aggregateDesc = aggregateDescription(merged);
        return {
            description: aggregateDesc,
            value: highestState.state,
        };
    }

    function gw3 (connection, config) {
        var _this = this;
        if (!connection || typeof connection !== "object") {
            throw new Error("Connection is required parameter");
        }
        var joinPromise;
        var session;
        var init = function (repo) {
            var resolveReadyPromise;
            joinPromise = new Promise(function (resolve) {
                resolveReadyPromise = resolve;
            });
            session = connection.domain("metrics");
            session.onJoined(function (reconnect) {
                if (!reconnect && resolveReadyPromise) {
                    resolveReadyPromise();
                    resolveReadyPromise = undefined;
                }
                var rootStateMetric = {
                    name: "/State",
                    type: "object",
                    composite: {
                        Description: {
                            type: "string",
                            description: "",
                        },
                        Value: {
                            type: "number",
                            description: "",
                        },
                    },
                    description: "System state",
                    context: {},
                };
                var defineRootMetricsMsg = {
                    type: "define",
                    metrics: [rootStateMetric],
                };
                session.send(defineRootMetricsMsg);
                if (reconnect) {
                    replayRepo(repo);
                }
            });
            session.join({
                system: config.system,
                service: config.service,
                instance: config.instance
            });
        };
        var replayRepo = function (repo) {
            replaySystem(repo.root);
        };
        var replaySystem = function (system) {
            createSystem(system);
            system.metrics.forEach(function (m) {
                createMetric(m);
            });
            system.subSystems.forEach(function (ss) {
                replaySystem(ss);
            });
        };
        var createSystem = function (system) { return __awaiter$1(_this, void 0, void 0, function () {
            var metric, createMetricsMsg;
            return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (system.parent === undefined) {
                            return [2];
                        }
                        return [4, joinPromise];
                    case 1:
                        _a.sent();
                        metric = {
                            name: normalizeMetricName(system.path.join("/") + "/" + system.name + "/State"),
                            type: "object",
                            composite: {
                                Description: {
                                    type: "string",
                                    description: "",
                                },
                                Value: {
                                    type: "number",
                                    description: "",
                                },
                            },
                            description: "System state",
                            context: {},
                        };
                        createMetricsMsg = {
                            type: "define",
                            metrics: [metric],
                        };
                        session.send(createMetricsMsg);
                        return [2];
                }
            });
        }); };
        var updateSystem = function (system, state) { return __awaiter$1(_this, void 0, void 0, function () {
            var shadowedUpdateMetric, stateObj, rootMetric;
            return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, joinPromise];
                    case 1:
                        _a.sent();
                        shadowedUpdateMetric = {
                            type: "publish",
                            values: [{
                                    name: normalizeMetricName(system.path.join("/") + "/" + system.name + "/State"),
                                    value: {
                                        Description: state.description,
                                        Value: state.state,
                                    },
                                    timestamp: Date.now(),
                                }],
                        };
                        session.send(shadowedUpdateMetric);
                        stateObj = composeMsgForRootStateMetric(system);
                        rootMetric = {
                            type: "publish",
                            peer_id: connection.peerId,
                            values: [{
                                    name: "/State",
                                    value: {
                                        Description: stateObj.description,
                                        Value: stateObj.value,
                                    },
                                    timestamp: Date.now(),
                                }],
                        };
                        session.send(rootMetric);
                        return [2];
                }
            });
        }); };
        var createMetric = function (metric) { return __awaiter$1(_this, void 0, void 0, function () {
            var metricClone, m, createMetricsMsg;
            return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        metricClone = cloneMetric(metric);
                        return [4, joinPromise];
                    case 1:
                        _a.sent();
                        m = serializeMetric(metricClone);
                        createMetricsMsg = {
                            type: "define",
                            metrics: [m],
                        };
                        session.send(createMetricsMsg);
                        if (typeof metricClone.value !== "undefined") {
                            updateMetricCore(metricClone);
                        }
                        return [2];
                }
            });
        }); };
        var updateMetric = function (metric) { return __awaiter$1(_this, void 0, void 0, function () {
            var metricClone;
            return __generator$1(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        metricClone = cloneMetric(metric);
                        return [4, joinPromise];
                    case 1:
                        _a.sent();
                        updateMetricCore(metricClone);
                        return [2];
                }
            });
        }); };
        var updateMetricCore = function (metric) {
            if (canUpdate()) {
                var value = getMetricValueByType(metric);
                var publishMetricsMsg = {
                    type: "publish",
                    values: [{
                            name: normalizeMetricName(metric.path.join("/") + "/" + metric.name),
                            value: value,
                            timestamp: Date.now(),
                        }],
                };
                return session.sendFireAndForget(publishMetricsMsg);
            }
            return Promise.resolve();
        };
        var cloneMetric = function (metric) {
            var metricClone = __assign$1({}, metric);
            if (typeof metric.value === "object" && metric.value !== null) {
                metricClone.value = __assign$1({}, metric.value);
            }
            return metricClone;
        };
        var canUpdate = function () {
            var _a;
            try {
                var func = (_a = config.canUpdateMetric) !== null && _a !== void 0 ? _a : (function () { return true; });
                return func();
            }
            catch (_b) {
                return true;
            }
        };
        return {
            init: init,
            createSystem: createSystem,
            updateSystem: updateSystem,
            createMetric: createMetric,
            updateMetric: updateMetric,
        };
    }

    var Helpers = {
        validate: function (definition, parent, transport) {
            if (definition === null || typeof definition !== "object") {
                throw new Error("Missing definition");
            }
            if (parent === null || typeof parent !== "object") {
                throw new Error("Missing parent");
            }
            if (transport === null || typeof transport !== "object") {
                throw new Error("Missing transport");
            }
        },
    };

    var BaseMetric = (function () {
        function BaseMetric(definition, system, transport, value, type) {
            this.definition = definition;
            this.system = system;
            this.transport = transport;
            this.value = value;
            this.type = type;
            this.path = [];
            Helpers.validate(definition, system, transport);
            this.path = system.path.slice(0);
            this.path.push(system.name);
            this.name = definition.name;
            this.description = definition.description;
            transport.createMetric(this);
        }
        Object.defineProperty(BaseMetric.prototype, "repo", {
            get: function () {
                var _a;
                return (_a = this.system) === null || _a === void 0 ? void 0 : _a.repo;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMetric.prototype, "id", {
            get: function () { return this.system.path + "/" + name; },
            enumerable: true,
            configurable: true
        });
        BaseMetric.prototype.update = function (newValue) {
            this.value = newValue;
            return this.transport.updateMetric(this);
        };
        return BaseMetric;
    }());

    var NumberMetric = (function (_super) {
        __extends$1(NumberMetric, _super);
        function NumberMetric(definition, system, transport, value) {
            return _super.call(this, definition, system, transport, value, MetricTypes.NUMBER) || this;
        }
        NumberMetric.prototype.incrementBy = function (num) {
            this.update(this.value + num);
        };
        NumberMetric.prototype.increment = function () {
            this.incrementBy(1);
        };
        NumberMetric.prototype.decrement = function () {
            this.incrementBy(-1);
        };
        NumberMetric.prototype.decrementBy = function (num) {
            this.incrementBy(num * -1);
        };
        return NumberMetric;
    }(BaseMetric));

    var ObjectMetric = (function (_super) {
        __extends$1(ObjectMetric, _super);
        function ObjectMetric(definition, system, transport, value) {
            return _super.call(this, definition, system, transport, value, MetricTypes.OBJECT) || this;
        }
        ObjectMetric.prototype.update = function (newValue) {
            this.mergeValues(newValue);
            return this.transport.updateMetric(this);
        };
        ObjectMetric.prototype.mergeValues = function (values) {
            var _this = this;
            return Object.keys(this.value).forEach(function (k) {
                if (typeof values[k] !== "undefined") {
                    _this.value[k] = values[k];
                }
            });
        };
        return ObjectMetric;
    }(BaseMetric));

    var StringMetric = (function (_super) {
        __extends$1(StringMetric, _super);
        function StringMetric(definition, system, transport, value) {
            return _super.call(this, definition, system, transport, value, MetricTypes.STRING) || this;
        }
        return StringMetric;
    }(BaseMetric));

    var TimestampMetric = (function (_super) {
        __extends$1(TimestampMetric, _super);
        function TimestampMetric(definition, system, transport, value) {
            return _super.call(this, definition, system, transport, value, MetricTypes.TIMESTAMP) || this;
        }
        TimestampMetric.prototype.now = function () {
            this.update(new Date());
        };
        return TimestampMetric;
    }(BaseMetric));

    function system(name, repo, protocol, parent, description) {
        if (!repo) {
            throw new Error("Repository is required");
        }
        if (!protocol) {
            throw new Error("Transport is required");
        }
        var _transport = protocol;
        var _name = name;
        var _description = description || "";
        var _repo = repo;
        var _parent = parent;
        var _path = _buildPath(parent);
        var _state = {};
        var id = _arrayToString(_path, "/") + name;
        var root = repo.root;
        var _subSystems = [];
        var _metrics = [];
        function subSystem(nameSystem, descriptionSystem) {
            if (!nameSystem || nameSystem.length === 0) {
                throw new Error("name is required");
            }
            var match = _subSystems.filter(function (s) { return s.name === nameSystem; });
            if (match.length > 0) {
                return match[0];
            }
            var _system = system(nameSystem, _repo, _transport, me, descriptionSystem);
            _subSystems.push(_system);
            return _system;
        }
        function setState(state, stateDescription) {
            _state = { state: state, description: stateDescription };
            _transport.updateSystem(me, _state);
        }
        function stringMetric(definition, value) {
            return _getOrCreateMetric(definition, MetricTypes.STRING, value, function (metricDef) { return new StringMetric(metricDef, me, _transport, value); });
        }
        function numberMetric(definition, value) {
            return _getOrCreateMetric(definition, MetricTypes.NUMBER, value, function (metricDef) { return new NumberMetric(metricDef, me, _transport, value); });
        }
        function objectMetric(definition, value) {
            return _getOrCreateMetric(definition, MetricTypes.OBJECT, value, function (metricDef) { return new ObjectMetric(metricDef, me, _transport, value); });
        }
        function timestampMetric(definition, value) {
            return _getOrCreateMetric(definition, MetricTypes.TIMESTAMP, value, function (metricDef) { return new TimestampMetric(metricDef, me, _transport, value); });
        }
        function _getOrCreateMetric(metricObject, expectedType, value, createMetric) {
            var metricDef = { name: "" };
            if (typeof metricObject === "string") {
                metricDef = { name: metricObject };
            }
            else {
                metricDef = metricObject;
            }
            var matching = _metrics.filter(function (shadowedMetric) { return shadowedMetric.name === metricDef.name; });
            if (matching.length > 0) {
                var existing = matching[0];
                if (existing.type !== expectedType) {
                    throw new Error("A metric named " + metricDef.name + " is already defined with different type.");
                }
                if (typeof value !== "undefined") {
                    existing
                        .update(value)
                        .catch(function () { });
                }
                return existing;
            }
            var metric = createMetric(metricDef);
            _metrics.push(metric);
            return metric;
        }
        function _buildPath(shadowedSystem) {
            if (!shadowedSystem || !shadowedSystem.parent) {
                return [];
            }
            var path = _buildPath(shadowedSystem.parent);
            path.push(shadowedSystem.name);
            return path;
        }
        function _arrayToString(path, separator) {
            return ((path && path.length > 0) ? path.join(separator) : "");
        }
        function getAggregateState() {
            var aggState = [];
            if (Object.keys(_state).length > 0) {
                aggState.push({
                    name: _name,
                    path: _path,
                    state: _state.state,
                    description: _state.description,
                });
            }
            _subSystems.forEach(function (shadowedSubSystem) {
                var result = shadowedSubSystem.getAggregateState();
                if (result.length > 0) {
                    aggState.push.apply(aggState, result);
                }
            });
            return aggState;
        }
        var me = {
            get name() {
                return _name;
            },
            get description() {
                return _description;
            },
            get repo() {
                return _repo;
            },
            get parent() {
                return _parent;
            },
            path: _path,
            id: id,
            root: root,
            get subSystems() {
                return _subSystems;
            },
            get metrics() {
                return _metrics;
            },
            subSystem: subSystem,
            getState: function () {
                return _state;
            },
            setState: setState,
            stringMetric: stringMetric,
            timestampMetric: timestampMetric,
            objectMetric: objectMetric,
            numberMetric: numberMetric,
            getAggregateState: getAggregateState,
        };
        _transport.createSystem(me);
        return me;
    }

    var Repository = (function () {
        function Repository(options, protocol) {
            protocol.init(this);
            this.root = system("", this, protocol);
            this.addSystemMetrics(this.root, options.clickStream || options.clickStream === undefined);
        }
        Repository.prototype.addSystemMetrics = function (rootSystem, useClickStream) {
            if (typeof navigator !== "undefined") {
                rootSystem.stringMetric("UserAgent", navigator.userAgent);
            }
            if (useClickStream && typeof document !== "undefined") {
                var clickStream_1 = rootSystem.subSystem("ClickStream");
                var documentClickHandler = function (e) {
                    if (!e.target) {
                        return;
                    }
                    var target = e.target;
                    clickStream_1.objectMetric("LastBrowserEvent", {
                        type: "click",
                        timestamp: new Date(),
                        target: {
                            className: e.target ? target.className : "",
                            id: target.id,
                            type: "<" + target.tagName.toLowerCase() + ">",
                            href: target.href || "",
                        },
                    });
                };
                clickStream_1.objectMetric("Page", {
                    title: document.title,
                    page: window.location.href,
                });
                if (document.addEventListener) {
                    document.addEventListener("click", documentClickHandler);
                }
                else {
                    document.attachEvent("onclick", documentClickHandler);
                }
            }
            var startTime = rootSystem.stringMetric("StartTime", (new Date()).toString());
            var urlMetric = rootSystem.stringMetric("StartURL", "");
            var appNameMetric = rootSystem.stringMetric("AppName", "");
            if (typeof window !== "undefined") {
                if (typeof window.location !== "undefined") {
                    var startUrl = window.location.href;
                    urlMetric.update(startUrl);
                }
                if (typeof window.glue42gd !== "undefined") {
                    appNameMetric.update(window.glue42gd.appName);
                }
            }
        };
        return Repository;
    }());

    var NullProtocol = (function () {
        function NullProtocol() {
        }
        NullProtocol.prototype.init = function (repo) {
        };
        NullProtocol.prototype.createSystem = function (system) {
            return Promise.resolve();
        };
        NullProtocol.prototype.updateSystem = function (metric, state) {
            return Promise.resolve();
        };
        NullProtocol.prototype.createMetric = function (metric) {
            return Promise.resolve();
        };
        NullProtocol.prototype.updateMetric = function (metric) {
            return Promise.resolve();
        };
        return NullProtocol;
    }());

    var PerfTracker = (function () {
        function PerfTracker(api, initialPublishTimeout, publishInterval) {
            this.api = api;
            this.lastCount = 0;
            this.initialPublishTimeout = 10 * 1000;
            this.publishInterval = 60 * 1000;
            this.initialPublishTimeout = initialPublishTimeout !== null && initialPublishTimeout !== void 0 ? initialPublishTimeout : this.initialPublishTimeout;
            this.publishInterval = publishInterval !== null && publishInterval !== void 0 ? publishInterval : this.publishInterval;
            this.scheduleCollection();
            this.system = this.api.subSystem("performance", "Performance data published by the web application");
        }
        PerfTracker.prototype.scheduleCollection = function () {
            var _this = this;
            setTimeout(function () {
                _this.collect();
                setInterval(function () {
                    _this.collect();
                }, _this.publishInterval);
            }, this.initialPublishTimeout);
        };
        PerfTracker.prototype.collect = function () {
            try {
                this.collectMemory();
                this.collectEntries();
            }
            catch (_a) {
            }
        };
        PerfTracker.prototype.collectMemory = function () {
            var memory = window.performance.memory;
            this.system.stringMetric("memory", JSON.stringify({
                totalJSHeapSize: memory.totalJSHeapSize,
                usedJSHeapSize: memory.usedJSHeapSize
            }));
        };
        PerfTracker.prototype.collectEntries = function () {
            var allEntries = window.performance.getEntries();
            if (allEntries.length <= this.lastCount) {
                return;
            }
            this.lastCount = allEntries.length;
            var jsonfiedEntries = allEntries.map(function (i) { return i.toJSON(); });
            this.system.stringMetric("entries", JSON.stringify(jsonfiedEntries));
        };
        return PerfTracker;
    }());

    var metrics = (function (options) {
        var protocol;
        if (!options.connection || typeof options.connection !== "object") {
            protocol = new NullProtocol();
        }
        else {
            protocol = gw3(options.connection, options);
        }
        var repo = new Repository(options, protocol);
        var rootSystem = repo.root;
        if (!options.disableAutoAppSystem) {
            rootSystem = rootSystem.subSystem("App");
        }
        var api = addFAVSupport(rootSystem);
        initPerf(api, options.pagePerformanceMetrics);
        return api;
    });
    var perf;
    function initPerf(api, config) {
        var _a, _b;
        if (typeof window === "undefined") {
            return;
        }
        var perfConfig = (_b = (_a = window === null || window === void 0 ? void 0 : window.glue42gd) === null || _a === void 0 ? void 0 : _a.metrics) === null || _b === void 0 ? void 0 : _b.pagePerformanceMetrics;
        if (perfConfig) {
            config = perfConfig;
        }
        if (config === null || config === void 0 ? void 0 : config.enabled) {
            perf = new PerfTracker(api, config.initialPublishTimeout, config.publishInterval);
        }
    }
    function addFAVSupport(system) {
        var reportingSystem = system.subSystem("reporting");
        var def = {
            name: "features"
        };
        var featureMetric;
        var featureMetricFunc = function (name, action, payload) {
            if (typeof name === "undefined" || name === "") {
                throw new Error("name is mandatory");
            }
            else if (typeof action === "undefined" || action === "") {
                throw new Error("action is mandatory");
            }
            else if (typeof payload === "undefined" || payload === "") {
                throw new Error("payload is mandatory");
            }
            if (!featureMetric) {
                featureMetric = reportingSystem.objectMetric(def, { name: name, action: action, payload: payload });
            }
            else {
                featureMetric.update({
                    name: name,
                    action: action,
                    payload: payload
                });
            }
        };
        system.featureMetric = featureMetricFunc;
        return system;
    }

    function createRegistry(options) {
        if (options && options.errorHandling
            && typeof options.errorHandling !== "function"
            && options.errorHandling !== "log"
            && options.errorHandling !== "silent"
            && options.errorHandling !== "throw") {
            throw new Error("Invalid options passed to createRegistry. Prop errorHandling should be [\"log\" | \"silent\" | \"throw\" | (err) => void], but " + typeof options.errorHandling + " was passed");
        }
        var _userErrorHandler = options && typeof options.errorHandling === "function" && options.errorHandling;
        var callbacks = {};
        function add(key, callback, replayArgumentsArr) {
            var callbacksForKey = callbacks[key];
            if (!callbacksForKey) {
                callbacksForKey = [];
                callbacks[key] = callbacksForKey;
            }
            callbacksForKey.push(callback);
            if (replayArgumentsArr) {
                setTimeout(function () {
                    replayArgumentsArr.forEach(function (replayArgument) {
                        var _a;
                        if ((_a = callbacks[key]) === null || _a === void 0 ? void 0 : _a.includes(callback)) {
                            try {
                                if (Array.isArray(replayArgument)) {
                                    callback.apply(undefined, replayArgument);
                                }
                                else {
                                    callback.apply(undefined, [replayArgument]);
                                }
                            }
                            catch (err) {
                                _handleError(err, key);
                            }
                        }
                    });
                }, 0);
            }
            return function () {
                var allForKey = callbacks[key];
                if (!allForKey) {
                    return;
                }
                allForKey = allForKey.reduce(function (acc, element, index) {
                    if (!(element === callback && acc.length === index)) {
                        acc.push(element);
                    }
                    return acc;
                }, []);
                if (allForKey.length === 0) {
                    delete callbacks[key];
                }
                else {
                    callbacks[key] = allForKey;
                }
            };
        }
        function execute(key) {
            var argumentsArr = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                argumentsArr[_i - 1] = arguments[_i];
            }
            var callbacksForKey = callbacks[key];
            if (!callbacksForKey || callbacksForKey.length === 0) {
                return [];
            }
            var results = [];
            callbacksForKey.forEach(function (callback) {
                try {
                    var result = callback.apply(undefined, argumentsArr);
                    results.push(result);
                }
                catch (err) {
                    results.push(undefined);
                    _handleError(err, key);
                }
            });
            return results;
        }
        function _handleError(exceptionArtifact, key) {
            var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);
            if (_userErrorHandler) {
                _userErrorHandler(errParam);
                return;
            }
            var msg = "[ERROR] callback-registry: User callback for key \"" + key + "\" failed: " + errParam.stack;
            if (options) {
                switch (options.errorHandling) {
                    case "log":
                        return console.error(msg);
                    case "silent":
                        return;
                    case "throw":
                        throw new Error(msg);
                }
            }
            console.error(msg);
        }
        function clear() {
            callbacks = {};
        }
        function clearKey(key) {
            var callbacksForKey = callbacks[key];
            if (!callbacksForKey) {
                return;
            }
            delete callbacks[key];
        }
        return {
            add: add,
            execute: execute,
            clear: clear,
            clearKey: clearKey
        };
    }
    createRegistry.default = createRegistry;
    var lib = createRegistry;

    var InProcTransport = (function () {
        function InProcTransport(settings, logger) {
            var _this = this;
            this.registry = lib();
            this.gw = settings.facade;
            this.gw.connect(function (_client, message) {
                _this.messageHandler(message);
            }).then(function (client) {
                _this.client = client;
            });
        }
        Object.defineProperty(InProcTransport.prototype, "isObjectBasedTransport", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        InProcTransport.prototype.sendObject = function (msg) {
            if (this.client) {
                this.client.send(msg);
                return Promise.resolve(undefined);
            }
            else {
                return Promise.reject("not connected");
            }
        };
        InProcTransport.prototype.send = function (_msg) {
            return Promise.reject("not supported");
        };
        InProcTransport.prototype.onMessage = function (callback) {
            return this.registry.add("onMessage", callback);
        };
        InProcTransport.prototype.onConnectedChanged = function (callback) {
            callback(true);
        };
        InProcTransport.prototype.close = function () {
            return Promise.resolve();
        };
        InProcTransport.prototype.open = function () {
            return Promise.resolve();
        };
        InProcTransport.prototype.name = function () {
            return "in-memory";
        };
        InProcTransport.prototype.reconnect = function () {
            return Promise.resolve();
        };
        InProcTransport.prototype.messageHandler = function (msg) {
            this.registry.execute("onMessage", msg);
        };
        return InProcTransport;
    }());

    var SharedWorkerTransport = (function () {
        function SharedWorkerTransport(workerFile, logger) {
            var _this = this;
            this.logger = logger;
            this.registry = lib();
            this.worker = new SharedWorker(workerFile);
            this.worker.port.onmessage = function (e) {
                _this.messageHandler(e.data);
            };
        }
        Object.defineProperty(SharedWorkerTransport.prototype, "isObjectBasedTransport", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        SharedWorkerTransport.prototype.sendObject = function (msg) {
            this.worker.port.postMessage(msg);
            return Promise.resolve();
        };
        SharedWorkerTransport.prototype.send = function (_msg) {
            return Promise.reject("not supported");
        };
        SharedWorkerTransport.prototype.onMessage = function (callback) {
            return this.registry.add("onMessage", callback);
        };
        SharedWorkerTransport.prototype.onConnectedChanged = function (callback) {
            callback(true);
        };
        SharedWorkerTransport.prototype.close = function () {
            return Promise.resolve();
        };
        SharedWorkerTransport.prototype.open = function () {
            return Promise.resolve();
        };
        SharedWorkerTransport.prototype.name = function () {
            return "shared-worker";
        };
        SharedWorkerTransport.prototype.reconnect = function () {
            return Promise.resolve();
        };
        SharedWorkerTransport.prototype.messageHandler = function (msg) {
            this.registry.execute("onMessage", msg);
        };
        return SharedWorkerTransport;
    }());

    var Utils = (function () {
        function Utils() {
        }
        Utils.getGDMajorVersion = function () {
            if (typeof window === "undefined") {
                return undefined;
            }
            if (!window.glueDesktop) {
                return undefined;
            }
            if (!window.glueDesktop.version) {
                return undefined;
            }
            var ver = Number(window.glueDesktop.version.substr(0, 1));
            return isNaN(ver) ? undefined : ver;
        };
        Utils.isNode = function () {
            if (typeof Utils._isNode !== "undefined") {
                return Utils._isNode;
            }
            if (typeof window !== "undefined") {
                Utils._isNode = false;
                return false;
            }
            try {
                Utils._isNode = Object.prototype.toString.call(global.process) === "[object process]";
            }
            catch (e) {
                Utils._isNode = false;
            }
            return Utils._isNode;
        };
        return Utils;
    }());

    var PromiseWrapper = (function () {
        function PromiseWrapper() {
            var _this = this;
            this.rejected = false;
            this.resolved = false;
            this.promise = new Promise(function (resolve, reject) {
                _this.resolve = function (t) {
                    _this.resolved = true;
                    resolve(t);
                };
                _this.reject = function (err) {
                    _this.rejected = true;
                    reject(err);
                };
            });
        }
        PromiseWrapper.delay = function (time) {
            return new Promise(function (resolve) { return setTimeout(resolve, time); });
        };
        Object.defineProperty(PromiseWrapper.prototype, "ended", {
            get: function () {
                return this.rejected || this.resolved;
            },
            enumerable: true,
            configurable: true
        });
        return PromiseWrapper;
    }());

    var timers = {};
    function getAllTimers() {
        return timers;
    }
    function timer (timerName) {
        var existing = timers[timerName];
        if (existing) {
            return existing;
        }
        var marks = [];
        function now() {
            return new Date().getTime();
        }
        var startTime = now();
        mark("start", startTime);
        var endTime;
        var period;
        function stop() {
            endTime = now();
            mark("end", endTime);
            period = endTime - startTime;
            return period;
        }
        function mark(name, time) {
            var currentTime = time !== null && time !== void 0 ? time : now();
            var diff = 0;
            if (marks.length > 0) {
                diff = currentTime - marks[marks.length - 1].time;
            }
            marks.push({ name: name, time: currentTime, diff: diff });
        }
        var timerObj = {
            get startTime() {
                return startTime;
            },
            get endTime() {
                return endTime;
            },
            get period() {
                return period;
            },
            stop: stop,
            mark: mark,
            marks: marks
        };
        timers[timerName] = timerObj;
        return timerObj;
    }

    var WebSocketConstructor = Utils.isNode() ? null : window.WebSocket;
    var WS = (function () {
        function WS(settings, logger) {
            this.startupTimer = timer("connection");
            this._running = true;
            this._registry = lib();
            this.wsRequests = [];
            this.settings = settings;
            this.logger = logger;
            if (!this.settings.ws) {
                throw new Error("ws is missing");
            }
        }
        WS.prototype.onMessage = function (callback) {
            return this._registry.add("onMessage", callback);
        };
        WS.prototype.send = function (msg, options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.waitForSocketConnection(function () {
                    var _a;
                    try {
                        (_a = _this.ws) === null || _a === void 0 ? void 0 : _a.send(msg);
                        resolve();
                    }
                    catch (e) {
                        reject(e);
                    }
                }, reject);
            });
        };
        WS.prototype.open = function () {
            var _this = this;
            this.logger.info("opening ws...");
            this._running = true;
            return new Promise(function (resolve, reject) {
                _this.waitForSocketConnection(resolve, reject);
            });
        };
        WS.prototype.close = function () {
            this._running = false;
            if (this.ws) {
                this.ws.close();
            }
            return Promise.resolve();
        };
        WS.prototype.onConnectedChanged = function (callback) {
            return this._registry.add("onConnectedChanged", callback);
        };
        WS.prototype.name = function () {
            return "ws " + this.settings.ws;
        };
        WS.prototype.reconnect = function () {
            var _a;
            (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();
            var pw = new PromiseWrapper();
            this.waitForSocketConnection(function () {
                pw.resolve();
            });
            return pw.promise;
        };
        WS.prototype.waitForSocketConnection = function (callback, failed) {
            var _a;
            failed = failed !== null && failed !== void 0 ? failed : (function () { });
            if (!this._running) {
                failed("wait for socket on " + this.settings.ws + " failed - socket closed by user");
                return;
            }
            if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === 1) {
                callback();
                return;
            }
            this.wsRequests.push({ callback: callback, failed: failed });
            if (this.wsRequests.length > 1) {
                return;
            }
            this.openSocket();
        };
        WS.prototype.openSocket = function (retryInterval, retriesLeft) {
            return __awaiter$1(this, void 0, void 0, function () {
                var _a;
                var _this = this;
                return __generator$1(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.startupTimer.mark("opening-socket");
                            if (retryInterval === undefined) {
                                retryInterval = this.settings.reconnectInterval;
                            }
                            if (retriesLeft !== undefined) {
                                if (retriesLeft === 0) {
                                    this.notifyForSocketState("wait for socket on " + this.settings.ws + " failed - no more retries left");
                                    return [2];
                                }
                                this.logger.debug("will retry " + retriesLeft + " more times (every " + retryInterval + " ms)");
                            }
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4, this.initiateSocket()];
                        case 2:
                            _b.sent();
                            this.startupTimer.mark("socket-initiated");
                            this.notifyForSocketState();
                            return [3, 4];
                        case 3:
                            _a = _b.sent();
                            setTimeout(function () {
                                var retries = retriesLeft === undefined ? undefined : retriesLeft - 1;
                                _this.openSocket(retryInterval, retries);
                            }, retryInterval);
                            return [3, 4];
                        case 4: return [2];
                    }
                });
            });
        };
        WS.prototype.initiateSocket = function () {
            var _this = this;
            var pw = new PromiseWrapper();
            this.logger.debug("initiating ws to " + this.settings.ws + "...");
            this.ws = new WebSocketConstructor(this.settings.ws || "");
            this.ws.onerror = function (err) {
                var reason = "";
                try {
                    reason = JSON.stringify(err);
                }
                catch (error) {
                    var seen_1 = new WeakSet();
                    var replacer = function (key, value) {
                        if (typeof value === "object" && value !== null) {
                            if (seen_1.has(value)) {
                                return;
                            }
                            seen_1.add(value);
                        }
                        return value;
                    };
                    reason = JSON.stringify(err, replacer);
                }
                pw.reject("error");
                _this.notifyStatusChanged(false, reason);
            };
            this.ws.onclose = function (err) {
                _this.logger.info("ws closed " + err);
                pw.reject("closed");
                _this.notifyStatusChanged(false);
            };
            this.ws.onopen = function () {
                var _a;
                _this.startupTimer.mark("ws-opened");
                _this.logger.info("ws opened " + ((_a = _this.settings.identity) === null || _a === void 0 ? void 0 : _a.application));
                pw.resolve();
                _this.notifyStatusChanged(true);
            };
            this.ws.onmessage = function (message) {
                _this._registry.execute("onMessage", message.data);
            };
            return pw.promise;
        };
        WS.prototype.notifyForSocketState = function (error) {
            this.wsRequests.forEach(function (wsRequest) {
                if (error) {
                    if (wsRequest.failed) {
                        wsRequest.failed(error);
                    }
                }
                else {
                    wsRequest.callback();
                }
            });
            this.wsRequests = [];
        };
        WS.prototype.notifyStatusChanged = function (status, reason) {
            this._registry.execute("onConnectedChanged", status, reason);
        };
        return WS;
    }());

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    // Found this seed-based random generator somewhere
    // Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

    var seed = 1;

    /**
     * return a random number based on a seed
     * @param seed
     * @returns {number}
     */
    function getNextValue() {
        seed = (seed * 9301 + 49297) % 233280;
        return seed/(233280.0);
    }

    function setSeed(_seed_) {
        seed = _seed_;
    }

    var randomFromSeed = {
        nextValue: getNextValue,
        seed: setSeed
    };

    var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
    var alphabet;
    var previousSeed;

    var shuffled;

    function reset() {
        shuffled = false;
    }

    function setCharacters(_alphabet_) {
        if (!_alphabet_) {
            if (alphabet !== ORIGINAL) {
                alphabet = ORIGINAL;
                reset();
            }
            return;
        }

        if (_alphabet_ === alphabet) {
            return;
        }

        if (_alphabet_.length !== ORIGINAL.length) {
            throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
        }

        var unique = _alphabet_.split('').filter(function(item, ind, arr){
           return ind !== arr.lastIndexOf(item);
        });

        if (unique.length) {
            throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
        }

        alphabet = _alphabet_;
        reset();
    }

    function characters(_alphabet_) {
        setCharacters(_alphabet_);
        return alphabet;
    }

    function setSeed$1(seed) {
        randomFromSeed.seed(seed);
        if (previousSeed !== seed) {
            reset();
            previousSeed = seed;
        }
    }

    function shuffle() {
        if (!alphabet) {
            setCharacters(ORIGINAL);
        }

        var sourceArray = alphabet.split('');
        var targetArray = [];
        var r = randomFromSeed.nextValue();
        var characterIndex;

        while (sourceArray.length > 0) {
            r = randomFromSeed.nextValue();
            characterIndex = Math.floor(r * sourceArray.length);
            targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
        }
        return targetArray.join('');
    }

    function getShuffled() {
        if (shuffled) {
            return shuffled;
        }
        shuffled = shuffle();
        return shuffled;
    }

    /**
     * lookup shuffled letter
     * @param index
     * @returns {string}
     */
    function lookup(index) {
        var alphabetShuffled = getShuffled();
        return alphabetShuffled[index];
    }

    var alphabet_1 = {
        characters: characters,
        seed: setSeed$1,
        lookup: lookup,
        shuffled: getShuffled
    };

    var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

    function randomByte() {
        if (!crypto || !crypto.getRandomValues) {
            return Math.floor(Math.random() * 256) & 0x30;
        }
        var dest = new Uint8Array(1);
        crypto.getRandomValues(dest);
        return dest[0] & 0x30;
    }

    var randomByteBrowser = randomByte;

    function encode(lookup, number) {
        var loopCounter = 0;
        var done;

        var str = '';

        while (!done) {
            str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByteBrowser() );
            done = number < (Math.pow(16, loopCounter + 1 ) );
            loopCounter++;
        }
        return str;
    }

    var encode_1 = encode;

    /**
     * Decode the id to get the version and worker
     * Mainly for debugging and testing.
     * @param id - the shortid-generated id.
     */
    function decode(id) {
        var characters = alphabet_1.shuffled();
        return {
            version: characters.indexOf(id.substr(0, 1)) & 0x0f,
            worker: characters.indexOf(id.substr(1, 1)) & 0x0f
        };
    }

    var decode_1 = decode;

    function isShortId(id) {
        if (!id || typeof id !== 'string' || id.length < 6 ) {
            return false;
        }

        var characters = alphabet_1.characters();
        var len = id.length;
        for(var i = 0; i < len;i++) {
            if (characters.indexOf(id[i]) === -1) {
                return false;
            }
        }
        return true;
    }

    var isValid = isShortId;

    var lib$1 = createCommonjsModule(function (module) {






    // Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
    // This number should be updated every year or so to keep the generated id short.
    // To regenerate `new Date() - 0` and bump the version. Always bump the version!
    var REDUCE_TIME = 1459707606518;

    // don't change unless we change the algos or REDUCE_TIME
    // must be an integer and less than 16
    var version = 6;

    // if you are using cluster or multiple servers use this to make each instance
    // has a unique value for worker
    // Note: I don't know if this is automatically set when using third
    // party cluster solutions such as pm2.
    var clusterWorkerId =  0;

    // Counter is used when shortid is called multiple times in one second.
    var counter;

    // Remember the last time shortid was called in case counter is needed.
    var previousSeconds;

    /**
     * Generate unique id
     * Returns string id
     */
    function generate() {

        var str = '';

        var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

        if (seconds === previousSeconds) {
            counter++;
        } else {
            counter = 0;
            previousSeconds = seconds;
        }

        str = str + encode_1(alphabet_1.lookup, version);
        str = str + encode_1(alphabet_1.lookup, clusterWorkerId);
        if (counter > 0) {
            str = str + encode_1(alphabet_1.lookup, counter);
        }
        str = str + encode_1(alphabet_1.lookup, seconds);

        return str;
    }


    /**
     * Set the seed.
     * Highly recommended if you don't want people to try to figure out your id schema.
     * exposed as shortid.seed(int)
     * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
     */
    function seed(seedValue) {
        alphabet_1.seed(seedValue);
        return module.exports;
    }

    /**
     * Set the cluster worker or machine id
     * exposed as shortid.worker(int)
     * @param workerId worker must be positive integer.  Number less than 16 is recommended.
     * returns shortid module so it can be chained.
     */
    function worker(workerId) {
        clusterWorkerId = workerId;
        return module.exports;
    }

    /**
     *
     * sets new characters to use in the alphabet
     * returns the shuffled alphabet
     */
    function characters(newCharacters) {
        if (newCharacters !== undefined) {
            alphabet_1.characters(newCharacters);
        }

        return alphabet_1.shuffled();
    }


    // Export all other functions as properties of the generate function
    module.exports = generate;
    module.exports.generate = generate;
    module.exports.seed = seed;
    module.exports.worker = worker;
    module.exports.characters = characters;
    module.exports.decode = decode_1;
    module.exports.isValid = isValid;
    });
    var lib_1 = lib$1.generate;
    var lib_2 = lib$1.seed;
    var lib_3 = lib$1.worker;
    var lib_4 = lib$1.characters;
    var lib_5 = lib$1.decode;
    var lib_6 = lib$1.isValid;

    var shortid = lib$1;

    function domainSession (domain, connection, logger, successMessages, errorMessages) {
        if (domain == null) {
            domain = "global";
        }
        successMessages = successMessages || ["success"];
        errorMessages = errorMessages || ["error"];
        var isJoined = false;
        var tryReconnecting = false;
        var _latestOptions;
        var _connectionOn = false;
        var callbacks = lib();
        connection.disconnected(handleConnectionDisconnected);
        connection.loggedIn(handleConnectionLoggedIn);
        connection.on("success", function (msg) { return handleSuccessMessage(msg); });
        connection.on("error", function (msg) { return handleErrorMessage(msg); });
        connection.on("result", function (msg) { return handleSuccessMessage(msg); });
        if (successMessages) {
            successMessages.forEach(function (sm) {
                connection.on(sm, function (msg) { return handleSuccessMessage(msg); });
            });
        }
        if (errorMessages) {
            errorMessages.forEach(function (sm) {
                connection.on(sm, function (msg) { return handleErrorMessage(msg); });
            });
        }
        var requestsMap = {};
        function join(options) {
            _latestOptions = options;
            return new Promise(function (resolve, reject) {
                if (isJoined) {
                    resolve();
                    return;
                }
                var joinPromise;
                if (domain === "global") {
                    joinPromise = _connectionOn ? Promise.resolve({}) : Promise.reject("not connected to gateway");
                }
                else {
                    logger.debug("joining domain " + domain);
                    var joinMsg = {
                        type: "join",
                        destination: domain,
                        domain: "global",
                        options: options,
                    };
                    joinPromise = send(joinMsg);
                }
                joinPromise
                    .then(function () {
                    handleJoined();
                    resolve();
                })
                    .catch(function (err) {
                    logger.debug("error joining " + domain + " domain: " + JSON.stringify(err));
                    reject(err);
                });
            });
        }
        function leave() {
            if (domain === "global") {
                return Promise.resolve();
            }
            logger.debug("stopping session " + domain + "...");
            var leaveMsg = {
                type: "leave",
                destination: domain,
                domain: "global",
            };
            tryReconnecting = false;
            return send(leaveMsg).then(function () {
                isJoined = false;
                callbacks.execute("onLeft");
            });
        }
        function handleJoined() {
            logger.debug("did join " + domain);
            isJoined = true;
            var wasReconnect = tryReconnecting;
            tryReconnecting = false;
            callbacks.execute("onJoined", wasReconnect);
        }
        function handleConnectionDisconnected() {
            _connectionOn = false;
            logger.debug("connection is down");
            isJoined = false;
            tryReconnecting = true;
            callbacks.execute("onLeft", { disconnected: true });
        }
        function handleConnectionLoggedIn() {
            _connectionOn = true;
            if (tryReconnecting) {
                logger.debug("connection is now up - trying to reconnect...");
                join(_latestOptions);
            }
        }
        function onJoined(callback) {
            if (isJoined) {
                callback(false);
            }
            return callbacks.add("onJoined", callback);
        }
        function onLeft(callback) {
            if (!isJoined) {
                callback();
            }
            return callbacks.add("onLeft", callback);
        }
        function handleErrorMessage(msg) {
            if (domain !== msg.domain) {
                return;
            }
            var requestId = msg.request_id;
            if (!requestId) {
                return;
            }
            var entry = requestsMap[requestId];
            if (!entry) {
                return;
            }
            entry.error(msg);
        }
        function handleSuccessMessage(msg) {
            if (msg.domain !== domain) {
                return;
            }
            var requestId = msg.request_id;
            if (!requestId) {
                return;
            }
            var entry = requestsMap[requestId];
            if (!entry) {
                return;
            }
            entry.success(msg);
        }
        function getNextRequestId() {
            return shortid();
        }
        function send(msg, tag, options) {
            options = options || {};
            msg.request_id = msg.request_id || getNextRequestId();
            msg.domain = msg.domain || domain;
            if (!options.skipPeerId) {
                msg.peer_id = connection.peerId;
            }
            var requestId = msg.request_id;
            return new Promise(function (resolve, reject) {
                requestsMap[requestId] = {
                    success: function (successMsg) {
                        delete requestsMap[requestId];
                        successMsg._tag = tag;
                        resolve(successMsg);
                    },
                    error: function (errorMsg) {
                        logger.warn("GW error - " + JSON.stringify(errorMsg) + " for request " + JSON.stringify(msg));
                        delete requestsMap[requestId];
                        errorMsg._tag = tag;
                        reject(errorMsg);
                    },
                };
                connection
                    .send(msg, options)
                    .catch(function (err) {
                    requestsMap[requestId].error({ err: err });
                });
            });
        }
        function sendFireAndForget(msg) {
            msg.request_id = msg.request_id ? msg.request_id : getNextRequestId();
            msg.domain = msg.domain || domain;
            msg.peer_id = connection.peerId;
            return connection.send(msg);
        }
        return {
            join: join,
            leave: leave,
            onJoined: onJoined,
            onLeft: onLeft,
            send: send,
            sendFireAndForget: sendFireAndForget,
            on: function (type, callback) {
                connection.on(type, function (msg) {
                    if (msg.domain !== domain) {
                        return;
                    }
                    try {
                        callback(msg);
                    }
                    catch (e) {
                        logger.error("Callback  failed: " + e + " \n " + e.stack + " \n msg was: " + JSON.stringify(msg), e);
                    }
                });
            },
            loggedIn: function (callback) { return connection.loggedIn(callback); },
            connected: function (callback) { return connection.connected(callback); },
            disconnected: function (callback) { return connection.disconnected(callback); },
            get peerId() {
                return connection.peerId;
            },
            get domain() {
                return domain;
            },
        };
    }

    var GW3ProtocolImpl = (function () {
        function GW3ProtocolImpl(connection, settings, logger) {
            var _this = this;
            this.connection = connection;
            this.settings = settings;
            this.logger = logger;
            this.protocolVersion = 3;
            this.datePrefix = "#T42_DATE#";
            this.datePrefixLen = this.datePrefix.length;
            this.dateMinLen = this.datePrefixLen + 1;
            this.datePrefixFirstChar = this.datePrefix[0];
            this.registry = lib();
            this._isLoggedIn = false;
            this.shouldTryLogin = true;
            this.initialLogin = true;
            this.initialLoginAttempts = 3;
            this.sessions = [];
            connection.disconnected(function () {
                _this.handleDisconnected();
            });
            this.ping();
        }
        Object.defineProperty(GW3ProtocolImpl.prototype, "isLoggedIn", {
            get: function () {
                return this._isLoggedIn;
            },
            enumerable: true,
            configurable: true
        });
        GW3ProtocolImpl.prototype.processStringMessage = function (message) {
            var _this = this;
            var msg = JSON.parse(message, function (key, value) {
                if (typeof value !== "string") {
                    return value;
                }
                if (value.length < _this.dateMinLen) {
                    return value;
                }
                if (value[0] !== _this.datePrefixFirstChar) {
                    return value;
                }
                if (value.substring(0, _this.datePrefixLen) !== _this.datePrefix) {
                    return value;
                }
                try {
                    var milliseconds = parseInt(value.substring(_this.datePrefixLen, value.length), 10);
                    if (isNaN(milliseconds)) {
                        return value;
                    }
                    return new Date(milliseconds);
                }
                catch (ex) {
                    return value;
                }
            });
            return {
                msg: msg,
                msgType: msg.type,
            };
        };
        GW3ProtocolImpl.prototype.createStringMessage = function (message) {
            var oldToJson = Date.prototype.toJSON;
            try {
                var datePrefix_1 = this.datePrefix;
                Date.prototype.toJSON = function () {
                    return datePrefix_1 + this.getTime();
                };
                var result = JSON.stringify(message);
                return result;
            }
            finally {
                Date.prototype.toJSON = oldToJson;
            }
        };
        GW3ProtocolImpl.prototype.processObjectMessage = function (message) {
            if (!message.type) {
                throw new Error("Object should have type property");
            }
            return {
                msg: message,
                msgType: message.type,
            };
        };
        GW3ProtocolImpl.prototype.createObjectMessage = function (message) {
            return message;
        };
        GW3ProtocolImpl.prototype.login = function (config, reconnect) {
            return __awaiter$1(this, void 0, void 0, function () {
                var authentication, token, e_1, _a, helloMsg, sendOptions, welcomeMsg, msg, token, _b, err_1;
                return __generator$1(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            this.logger.debug("logging in...");
                            this.loginConfig = config;
                            if (!this.loginConfig) {
                                this.loginConfig = { username: "", password: "" };
                            }
                            this.shouldTryLogin = true;
                            authentication = {};
                            this.connection.gatewayToken = config.gatewayToken;
                            if (!config.gatewayToken) return [3, 5];
                            if (!reconnect) return [3, 4];
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 3, , 4]);
                            return [4, this.getNewGWToken()];
                        case 2:
                            token = _c.sent();
                            config.gatewayToken = token;
                            return [3, 4];
                        case 3:
                            e_1 = _c.sent();
                            this.logger.warn("failed to get GW token when reconnecting " + ((e_1 === null || e_1 === void 0 ? void 0 : e_1.message) || e_1));
                            return [3, 4];
                        case 4:
                            authentication.method = "gateway-token";
                            authentication.token = config.gatewayToken;
                            this.connection.gatewayToken = config.gatewayToken;
                            return [3, 10];
                        case 5:
                            if (!(config.flowName === "sspi")) return [3, 9];
                            authentication.provider = "win";
                            authentication.method = "access-token";
                            if (!(config.flowCallback && config.sessionId)) return [3, 7];
                            _a = authentication;
                            return [4, config.flowCallback(config.sessionId, null)];
                        case 6:
                            _a.token =
                                (_c.sent())
                                    .data
                                    .toString("base64");
                            return [3, 8];
                        case 7: throw new Error("Invalid SSPI config");
                        case 8: return [3, 10];
                        case 9:
                            if (config.token) {
                                authentication.method = "access-token";
                                authentication.token = config.token;
                            }
                            else if (config.username) {
                                authentication.method = "secret";
                                authentication.login = config.username;
                                authentication.secret = config.password;
                            }
                            else {
                                throw new Error("invalid auth message" + JSON.stringify(config));
                            }
                            _c.label = 10;
                        case 10:
                            helloMsg = {
                                type: "hello",
                                identity: this.settings.identity,
                                authentication: authentication
                            };
                            if (config.sessionId) {
                                helloMsg.request_id = config.sessionId;
                            }
                            this.globalDomain = domainSession("global", this.connection, this.logger.subLogger("global-domain"), [
                                "welcome",
                                "token",
                                "authentication-request"
                            ]);
                            sendOptions = { skipPeerId: true };
                            if (this.initialLogin) {
                                sendOptions.retryInterval = this.settings.reconnectInterval;
                                sendOptions.maxRetries = this.settings.reconnectAttempts;
                            }
                            _c.label = 11;
                        case 11:
                            _c.trys.push([11, 19, 20, 21]);
                            welcomeMsg = void 0;
                            _c.label = 12;
                        case 12:
                            return [4, this.globalDomain.send(helloMsg, undefined, sendOptions)];
                        case 13:
                            msg = _c.sent();
                            if (!(msg.type === "authentication-request")) return [3, 16];
                            token = Buffer.from(msg.authentication.token, "base64");
                            if (!(config.flowCallback && config.sessionId)) return [3, 15];
                            _b = helloMsg.authentication;
                            return [4, config.flowCallback(config.sessionId, token)];
                        case 14:
                            _b.token =
                                (_c.sent())
                                    .data
                                    .toString("base64");
                            _c.label = 15;
                        case 15:
                            helloMsg.request_id = config.sessionId;
                            return [3, 12];
                        case 16:
                            if (msg.type === "welcome") {
                                welcomeMsg = msg;
                                return [3, 18];
                            }
                            else if (msg.type === "error") {
                                throw new Error("Authentication failed: " + msg.reason);
                            }
                            else {
                                throw new Error("Unexpected message type during authentication: " + msg.type);
                            }
                        case 17: return [3, 12];
                        case 18:
                            this.initialLogin = false;
                            this.logger.debug("login successful with peerId " + welcomeMsg.peer_id);
                            this.connection.peerId = welcomeMsg.peer_id;
                            this.connection.resolvedIdentity = welcomeMsg.resolved_identity;
                            this.connection.availableDomains = welcomeMsg.available_domains;
                            if (welcomeMsg.options) {
                                this.connection.token = welcomeMsg.options.access_token;
                                this.connection.info = welcomeMsg.options.info;
                            }
                            this.setLoggedIn(true);
                            return [2, welcomeMsg.resolved_identity];
                        case 19:
                            err_1 = _c.sent();
                            this.logger.error("error sending hello message - " + (err_1.message || err_1.msg || err_1.reason || err_1), err_1);
                            throw err_1;
                        case 20:
                            if (config && config.flowCallback && config.sessionId) {
                                config.flowCallback(config.sessionId, null);
                            }
                            return [7];
                        case 21: return [2];
                    }
                });
            });
        };
        GW3ProtocolImpl.prototype.logout = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                var promises;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.logger.debug("logging out...");
                            this.shouldTryLogin = false;
                            if (this.pingTimer) {
                                clearTimeout(this.pingTimer);
                            }
                            promises = this.sessions.map(function (session) {
                                session.leave();
                            });
                            return [4, Promise.all(promises)];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        GW3ProtocolImpl.prototype.loggedIn = function (callback) {
            if (this._isLoggedIn) {
                callback();
            }
            return this.registry.add("onLoggedIn", callback);
        };
        GW3ProtocolImpl.prototype.domain = function (domainName, domainLogger, successMessages, errorMessages) {
            var session = this.sessions.filter(function (s) { return s.domain === domainName; })[0];
            if (!session) {
                session = domainSession(domainName, this.connection, domainLogger, successMessages, errorMessages);
                this.sessions.push(session);
            }
            return session;
        };
        GW3ProtocolImpl.prototype.handleDisconnected = function () {
            var _this = this;
            this.setLoggedIn(false);
            var tryToLogin = this.shouldTryLogin;
            if (tryToLogin && this.initialLogin) {
                if (this.initialLoginAttempts <= 0) {
                    return;
                }
                this.initialLoginAttempts--;
            }
            this.logger.debug("disconnected - will try new login?" + this.shouldTryLogin);
            if (this.shouldTryLogin) {
                if (!this.loginConfig) {
                    throw new Error("no login info");
                }
                this.connection.login(this.loginConfig, true)
                    .catch(function () {
                    setTimeout(_this.handleDisconnected.bind(_this), _this.settings.reconnectInterval || 1000);
                });
            }
        };
        GW3ProtocolImpl.prototype.setLoggedIn = function (value) {
            this._isLoggedIn = value;
            if (this._isLoggedIn) {
                this.registry.execute("onLoggedIn");
            }
        };
        GW3ProtocolImpl.prototype.ping = function () {
            var _this = this;
            if (!this.shouldTryLogin) {
                return;
            }
            if (this._isLoggedIn) {
                this.connection.send({ type: "ping" });
            }
            this.pingTimer = setTimeout(function () {
                _this.ping();
            }, 30 * 1000);
        };
        GW3ProtocolImpl.prototype.authToken = function () {
            var createTokenReq = {
                type: "create-token"
            };
            if (!this.globalDomain) {
                return Promise.reject(new Error("no global domain session"));
            }
            return this.globalDomain.send(createTokenReq)
                .then(function (res) {
                return res.token;
            });
        };
        GW3ProtocolImpl.prototype.getNewGWToken = function () {
            if (typeof window !== undefined) {
                var glue42gd = window.glue42gd;
                if (glue42gd) {
                    return glue42gd.getGWToken();
                }
            }
            return Promise.reject(new Error("not running in GD"));
        };
        return GW3ProtocolImpl;
    }());

    var MessageReplayerImpl = (function () {
        function MessageReplayerImpl(specs) {
            this.specsNames = [];
            this.messages = {};
            this.subs = {};
            this.subsRefCount = {};
            this.specs = {};
            for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
                var spec = specs_1[_i];
                this.specs[spec.name] = spec;
                this.specsNames.push(spec.name);
            }
        }
        MessageReplayerImpl.prototype.init = function (connection) {
            var _this = this;
            this.connection = connection;
            for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {
                var name_1 = _a[_i];
                var _loop_1 = function (type) {
                    var refCount = this_1.subsRefCount[type];
                    if (!refCount) {
                        refCount = 0;
                    }
                    refCount += 1;
                    this_1.subsRefCount[type] = refCount;
                    if (refCount > 1) {
                        return "continue";
                    }
                    var sub = connection.on(type, function (msg) { return _this.processMessage(type, msg); });
                    this_1.subs[type] = sub;
                };
                var this_1 = this;
                for (var _b = 0, _c = this.specs[name_1].types; _b < _c.length; _b++) {
                    var type = _c[_b];
                    _loop_1(type);
                }
            }
        };
        MessageReplayerImpl.prototype.processMessage = function (type, msg) {
            if (this.isDone || !msg) {
                return;
            }
            for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {
                var name_2 = _a[_i];
                if (this.specs[name_2].types.indexOf(type) !== -1) {
                    var messages = this.messages[name_2] || [];
                    this.messages[name_2] = messages;
                    messages.push(msg);
                }
            }
        };
        MessageReplayerImpl.prototype.drain = function (name, callback) {
            var _a;
            if (callback) {
                (this.messages[name] || []).forEach(callback);
            }
            delete this.messages[name];
            for (var _i = 0, _b = this.specs[name].types; _i < _b.length; _i++) {
                var type = _b[_i];
                this.subsRefCount[type] -= 1;
                if (this.subsRefCount[type] <= 0) {
                    (_a = this.connection) === null || _a === void 0 ? void 0 : _a.off(this.subs[type]);
                    delete this.subs[type];
                    delete this.subsRefCount[type];
                }
            }
            delete this.specs[name];
            if (!this.specs.length) {
                this.isDone = true;
            }
        };
        return MessageReplayerImpl;
    }());

    var PromisePlus = function (executor, timeoutMilliseconds, timeoutMessage) {
        return new Promise(function (resolve, reject) {
            var timeout = setTimeout(function () {
                var message = timeoutMessage || "Promise timeout hit: " + timeoutMilliseconds;
                reject(message);
            }, timeoutMilliseconds);
            var providedPromise = new Promise(executor);
            providedPromise
                .then(function (result) {
                clearTimeout(timeout);
                resolve(result);
            })
                .catch(function (error) {
                clearTimeout(timeout);
                reject(error);
            });
        });
    };

    var WebPlatformTransport = (function () {
        function WebPlatformTransport(settings, logger, identity) {
            this.settings = settings;
            this.logger = logger;
            this.identity = identity;
            this.parentReady = false;
            this.iAmConnected = false;
            this.rejected = false;
            this.children = [];
            this.parentPingTimeout = 3000;
            this.connectionRequestTimeout = 5000;
            this.defaultTargetString = "*";
            this.registry = lib();
            this.messages = {
                connectionAccepted: { name: "connectionAccepted", handle: this.handleConnectionAccepted.bind(this) },
                connectionRejected: { name: "connectionRejected", handle: this.handleConnectionRejected.bind(this) },
                connectionRequest: { name: "connectionRequest", handle: this.handleConnectionRequest.bind(this) },
                parentReady: { name: "parentReady", handle: this.handleParentReady.bind(this) },
                parentPing: { name: "parentPing", handle: this.handleParentPing.bind(this) },
                platformPing: { name: "platformPing", handle: this.handlePlatformPing.bind(this) },
                platformUnload: { name: "platformUnload", handle: this.handlePlatformUnload.bind(this) },
                platformReady: { name: "platformReady", handle: this.handlePlatformReady.bind(this) },
                clientUnload: { name: "clientUnload", handle: this.handleClientUnload.bind(this) },
                manualUnload: { name: "manualUnload", handle: this.handleManualUnload.bind(this) }
            };
            this.setUpMessageListener();
            this.setUpUnload();
            if (!this.settings.port) {
                this.parent = window.opener || window.top;
                this.parentType = window.opener ? "opener" :
                    window.name.indexOf("#wsp") !== -1 ? "workspace" : "top";
            }
        }
        Object.defineProperty(WebPlatformTransport.prototype, "transportWindowId", {
            get: function () {
                return this.publicWindowId;
            },
            enumerable: true,
            configurable: true
        });
        WebPlatformTransport.prototype.sendObject = function (msg) {
            return __awaiter$1(this, void 0, void 0, function () {
                return __generator$1(this, function (_a) {
                    if (!this.port) {
                        throw new Error("Cannot send message, because the port was not opened yet");
                    }
                    this.port.postMessage(msg);
                    return [2];
                });
            });
        };
        Object.defineProperty(WebPlatformTransport.prototype, "isObjectBasedTransport", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        WebPlatformTransport.prototype.onMessage = function (callback) {
            return this.registry.add("onMessage", callback);
        };
        WebPlatformTransport.prototype.send = function () {
            return Promise.reject("not supported");
        };
        WebPlatformTransport.prototype.onConnectedChanged = function (callback) {
            return this.registry.add("onConnectedChanged", callback);
        };
        WebPlatformTransport.prototype.open = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.logger.debug("opening a connection to the web platform gateway.");
                            return [4, this.connect()];
                        case 1:
                            _a.sent();
                            this.notifyStatusChanged(true);
                            return [2];
                    }
                });
            });
        };
        WebPlatformTransport.prototype.close = function () {
            return Promise.resolve();
        };
        WebPlatformTransport.prototype.name = function () {
            return "web-platform";
        };
        WebPlatformTransport.prototype.reconnect = function () {
            return Promise.resolve();
        };
        WebPlatformTransport.prototype.connect = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                var _this = this;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.parentReady) {
                                this.logger.debug("cancelling connection attempt, because this client's parent has already given a ready signal");
                                return [2];
                            }
                            if (this.settings.port) {
                                this.logger.debug("opening an internal web platform connection");
                                this.port = this.settings.port;
                                this.publicWindowId = this.settings.windowId;
                                if (this.identity) {
                                    this.identity.windowId = this.publicWindowId;
                                }
                                this.port.onmessage = function (event) { return _this.registry.execute("onMessage", event.data); };
                                this.logger.debug("internal web platform connection completed");
                                return [2];
                            }
                            if (!this.parentType || !this.parent) {
                                throw new Error("Cannot initiate a connection, because there is no opener, no top and no port.");
                            }
                            this.logger.debug("opening a " + (this.parentType === "opener" ? "child" : "grandchild") + " client web platform connection");
                            return [4, this.waitParent(this.parent, this.parentType)];
                        case 1:
                            _a.sent();
                            return [4, this.initiateRemoteConnection(this.parent, this.parentType)];
                        case 2:
                            _a.sent();
                            this.logger.debug("the " + (this.parentType === "opener" ? "child" : "grandchild") + " client is connected");
                            return [2];
                    }
                });
            });
        };
        WebPlatformTransport.prototype.initiateRemoteConnection = function (target, parentType) {
            var _this = this;
            return PromisePlus(function (resolve, reject) {
                _this.connectionResolve = resolve;
                _this.connectionReject = reject;
                _this.myClientId = shortid();
                var bridgeInstanceId = _this.parentType === "workspace" ? window.name.substring(0, window.name.indexOf("#wsp")) : window.name;
                var request = {
                    glue42core: {
                        type: _this.messages.connectionRequest.name,
                        clientId: _this.myClientId,
                        clientType: parentType === "top" || parentType === "workspace" ? "grandChild" : "child",
                        bridgeInstanceId: bridgeInstanceId
                    }
                };
                _this.logger.debug("sending connection request to " + parentType);
                target.postMessage(request, _this.defaultTargetString);
            }, this.connectionRequestTimeout, "The connection to the opener/top window timed out");
        };
        WebPlatformTransport.prototype.waitParent = function (target, parentType) {
            var _this = this;
            return PromisePlus(function (resolve) {
                _this.parentPingResolve = resolve;
                var message = {
                    glue42core: {
                        type: parentType === "opener" ? _this.messages.platformPing.name : _this.messages.parentPing.name
                    }
                };
                _this.logger.debug("checking for " + parentType + " window availability");
                target.postMessage(message, _this.defaultTargetString);
            }, this.parentPingTimeout, "Cannot initiate glue, because this window was not opened or created by a glue client");
        };
        WebPlatformTransport.prototype.setUpMessageListener = function () {
            var _this = this;
            if (this.settings.port) {
                this.logger.debug("skipping generic message listener, because this is an internal client");
                return;
            }
            window.addEventListener("message", function (event) {
                var _a;
                var data = (_a = event.data) === null || _a === void 0 ? void 0 : _a.glue42core;
                if (!data || _this.rejected) {
                    return;
                }
                if (!_this.checkMessageTypeValid(data.type)) {
                    _this.logger.error("cannot handle the incoming glue42 core message, because the type is invalid: " + data.type);
                    return;
                }
                var messageType = data.type;
                _this.logger.debug("received valid glue42core message of type: " + messageType);
                _this.messages[messageType].handle(event);
            });
        };
        WebPlatformTransport.prototype.setUpUnload = function () {
            var _this = this;
            if (this.settings.port) {
                this.logger.debug("skipping unload event listener, because this is an internal client");
                return;
            }
            window.addEventListener("beforeunload", function () {
                var _a, _b;
                var message = {
                    glue42core: {
                        type: _this.messages.clientUnload.name,
                        data: {
                            clientId: _this.myClientId,
                            ownWindowId: (_a = _this.identity) === null || _a === void 0 ? void 0 : _a.windowId
                        }
                    }
                };
                if (_this.parent) {
                    _this.parent.postMessage(message, _this.defaultTargetString);
                }
                (_b = _this.port) === null || _b === void 0 ? void 0 : _b.postMessage(message);
            });
        };
        WebPlatformTransport.prototype.handleParentReady = function () {
            this.logger.debug("handling the ready signal from the parent, by resoling the pending promise.");
            this.parentReady = true;
            if (this.parentPingResolve) {
                this.parentPingResolve();
                delete this.parentPingResolve;
                return;
            }
            this.logger.debug("silently handling the ready signal from the top parent, because there is no defined promise");
        };
        WebPlatformTransport.prototype.handlePlatformReady = function () {
            this.logger.debug("the web platform gave the ready signal");
            this.parentReady = true;
            if (this.parentPingResolve) {
                this.parentPingResolve();
                delete this.parentPingResolve;
                return;
            }
            this.logger.debug("silently handling the ready signal from the top parent, because there is no defined promise");
        };
        WebPlatformTransport.prototype.handleConnectionAccepted = function (event) {
            var _a;
            var data = (_a = event.data) === null || _a === void 0 ? void 0 : _a.glue42core;
            if (this.myClientId === data.clientId) {
                return this.handleAcceptanceOfMyRequest(data);
            }
            return this.handleAcceptanceOfGrandChildRequest(data, event);
        };
        WebPlatformTransport.prototype.handleAcceptanceOfMyRequest = function (data) {
            var _this = this;
            this.logger.debug("handling a connection accepted signal targeted at me.");
            if (!data.port) {
                this.logger.error("cannot set up my connection, because I was not provided with a port");
                return;
            }
            this.publicWindowId = this.parentType === "opener" ? window.name :
                this.parentType === "top" ? data.parentWindowId :
                    window.name.substring(0, window.name.indexOf("#wsp"));
            if (this.identity && this.parentType !== "top") {
                this.identity.windowId = this.publicWindowId;
            }
            if (this.identity && data.appName) {
                this.identity.application = data.appName;
                this.identity.applicationName = data.appName;
            }
            this.port = data.port;
            this.port.onmessage = function (e) { return _this.registry.execute("onMessage", e.data); };
            if (this.connectionResolve) {
                this.logger.debug("my connection is set up, calling the connection resolve.");
                this.connectionResolve();
                delete this.connectionResolve;
                return;
            }
            this.logger.error("unable to call the connection resolve, because no connection promise was found");
        };
        WebPlatformTransport.prototype.handleAcceptanceOfGrandChildRequest = function (data, event) {
            this.logger.debug("handling a connection accepted signal targeted at a grandchild: " + data.clientId);
            var child = this.children.find(function (c) { return c.grandChildId === data.clientId; });
            if (!child) {
                this.logger.error("cannot handle connection accepted for grandchild: " + data.clientId + ", because there is no grandchild with this id");
                return;
            }
            child.connected = true;
            this.logger.debug("the grandchild connection for " + data.clientId + " is set up, forwarding the success message and the gateway port");
            data.parentWindowId = this.publicWindowId;
            child.source.postMessage(event.data, child.origin, [data.port]);
            return;
        };
        WebPlatformTransport.prototype.handleConnectionRejected = function () {
            this.logger.debug("handling a connection rejection. Most likely the reason is that this window was not created by a glue API call");
            if (this.connectionReject) {
                this.connectionReject("The platform connection was rejected. Most likely because this window was not created by a glue API call");
                delete this.connectionReject;
            }
        };
        WebPlatformTransport.prototype.handleConnectionRequest = function (event) {
            var source = event.source;
            var data = event.data.glue42core;
            if (!data.clientType || data.clientType !== "grandChild") {
                return this.rejectConnectionRequest(source, event.origin, "rejecting a connection request, because the source was not opened by a glue API call");
            }
            if (!data.clientId) {
                return this.rejectConnectionRequest(source, event.origin, "rejecting a connection request, because the source did not provide a valid id");
            }
            if (this.parentType !== "opener" || !this.parent) {
                return this.rejectConnectionRequest(source, event.origin, "Cannot forward the connection request, because no direct connection to the platform was found");
            }
            this.logger.debug("handling a connection request for a grandchild: " + data.clientId);
            this.children.push({ grandChildId: data.clientId, source: source, connected: false, origin: event.origin });
            this.logger.debug("grandchild: " + data.clientId + " is prepared, forwarding connection request to the platform");
            this.parent.postMessage(event.data, this.defaultTargetString);
        };
        WebPlatformTransport.prototype.handleParentPing = function (event) {
            if (!this.parentReady) {
                this.logger.debug("my parent is not ready, I am ignoring the parent ping");
                return;
            }
            if (!this.iAmConnected) {
                this.logger.debug("i am not fully connected yet, I am ignoring the parent ping");
                return;
            }
            var message = {
                glue42core: {
                    type: this.messages.parentReady.name
                }
            };
            var source = event.source;
            this.logger.debug("responding to a parent ping with a ready message");
            source.postMessage(message, event.origin);
        };
        WebPlatformTransport.prototype.handlePlatformUnload = function (event) {
            this.logger.debug("detected a web platform unload");
            this.parentReady = false;
            if (this.children.length) {
                this.logger.debug("forwarding the platform unload to all known children and starting platform discovery polling");
                this.children.forEach(function (child) { return child.source.postMessage(event.data, child.origin); });
            }
            this.notifyStatusChanged(false, "Gateway unloaded");
        };
        WebPlatformTransport.prototype.handleManualUnload = function () {
            var _a, _b;
            var message = {
                glue42core: {
                    type: this.messages.clientUnload.name,
                    data: {
                        clientId: this.myClientId,
                        ownWindowId: (_a = this.identity) === null || _a === void 0 ? void 0 : _a.windowId
                    }
                }
            };
            if (this.parent) {
                this.parent.postMessage(message, this.defaultTargetString);
            }
            (_b = this.port) === null || _b === void 0 ? void 0 : _b.postMessage(message);
        };
        WebPlatformTransport.prototype.handleClientUnload = function (event) {
            var data = event.data.glue42core;
            var clientId = data === null || data === void 0 ? void 0 : data.data.clientId;
            if (!clientId) {
                this.logger.warn("cannot process grand child unload, because the provided id was not valid");
                return;
            }
            var foundChild = this.children.find(function (child) { return child.grandChildId === clientId; });
            if (!foundChild) {
                this.logger.warn("cannot process grand child unload, because this client is unaware of this grandchild");
                return;
            }
            this.logger.debug("handling grandchild unload for id: " + clientId);
            this.children = this.children.filter(function (child) { return child.grandChildId !== clientId; });
        };
        WebPlatformTransport.prototype.handlePlatformPing = function () {
            this.logger.error("cannot handle platform ping, because this is not a platform calls handling component");
        };
        WebPlatformTransport.prototype.notifyStatusChanged = function (status, reason) {
            this.iAmConnected = status;
            this.registry.execute("onConnectedChanged", status, reason);
        };
        WebPlatformTransport.prototype.checkMessageTypeValid = function (typeToValidate) {
            return typeof typeToValidate === "string" && !!this.messages[typeToValidate];
        };
        WebPlatformTransport.prototype.rejectConnectionRequest = function (source, origin, reason) {
            this.rejected = true;
            this.logger.error(reason);
            var rejection = {
                glue42core: {
                    type: this.messages.connectionRejected.name
                }
            };
            source.postMessage(rejection, origin);
        };
        return WebPlatformTransport;
    }());

    var Connection = (function () {
        function Connection(settings, logger) {
            this.settings = settings;
            this.logger = logger;
            this.messageHandlers = {};
            this.ids = 1;
            this.registry = lib();
            this._connected = false;
            this.isTrace = false;
            settings = settings || {};
            settings.reconnectAttempts = settings.reconnectAttempts || 10;
            settings.reconnectInterval = settings.reconnectInterval || 1000;
            if (settings.inproc) {
                this.transport = new InProcTransport(settings.inproc, logger.subLogger("inMemory"));
            }
            else if (settings.sharedWorker) {
                this.transport = new SharedWorkerTransport(settings.sharedWorker, logger.subLogger("shared-worker"));
            }
            else if (settings.webPlatform) {
                this.transport = new WebPlatformTransport(settings.webPlatform, logger.subLogger("web-platform"), settings.identity);
            }
            else if (settings.ws !== undefined) {
                this.transport = new WS(settings, logger.subLogger("ws"));
            }
            else {
                throw new Error("No connection information specified");
            }
            this.isTrace = logger.canPublish("trace");
            logger.debug("starting with " + this.transport.name() + " transport");
            this.protocol = new GW3ProtocolImpl(this, settings, logger.subLogger("protocol"));
            this.transport.onConnectedChanged(this.handleConnectionChanged.bind(this));
            this.transport.onMessage(this.handleTransportMessage.bind(this));
            if (settings.replaySpecs && settings.replaySpecs.length) {
                this.replayer = new MessageReplayerImpl(settings.replaySpecs);
                this.replayer.init(this);
            }
        }
        Object.defineProperty(Connection.prototype, "protocolVersion", {
            get: function () {
                var _a;
                return (_a = this.protocol) === null || _a === void 0 ? void 0 : _a.protocolVersion;
            },
            enumerable: true,
            configurable: true
        });
        Connection.prototype.send = function (message, options) {
            if (this.transport.sendObject &&
                this.transport.isObjectBasedTransport) {
                var msg = this.protocol.createObjectMessage(message);
                if (this.isTrace) {
                    this.logger.trace(">> " + JSON.stringify(msg));
                }
                return this.transport.sendObject(msg, options);
            }
            else {
                var strMessage = this.protocol.createStringMessage(message);
                if (this.isTrace) {
                    this.logger.trace(">> " + strMessage);
                }
                return this.transport.send(strMessage, options);
            }
        };
        Connection.prototype.on = function (type, messageHandler) {
            type = type.toLowerCase();
            if (this.messageHandlers[type] === undefined) {
                this.messageHandlers[type] = {};
            }
            var id = this.ids++;
            this.messageHandlers[type][id] = messageHandler;
            return {
                type: type,
                id: id,
            };
        };
        Connection.prototype.off = function (info) {
            delete this.messageHandlers[info.type.toLowerCase()][info.id];
        };
        Object.defineProperty(Connection.prototype, "isConnected", {
            get: function () {
                return this.protocol.isLoggedIn;
            },
            enumerable: true,
            configurable: true
        });
        Connection.prototype.connected = function (callback) {
            var _this = this;
            return this.protocol.loggedIn(function () {
                callback(_this.settings.ws || _this.settings.sharedWorker || "");
            });
        };
        Connection.prototype.disconnected = function (callback) {
            return this.registry.add("disconnected", callback);
        };
        Connection.prototype.login = function (authRequest, reconnect) {
            return __awaiter$1(this, void 0, void 0, function () {
                var identity;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.transport.open()];
                        case 1:
                            _a.sent();
                            timer("connection").mark("transport-opened");
                            identity = this.protocol.login(authRequest, reconnect);
                            timer("connection").mark("protocol-logged-in");
                            return [2, identity];
                    }
                });
            });
        };
        Connection.prototype.logout = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.protocol.logout()];
                        case 1:
                            _a.sent();
                            return [4, this.transport.close()];
                        case 2:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        Connection.prototype.loggedIn = function (callback) {
            return this.protocol.loggedIn(callback);
        };
        Connection.prototype.domain = function (domain, successMessages, errorMessages) {
            return this.protocol.domain(domain, this.logger.subLogger("domain=" + domain), successMessages, errorMessages);
        };
        Connection.prototype.authToken = function () {
            return this.protocol.authToken();
        };
        Connection.prototype.reconnect = function () {
            return this.transport.reconnect();
        };
        Connection.prototype.distributeMessage = function (message, type) {
            var _this = this;
            var handlers = this.messageHandlers[type.toLowerCase()];
            if (handlers !== undefined) {
                Object.keys(handlers).forEach(function (handlerId) {
                    var handler = handlers[handlerId];
                    if (handler !== undefined) {
                        try {
                            handler(message);
                        }
                        catch (error) {
                            try {
                                _this.logger.error("Message handler failed with " + error.stack, error);
                            }
                            catch (loggerError) {
                                console.log("Message handler failed", error);
                            }
                        }
                    }
                });
            }
        };
        Connection.prototype.handleConnectionChanged = function (connected) {
            if (this._connected === connected) {
                return;
            }
            this._connected = connected;
            if (connected) {
                this.registry.execute("connected");
            }
            else {
                this.registry.execute("disconnected");
            }
        };
        Connection.prototype.handleTransportMessage = function (msg) {
            var msgObj;
            if (typeof msg === "string") {
                msgObj = this.protocol.processStringMessage(msg);
            }
            else {
                msgObj = this.protocol.processObjectMessage(msg);
            }
            if (this.isTrace) {
                this.logger.trace("<< " + JSON.stringify(msgObj));
            }
            this.distributeMessage(msgObj.msg, msgObj.msgType);
        };
        return Connection;
    }());

    var order = ["trace", "debug", "info", "warn", "error", "off"];
    var Logger = (function () {
        function Logger(name, parent, logFn) {
            this.name = name;
            this.parent = parent;
            this.subLoggers = [];
            this.logFn = console;
            this.customLogFn = false;
            this.name = name;
            if (parent) {
                this.path = parent.path + "." + name;
            }
            else {
                this.path = name;
            }
            this.loggerFullName = "[" + this.path + "]";
            this.includeTimeAndLevel = !logFn;
            if (logFn) {
                this.logFn = logFn;
                this.customLogFn = true;
            }
        }
        Logger.prototype.subLogger = function (name) {
            var existingSub = this.subLoggers.filter(function (subLogger) {
                return subLogger.name === name;
            })[0];
            if (existingSub !== undefined) {
                return existingSub;
            }
            Object.keys(this).forEach(function (key) {
                if (key === name) {
                    throw new Error("This sub logger name is not allowed.");
                }
            });
            var sub = new Logger(name, this, this.customLogFn ? this.logFn : undefined);
            this.subLoggers.push(sub);
            return sub;
        };
        Logger.prototype.publishLevel = function (level) {
            var _a;
            if (level) {
                this._publishLevel = level;
            }
            return this._publishLevel || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.publishLevel());
        };
        Logger.prototype.consoleLevel = function (level) {
            var _a;
            if (level) {
                this._consoleLevel = level;
            }
            return this._consoleLevel || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.consoleLevel());
        };
        Logger.prototype.log = function (message, level, error) {
            this.publishMessage(level || "info", message, error);
        };
        Logger.prototype.trace = function (message) {
            this.log(message, "trace");
        };
        Logger.prototype.debug = function (message) {
            this.log(message, "debug");
        };
        Logger.prototype.info = function (message) {
            this.log(message, "info");
        };
        Logger.prototype.warn = function (message) {
            this.log(message, "warn");
        };
        Logger.prototype.error = function (message, err) {
            this.log(message, "error");
        };
        Logger.prototype.canPublish = function (level, compareWith) {
            var levelIdx = order.indexOf(level);
            var restrictionIdx = order.indexOf(compareWith || this.consoleLevel() || "trace");
            return levelIdx >= restrictionIdx;
        };
        Logger.prototype.publishMessage = function (level, message, error) {
            var loggerName = this.loggerFullName;
            if (level === "error" && !error) {
                var e = new Error();
                if (e.stack) {
                    message =
                        message +
                            "\n" +
                            e.stack
                                .split("\n")
                                .slice(3)
                                .join("\n");
                }
            }
            if (this.canPublish(level, this.publishLevel())) {
                var interop = Logger.Interop;
                if (interop) {
                    try {
                        if (interop.methods({ name: Logger.InteropMethodName }).length > 0) {
                            interop.invoke(Logger.InteropMethodName, {
                                msg: "" + message,
                                logger: loggerName,
                                level: level
                            });
                        }
                    }
                    catch (_a) {
                    }
                }
            }
            if (this.canPublish(level)) {
                var prefix = "";
                if (this.includeTimeAndLevel) {
                    var date = new Date();
                    var time = date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds() + ":" + date.getMilliseconds();
                    prefix = "[" + time + "] [" + level + "] ";
                }
                var toPrint = "" + prefix + loggerName + ": " + message;
                switch (level) {
                    case "trace":
                        this.logFn.debug(toPrint);
                        break;
                    case "debug":
                        if (this.logFn.debug) {
                            this.logFn.debug(toPrint);
                        }
                        else {
                            this.logFn.log(toPrint);
                        }
                        break;
                    case "info":
                        this.logFn.info(toPrint);
                        break;
                    case "warn":
                        this.logFn.warn(toPrint);
                        break;
                    case "error":
                        this.logFn.error(toPrint, error);
                        break;
                }
            }
        };
        Logger.InteropMethodName = "T42.AppLogger.Log";
        return Logger;
    }());

    var GW_MESSAGE_CREATE_CONTEXT = "create-context";
    var GW_MESSAGE_ACTIVITY_CREATED = "created";
    var GW_MESSAGE_ACTIVITY_DESTROYED = "destroyed";
    var GW_MESSAGE_CONTEXT_CREATED = "context-created";
    var GW_MESSAGE_CONTEXT_ADDED = "context-added";
    var GW_MESSAGE_SUBSCRIBE_CONTEXT = "subscribe-context";
    var GW_MESSAGE_SUBSCRIBED_CONTEXT = "subscribed-context";
    var GW_MESSAGE_UNSUBSCRIBE_CONTEXT = "unsubscribe-context";
    var GW_MESSAGE_DESTROY_CONTEXT = "destroy-context";
    var GW_MESSAGE_CONTEXT_DESTROYED = "context-destroyed";
    var GW_MESSAGE_UPDATE_CONTEXT = "update-context";
    var GW_MESSAGE_CONTEXT_UPDATED = "context-updated";
    var GW_MESSAGE_JOINED_ACTIVITY = "joined";

    var ContextMessageReplaySpec = {
        get name() {
            return "context";
        },
        get types() {
            return [
                GW_MESSAGE_CREATE_CONTEXT,
                GW_MESSAGE_ACTIVITY_CREATED,
                GW_MESSAGE_ACTIVITY_DESTROYED,
                GW_MESSAGE_CONTEXT_CREATED,
                GW_MESSAGE_CONTEXT_ADDED,
                GW_MESSAGE_SUBSCRIBE_CONTEXT,
                GW_MESSAGE_SUBSCRIBED_CONTEXT,
                GW_MESSAGE_UNSUBSCRIBE_CONTEXT,
                GW_MESSAGE_DESTROY_CONTEXT,
                GW_MESSAGE_CONTEXT_DESTROYED,
                GW_MESSAGE_UPDATE_CONTEXT,
                GW_MESSAGE_CONTEXT_UPDATED,
                GW_MESSAGE_JOINED_ACTIVITY
            ];
        }
    };

    var version = "5.4.4";

    function prepareConfig (configuration, ext, glue42gd) {
        var _a, _b, _c, _d, _e;
        var nodeStartingContext;
        if (Utils.isNode()) {
            var startingContextString = process.env._GD_STARTING_CONTEXT_;
            if (startingContextString) {
                try {
                    nodeStartingContext = JSON.parse(startingContextString);
                }
                catch (_f) {
                }
            }
        }
        function getConnection() {
            var _a, _b, _c, _d, _e;
            var gwConfig = configuration.gateway;
            var protocolVersion = (_a = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.protocolVersion) !== null && _a !== void 0 ? _a : 3;
            var reconnectInterval = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.reconnectInterval;
            var reconnectAttempts = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.reconnectAttempts;
            var defaultWs = "ws://localhost:8385";
            var ws = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.ws;
            var sharedWorker = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.sharedWorker;
            var inproc = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.inproc;
            var webPlatform = (_b = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.webPlatform) !== null && _b !== void 0 ? _b : undefined;
            if (glue42gd) {
                ws = glue42gd.gwURL;
            }
            if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwURL) {
                ws = nodeStartingContext.gwURL;
            }
            if (!ws && !sharedWorker && !inproc) {
                ws = defaultWs;
            }
            var instanceId;
            var windowId;
            var pid;
            var environment;
            var region;
            var appName = getApplication();
            var uniqueAppName = appName;
            if (typeof glue42gd !== "undefined") {
                windowId = glue42gd.windowId;
                pid = glue42gd.pid;
                if (glue42gd.env) {
                    environment = glue42gd.env.env;
                    region = glue42gd.env.region;
                }
                uniqueAppName = (_c = glue42gd.application) !== null && _c !== void 0 ? _c : "glue-app";
                instanceId = glue42gd.appInstanceId;
            }
            else if (Utils.isNode()) {
                pid = process.pid;
                if (nodeStartingContext) {
                    environment = nodeStartingContext.env;
                    region = nodeStartingContext.region;
                    instanceId = nodeStartingContext.instanceId;
                }
            }
            else ;
            var replaySpecs = (_e = (_d = configuration.gateway) === null || _d === void 0 ? void 0 : _d.replaySpecs) !== null && _e !== void 0 ? _e : [];
            replaySpecs.push(ContextMessageReplaySpec);
            return {
                identity: {
                    application: uniqueAppName,
                    applicationName: appName,
                    windowId: windowId,
                    instance: instanceId,
                    process: pid,
                    region: region,
                    environment: environment,
                    api: ext.version || version
                },
                reconnectInterval: reconnectInterval,
                ws: ws,
                sharedWorker: sharedWorker,
                webPlatform: webPlatform,
                inproc: inproc,
                protocolVersion: protocolVersion,
                reconnectAttempts: reconnectAttempts,
                replaySpecs: replaySpecs,
            };
        }
        function getApplication() {
            if (configuration.application) {
                return configuration.application;
            }
            if (glue42gd) {
                return glue42gd.applicationName;
            }
            var uid = shortid();
            if (Utils.isNode()) {
                if (nodeStartingContext) {
                    return nodeStartingContext.applicationConfig.name;
                }
                return "NodeJS" + uid;
            }
            if (typeof window !== "undefined" && typeof document !== "undefined") {
                return document.title + (" (" + uid + ")");
            }
            return uid;
        }
        function getAuth() {
            var _a, _b, _c;
            if (typeof configuration.auth === "string") {
                return {
                    token: configuration.auth
                };
            }
            if (configuration.auth) {
                return configuration.auth;
            }
            if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwToken) {
                return {
                    gatewayToken: nodeStartingContext.gwToken
                };
            }
            if (((_a = configuration.gateway) === null || _a === void 0 ? void 0 : _a.webPlatform) || ((_b = configuration.gateway) === null || _b === void 0 ? void 0 : _b.inproc) || ((_c = configuration.gateway) === null || _c === void 0 ? void 0 : _c.sharedWorker)) {
                return {
                    username: "glue42", password: "glue42"
                };
            }
        }
        function getLogger() {
            var _a, _b;
            var config = configuration.logger;
            var defaultLevel = "warn";
            if (!config) {
                config = defaultLevel;
            }
            var gdConsoleLevel;
            if (glue42gd) {
                gdConsoleLevel = glue42gd.consoleLogLevel;
            }
            if (typeof config === "string") {
                return { console: gdConsoleLevel !== null && gdConsoleLevel !== void 0 ? gdConsoleLevel : config, publish: defaultLevel };
            }
            return {
                console: (_a = gdConsoleLevel !== null && gdConsoleLevel !== void 0 ? gdConsoleLevel : config.console) !== null && _a !== void 0 ? _a : defaultLevel,
                publish: (_b = config.publish) !== null && _b !== void 0 ? _b : defaultLevel
            };
        }
        var connection = getConnection();
        var application = getApplication();
        if (typeof window !== "undefined") {
            var windowAsAny = window;
            var containerApplication = windowAsAny.htmlContainer ?
                windowAsAny.htmlContainer.containerName + "." + windowAsAny.htmlContainer.application : (_a = windowAsAny === null || windowAsAny === void 0 ? void 0 : windowAsAny.glue42gd) === null || _a === void 0 ? void 0 : _a.application;
            if (containerApplication) {
                application = containerApplication;
            }
        }
        return {
            bus: (_b = configuration.bus) !== null && _b !== void 0 ? _b : false,
            application: application,
            auth: getAuth(),
            logger: getLogger(),
            connection: connection,
            metrics: (_c = configuration.metrics) !== null && _c !== void 0 ? _c : true,
            contexts: (_d = configuration.contexts) !== null && _d !== void 0 ? _d : true,
            version: ext.version || version,
            libs: (_e = ext.libs) !== null && _e !== void 0 ? _e : [],
            customLogger: configuration.customLogger
        };
    }

    var GW3ContextData = (function () {
        function GW3ContextData(contextId, name, isAnnounced, activityId) {
            this.updateCallbacks = {};
            this.contextId = contextId;
            this.name = name;
            this.isAnnounced = isAnnounced;
            this.activityId = activityId;
            this.context = {};
        }
        GW3ContextData.prototype.hasCallbacks = function () {
            return Object.keys(this.updateCallbacks).length > 0;
        };
        GW3ContextData.prototype.getState = function () {
            if (this.isAnnounced && this.hasCallbacks()) {
                return 3;
            }
            if (this.isAnnounced) {
                return 2;
            }
            if (this.hasCallbacks()) {
                return 1;
            }
            return 0;
        };
        return GW3ContextData;
    }());

    function applyContextDelta(context, delta, logger) {
        try {
            if (logger === null || logger === void 0 ? void 0 : logger.canPublish("trace")) {
                logger === null || logger === void 0 ? void 0 : logger.trace("applying context delta " + JSON.stringify(delta) + " on context " + JSON.stringify(context));
            }
            if (!delta) {
                return context;
            }
            if (delta.reset) {
                context = __assign$1({}, delta.reset);
                return context;
            }
            context = deepClone(context, undefined);
            if (delta.commands) {
                for (var _i = 0, _a = delta.commands; _i < _a.length; _i++) {
                    var command = _a[_i];
                    if (command.type === "remove") {
                        deletePath(context, command.path);
                    }
                    else if (command.type === "set") {
                        setValueToPath(context, command.value, command.path);
                    }
                }
                return context;
            }
            var added_1 = delta.added;
            var updated_1 = delta.updated;
            var removed = delta.removed;
            if (added_1) {
                Object.keys(added_1).forEach(function (key) {
                    context[key] = added_1[key];
                });
            }
            if (updated_1) {
                Object.keys(updated_1).forEach(function (key) {
                    mergeObjectsProperties(key, context, updated_1);
                });
            }
            if (removed) {
                removed.forEach(function (key) {
                    delete context[key];
                });
            }
            return context;
        }
        catch (e) {
            logger === null || logger === void 0 ? void 0 : logger.error("error applying context delta " + JSON.stringify(delta) + " on context " + JSON.stringify(context), e);
            return context;
        }
    }
    function deepClone(obj, hash) {
        hash = hash || new WeakMap();
        if (Object(obj) !== obj) {
            return obj;
        }
        if (obj instanceof Set) {
            return new Set(obj);
        }
        if (hash.has(obj)) {
            return hash.get(obj);
        }
        var result = obj instanceof Date ? new Date(obj)
            : obj instanceof RegExp ? new RegExp(obj.source, obj.flags)
                : obj.constructor ? new obj.constructor()
                    : Object.create(null);
        hash.set(obj, result);
        if (obj instanceof Map) {
            Array.from(obj, function (_a) {
                var key = _a[0], val = _a[1];
                return result.set(key, deepClone(val, hash));
            });
        }
        return Object.assign.apply(Object, __spreadArrays([result], Object.keys(obj).map(function (key) {
            var _a;
            return (_a = {}, _a[key] = deepClone(obj[key], hash), _a);
        })));
    }
    var mergeObjectsProperties = function (key, what, withWhat) {
        var right = withWhat[key];
        if (right === undefined) {
            return what;
        }
        var left = what[key];
        if (!left || !right) {
            what[key] = right;
            return what;
        }
        if (typeof left === "string" ||
            typeof left === "number" ||
            typeof left === "boolean" ||
            typeof right === "string" ||
            typeof right === "number" ||
            typeof right === "boolean" ||
            Array.isArray(left) ||
            Array.isArray(right)) {
            what[key] = right;
            return what;
        }
        what[key] = Object.assign({}, left, right);
        return what;
    };
    function deepEqual(x, y) {
        if (x === y) {
            return true;
        }
        if (!(x instanceof Object) || !(y instanceof Object)) {
            return false;
        }
        if (x.constructor !== y.constructor) {
            return false;
        }
        for (var p in x) {
            if (!x.hasOwnProperty(p)) {
                continue;
            }
            if (!y.hasOwnProperty(p)) {
                return false;
            }
            if (x[p] === y[p]) {
                continue;
            }
            if (typeof (x[p]) !== "object") {
                return false;
            }
            if (!deepEqual(x[p], y[p])) {
                return false;
            }
        }
        for (var p in y) {
            if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {
                return false;
            }
        }
        return true;
    }
    function setValueToPath(obj, value, path) {
        var pathArr = path.split(".");
        var i;
        for (i = 0; i < pathArr.length - 1; i++) {
            if (!obj[pathArr[i]]) {
                obj[pathArr[i]] = {};
            }
            if (typeof obj[pathArr[i]] !== "object") {
                obj[pathArr[i]] = {};
            }
            obj = obj[pathArr[i]];
        }
        obj[pathArr[i]] = value;
    }
    function isSubset(superObj, subObj) {
        return Object.keys(subObj).every(function (ele) {
            if (typeof subObj[ele] === "object") {
                return isSubset((superObj === null || superObj === void 0 ? void 0 : superObj[ele]) || {}, subObj[ele] || {});
            }
            return subObj[ele] === (superObj === null || superObj === void 0 ? void 0 : superObj[ele]);
        });
    }
    function deletePath(obj, path) {
        var pathArr = path.split(".");
        var i;
        for (i = 0; i < pathArr.length - 1; i++) {
            if (!obj[pathArr[i]]) {
                return;
            }
            obj = obj[pathArr[i]];
        }
        delete obj[pathArr[i]];
    }

    var GW3Bridge = (function () {
        function GW3Bridge(config) {
            var _this = this;
            var _a;
            this._contextNameToData = {};
            this._gw3Subscriptions = [];
            this._nextCallbackSubscriptionNumber = 0;
            this._contextNameToId = {};
            this._contextIdToName = {};
            this._protocolVersion = undefined;
            this._connection = config.connection;
            this._logger = config.logger;
            this._gw3Session = this._connection.domain("global", [
                GW_MESSAGE_CONTEXT_CREATED,
                GW_MESSAGE_SUBSCRIBED_CONTEXT,
                GW_MESSAGE_CONTEXT_DESTROYED,
                GW_MESSAGE_CONTEXT_UPDATED,
            ]);
            this.subscribeToContextCreatedMessages();
            this.subscribeToContextUpdatedMessages();
            this.subscribeToContextDestroyedMessages();
            (_a = this._connection.replayer) === null || _a === void 0 ? void 0 : _a.drain(ContextMessageReplaySpec.name, function (message) {
                var type = message.type;
                if (!type) {
                    return;
                }
                if (type === GW_MESSAGE_CONTEXT_CREATED ||
                    type === GW_MESSAGE_CONTEXT_ADDED ||
                    type === GW_MESSAGE_ACTIVITY_CREATED) {
                    _this.handleContextCreatedMessage(message);
                }
                else if (type === GW_MESSAGE_SUBSCRIBED_CONTEXT ||
                    type === GW_MESSAGE_CONTEXT_UPDATED ||
                    type === GW_MESSAGE_JOINED_ACTIVITY) {
                    _this.handleContextUpdatedMessage(message);
                }
                else if (type === GW_MESSAGE_CONTEXT_DESTROYED ||
                    type === GW_MESSAGE_ACTIVITY_DESTROYED) {
                    _this.handleContextDestroyedMessage(message);
                }
            });
        }
        Object.defineProperty(GW3Bridge.prototype, "protocolVersion", {
            get: function () {
                var _a;
                if (!this._protocolVersion) {
                    var contextsDomainInfo = this._connection.availableDomains.find(function (d) { return d.uri === "context"; });
                    this._protocolVersion = (_a = contextsDomainInfo === null || contextsDomainInfo === void 0 ? void 0 : contextsDomainInfo.version) !== null && _a !== void 0 ? _a : 1;
                }
                return this._protocolVersion;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GW3Bridge.prototype, "setPathSupported", {
            get: function () {
                return this.protocolVersion >= 2;
            },
            enumerable: true,
            configurable: true
        });
        GW3Bridge.prototype.dispose = function () {
            for (var _i = 0, _a = this._gw3Subscriptions; _i < _a.length; _i++) {
                var sub = _a[_i];
                this._connection.off(sub);
            }
            this._gw3Subscriptions.length = 0;
            for (var contextName in this._contextNameToData) {
                if (this._contextNameToId.hasOwnProperty(contextName)) {
                    delete this._contextNameToData[contextName];
                }
            }
        };
        GW3Bridge.prototype.createContext = function (name, data) {
            var _this = this;
            return this._gw3Session
                .send({
                type: GW_MESSAGE_CREATE_CONTEXT,
                domain: "global",
                name: name,
                data: data,
                lifetime: "retained",
            })
                .then(function (createContextMsg) {
                _this._contextNameToId[name] = createContextMsg.context_id;
                _this._contextIdToName[createContextMsg.context_id] = name;
                var contextData = _this._contextNameToData[name] || new GW3ContextData(createContextMsg.context_id, name, true, undefined);
                contextData.isAnnounced = true;
                contextData.name = name;
                contextData.contextId = createContextMsg.context_id;
                contextData.context = data;
                _this._contextNameToData[name] = contextData;
                return createContextMsg.context_id;
            });
        };
        GW3Bridge.prototype.all = function () {
            var _this = this;
            return Object.keys(this._contextNameToData)
                .filter(function (name) { return _this._contextNameToData[name].isAnnounced; });
        };
        GW3Bridge.prototype.update = function (name, delta) {
            var _a;
            return __awaiter$1(this, void 0, void 0, function () {
                var contextData, currentContext, calculatedDelta;
                var _this = this;
                return __generator$1(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            contextData = this._contextNameToData[name];
                            if (!contextData || !contextData.isAnnounced) {
                                return [2, this.createContext(name, delta)];
                            }
                            currentContext = contextData.context;
                            if (!!contextData.hasCallbacks()) return [3, 2];
                            return [4, this.get(contextData.name)];
                        case 1:
                            currentContext = _b.sent();
                            _b.label = 2;
                        case 2:
                            calculatedDelta = this.protocolVersion === 2 ?
                                this.calculateContextDeltaV2(currentContext, delta) :
                                this.calculateContextDeltaV1(currentContext, delta);
                            if (!Object.keys(calculatedDelta.added).length
                                && !Object.keys(calculatedDelta.updated).length
                                && !calculatedDelta.removed.length
                                && !((_a = calculatedDelta.commands) === null || _a === void 0 ? void 0 : _a.length)) {
                                return [2, Promise.resolve()];
                            }
                            return [2, this._gw3Session
                                    .send({
                                    type: GW_MESSAGE_UPDATE_CONTEXT,
                                    domain: "global",
                                    context_id: contextData.contextId,
                                    delta: calculatedDelta,
                                }, {}, { skipPeerId: false })
                                    .then(function (gwResponse) {
                                    _this.handleUpdated(contextData, calculatedDelta, {
                                        updaterId: gwResponse.peer_id
                                    });
                                })];
                    }
                });
            });
        };
        GW3Bridge.prototype.set = function (name, data) {
            var _this = this;
            var contextData = this._contextNameToData[name];
            if (!contextData || !contextData.isAnnounced) {
                return this.createContext(name, data);
            }
            return this._gw3Session
                .send({
                type: GW_MESSAGE_UPDATE_CONTEXT,
                domain: "global",
                context_id: contextData.contextId,
                delta: { reset: data },
            }, {}, { skipPeerId: false })
                .then(function (gwResponse) {
                _this.handleUpdated(contextData, { reset: data, added: {}, removed: [], updated: {} }, { updaterId: gwResponse.peer_id });
            });
        };
        GW3Bridge.prototype.setPath = function (name, path, value) {
            if (!this.setPathSupported) {
                return Promise.reject("glue.contexts.setPath operation is not supported, use Glue42 3.10 or later");
            }
            return this.setPaths(name, [{ path: path, value: value }]);
        };
        GW3Bridge.prototype.setPaths = function (name, pathValues) {
            var _this = this;
            if (!this.setPathSupported) {
                return Promise.reject("glue.contexts.setPaths operation is not supported, use Glue42 3.10 or later");
            }
            var contextData = this._contextNameToData[name];
            if (!contextData || !contextData.isAnnounced) {
                var obj = {};
                for (var _i = 0, pathValues_1 = pathValues; _i < pathValues_1.length; _i++) {
                    var pathValue = pathValues_1[_i];
                    setValueToPath(obj, pathValue.value, pathValue.path);
                }
                return this.createContext(name, obj);
            }
            var commands = [];
            for (var _a = 0, pathValues_2 = pathValues; _a < pathValues_2.length; _a++) {
                var pathValue = pathValues_2[_a];
                if (pathValue.value === null) {
                    commands.push({ type: "remove", path: pathValue.path });
                }
                else {
                    commands.push({ type: "set", path: pathValue.path, value: pathValue.value });
                }
            }
            return this._gw3Session
                .send({
                type: GW_MESSAGE_UPDATE_CONTEXT,
                domain: "global",
                context_id: contextData.contextId,
                delta: { commands: commands }
            }, {}, { skipPeerId: false })
                .then(function (gwResponse) {
                _this.handleUpdated(contextData, { added: {}, removed: [], updated: {}, commands: commands }, { updaterId: gwResponse.peer_id });
            });
        };
        GW3Bridge.prototype.get = function (name) {
            var _this = this;
            var _a;
            var contextData = this._contextNameToData[name];
            if (!contextData || !contextData.isAnnounced) {
                return Promise.resolve({});
            }
            if (contextData && !contextData.hasCallbacks()) {
                return new Promise(function (resolve, _) { return __awaiter$1(_this, void 0, void 0, function () {
                    var _this = this;
                    return __generator$1(this, function (_a) {
                        this.subscribe(name, function (data, _d, _r, un) {
                            _this.unsubscribe(un);
                            resolve(data);
                        });
                        return [2];
                    });
                }); });
            }
            var context = (_a = contextData === null || contextData === void 0 ? void 0 : contextData.context) !== null && _a !== void 0 ? _a : {};
            return Promise.resolve(context);
        };
        GW3Bridge.prototype.subscribe = function (name, callback) {
            var thisCallbackSubscriptionNumber = this._nextCallbackSubscriptionNumber;
            this._nextCallbackSubscriptionNumber += 1;
            var contextData = this._contextNameToData[name];
            if (!contextData ||
                !contextData.isAnnounced) {
                contextData = contextData || new GW3ContextData(undefined, name, false, undefined);
                this._contextNameToData[name] = contextData;
                contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;
                return Promise.resolve(thisCallbackSubscriptionNumber);
            }
            var hadCallbacks = contextData.hasCallbacks();
            contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;
            if (!hadCallbacks) {
                if (!contextData.joinedActivity) {
                    if (contextData.context && contextData.sentExplicitSubscription) {
                        var clone = deepClone(contextData.context);
                        callback(clone, clone, [], thisCallbackSubscriptionNumber);
                        return Promise.resolve(thisCallbackSubscriptionNumber);
                    }
                    return this.sendSubscribe(contextData)
                        .then(function () { return thisCallbackSubscriptionNumber; });
                }
                else {
                    var clone = deepClone(contextData.context);
                    callback(clone, clone, [], thisCallbackSubscriptionNumber);
                    return Promise.resolve(thisCallbackSubscriptionNumber);
                }
            }
            else {
                var clone = deepClone(contextData.context);
                callback(clone, clone, [], thisCallbackSubscriptionNumber);
                return Promise.resolve(thisCallbackSubscriptionNumber);
            }
        };
        GW3Bridge.prototype.unsubscribe = function (subscriptionKey) {
            for (var _i = 0, _a = Object.keys(this._contextNameToData); _i < _a.length; _i++) {
                var name_1 = _a[_i];
                var contextId = this._contextNameToId[name_1];
                var contextData = this._contextNameToData[name_1];
                if (!contextData) {
                    return;
                }
                var hadCallbacks = contextData.hasCallbacks();
                delete contextData.updateCallbacks[subscriptionKey];
                if (contextData.isAnnounced &&
                    hadCallbacks &&
                    !contextData.hasCallbacks() &&
                    contextData.sentExplicitSubscription) {
                    this.sendUnsubscribe(contextData);
                }
                if (!contextData.isAnnounced &&
                    !contextData.hasCallbacks()) {
                    delete this._contextNameToData[name_1];
                }
            }
        };
        GW3Bridge.prototype.destroy = function (name) {
            var contextData = this._contextNameToData[name];
            if (!contextData) {
                return Promise.reject("context with " + name + " does not exist");
            }
            return this._gw3Session
                .send({
                type: GW_MESSAGE_DESTROY_CONTEXT,
                domain: "global",
                context_id: contextData.contextId,
            }).then(function (_) { return undefined; });
        };
        GW3Bridge.prototype.handleUpdated = function (contextData, delta, extraData) {
            var oldContext = contextData.context;
            contextData.context = applyContextDelta(contextData.context, delta, this._logger);
            if (this._contextNameToData[contextData.name] === contextData &&
                !deepEqual(oldContext, contextData.context)) {
                this.invokeUpdateCallbacks(contextData, delta, extraData);
            }
        };
        GW3Bridge.prototype.subscribeToContextCreatedMessages = function () {
            var createdMessageTypes = [
                GW_MESSAGE_CONTEXT_ADDED,
                GW_MESSAGE_CONTEXT_CREATED,
                GW_MESSAGE_ACTIVITY_CREATED,
            ];
            for (var _i = 0, createdMessageTypes_1 = createdMessageTypes; _i < createdMessageTypes_1.length; _i++) {
                var createdMessageType = createdMessageTypes_1[_i];
                var sub = this._connection.on(createdMessageType, this.handleContextCreatedMessage.bind(this));
                this._gw3Subscriptions.push(sub);
            }
        };
        GW3Bridge.prototype.handleContextCreatedMessage = function (contextCreatedMsg) {
            var createdMessageType = contextCreatedMsg.type;
            if (createdMessageType === GW_MESSAGE_ACTIVITY_CREATED) {
                this._contextNameToId[contextCreatedMsg.activity_id] = contextCreatedMsg.context_id;
                this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.activity_id;
            }
            else if (createdMessageType === GW_MESSAGE_CONTEXT_ADDED) {
                this._contextNameToId[contextCreatedMsg.name] = contextCreatedMsg.context_id;
                this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.name;
            }
            else ;
            var name = this._contextIdToName[contextCreatedMsg.context_id];
            if (!name) {
                throw new Error("Received created event for context with unknown name: " + contextCreatedMsg.context_id);
            }
            if (!this._contextNameToId[name]) {
                throw new Error("Received created event for context with unknown id: " + contextCreatedMsg.context_id);
            }
            var contextData = this._contextNameToData[name];
            if (contextData) {
                if (contextData.isAnnounced) {
                    return;
                }
                else {
                    if (!contextData.hasCallbacks()) {
                        throw new Error("Assertion failure: contextData.hasCallbacks()");
                    }
                    contextData.isAnnounced = true;
                    contextData.contextId = contextCreatedMsg.context_id;
                    contextData.activityId = contextCreatedMsg.activity_id;
                    if (!contextData.sentExplicitSubscription) {
                        this.sendSubscribe(contextData);
                    }
                }
            }
            else {
                this._contextNameToData[name] = contextData =
                    new GW3ContextData(contextCreatedMsg.context_id, name, true, contextCreatedMsg.activity_id);
            }
        };
        GW3Bridge.prototype.subscribeToContextUpdatedMessages = function () {
            var updatedMessageTypes = [
                GW_MESSAGE_CONTEXT_UPDATED,
                GW_MESSAGE_SUBSCRIBED_CONTEXT,
                GW_MESSAGE_JOINED_ACTIVITY,
            ];
            for (var _i = 0, updatedMessageTypes_1 = updatedMessageTypes; _i < updatedMessageTypes_1.length; _i++) {
                var updatedMessageType = updatedMessageTypes_1[_i];
                var sub = this._connection.on(updatedMessageType, this.handleContextUpdatedMessage.bind(this));
                this._gw3Subscriptions.push(sub);
            }
        };
        GW3Bridge.prototype.handleContextUpdatedMessage = function (contextUpdatedMsg) {
            var updatedMessageType = contextUpdatedMsg.type;
            var contextId = contextUpdatedMsg.context_id;
            var contextData = this._contextNameToData[this._contextIdToName[contextId]];
            var justSeen = !contextData || !contextData.isAnnounced;
            if (updatedMessageType === GW_MESSAGE_JOINED_ACTIVITY) {
                if (!contextData) {
                    contextData = new GW3ContextData(contextId, contextUpdatedMsg.activity_id, true, contextUpdatedMsg.activity_id);
                    this._contextNameToData[contextUpdatedMsg.activity_id] = contextData;
                    this._contextIdToName[contextId] = contextUpdatedMsg.activity_id;
                    this._contextNameToId[contextUpdatedMsg.activity_id] = contextId;
                }
                else {
                    contextData.contextId = contextId;
                    contextData.isAnnounced = true;
                    contextData.activityId = contextUpdatedMsg.activity_id;
                }
                contextData.joinedActivity = true;
            }
            else {
                if (!contextData || !contextData.isAnnounced) {
                    if (updatedMessageType === GW_MESSAGE_SUBSCRIBED_CONTEXT) {
                        contextData = contextData || new GW3ContextData(contextId, contextUpdatedMsg.name, true, undefined);
                        contextData.sentExplicitSubscription = true;
                        this._contextNameToData[contextUpdatedMsg.name] = contextData;
                        this._contextIdToName[contextId] = contextUpdatedMsg.name;
                        this._contextNameToId[contextUpdatedMsg.name] = contextId;
                    }
                    else {
                        this._logger.error("Received 'update' for unknown context: " + contextId);
                    }
                    return;
                }
            }
            var oldContext = contextData.context;
            if (updatedMessageType === GW_MESSAGE_SUBSCRIBED_CONTEXT) {
                contextData.context = contextUpdatedMsg.data || {};
            }
            else if (updatedMessageType === GW_MESSAGE_JOINED_ACTIVITY) {
                contextData.context = contextUpdatedMsg.context_snapshot || {};
            }
            else if (updatedMessageType === GW_MESSAGE_CONTEXT_UPDATED) {
                contextData.context = applyContextDelta(contextData.context, contextUpdatedMsg.delta, this._logger);
            }
            else {
                throw new Error("Unrecognized context update message " + updatedMessageType);
            }
            if (justSeen ||
                !deepEqual(contextData.context, oldContext) ||
                updatedMessageType === GW_MESSAGE_SUBSCRIBED_CONTEXT) {
                this.invokeUpdateCallbacks(contextData, contextUpdatedMsg.delta, { updaterId: contextUpdatedMsg.updater_id });
            }
        };
        GW3Bridge.prototype.invokeUpdateCallbacks = function (contextData, delta, extraData) {
            delta = delta || { added: {}, updated: {}, reset: {}, removed: [] };
            if (delta.commands) {
                delta.added = delta.updated = delta.reset = {};
                delta.removed = [];
                for (var _i = 0, _a = delta.commands; _i < _a.length; _i++) {
                    var command = _a[_i];
                    if (command.type === "remove") {
                        if (command.path.indexOf(".") === -1) {
                            delta.removed.push(command.path);
                        }
                        setValueToPath(delta.updated, null, command.path);
                    }
                    else if (command.type === "set") {
                        setValueToPath(delta.updated, command.value, command.path);
                    }
                }
            }
            for (var updateCallbackIndex in contextData.updateCallbacks) {
                if (contextData.updateCallbacks.hasOwnProperty(updateCallbackIndex)) {
                    try {
                        var updateCallback = contextData.updateCallbacks[updateCallbackIndex];
                        updateCallback(deepClone(contextData.context), Object.assign({}, delta.added || {}, delta.updated || {}, delta.reset || {}), delta.removed, parseInt(updateCallbackIndex, 10), extraData);
                    }
                    catch (err) {
                        this._logger.debug("callback error: " + JSON.stringify(err));
                    }
                }
            }
        };
        GW3Bridge.prototype.subscribeToContextDestroyedMessages = function () {
            var destroyedMessageTypes = [
                GW_MESSAGE_CONTEXT_DESTROYED,
                GW_MESSAGE_ACTIVITY_DESTROYED,
            ];
            for (var _i = 0, destroyedMessageTypes_1 = destroyedMessageTypes; _i < destroyedMessageTypes_1.length; _i++) {
                var destroyedMessageType = destroyedMessageTypes_1[_i];
                var sub = this._connection.on(destroyedMessageType, this.handleContextDestroyedMessage.bind(this));
                this._gw3Subscriptions.push(sub);
            }
        };
        GW3Bridge.prototype.handleContextDestroyedMessage = function (destroyedMsg) {
            var destroyedMessageType = destroyedMsg.type;
            var contextId;
            var name;
            if (destroyedMessageType === GW_MESSAGE_ACTIVITY_DESTROYED) {
                name = destroyedMsg.activity_id;
                contextId = this._contextNameToId[name];
                if (!contextId) {
                    this._logger.error("Received 'destroyed' for unknown activity: " + destroyedMsg.activity_id);
                    return;
                }
            }
            else {
                contextId = destroyedMsg.context_id;
                name = this._contextIdToName[contextId];
                if (!name) {
                    this._logger.error("Received 'destroyed' for unknown context: " + destroyedMsg.context_id);
                    return;
                }
            }
            delete this._contextIdToName[contextId];
            delete this._contextNameToId[name];
            var contextData = this._contextNameToData[name];
            delete this._contextNameToData[name];
            if (!contextData || !contextData.isAnnounced) {
                this._logger.error("Received 'destroyed' for unknown context: " + contextId);
                return;
            }
        };
        GW3Bridge.prototype.sendSubscribe = function (contextData) {
            contextData.sentExplicitSubscription = true;
            return this._gw3Session
                .send({
                type: GW_MESSAGE_SUBSCRIBE_CONTEXT,
                domain: "global",
                context_id: contextData.contextId,
            }).then(function (_) { return undefined; });
        };
        GW3Bridge.prototype.sendUnsubscribe = function (contextData) {
            contextData.sentExplicitSubscription = false;
            return this._gw3Session
                .send({
                type: GW_MESSAGE_UNSUBSCRIBE_CONTEXT,
                domain: "global",
                context_id: contextData.contextId,
            }).then(function (_) { return undefined; });
        };
        GW3Bridge.prototype.calculateContextDeltaV1 = function (from, to) {
            var delta = { added: {}, updated: {}, removed: [], reset: undefined };
            if (from) {
                for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {
                    var x = _a[_i];
                    if (Object.keys(to).indexOf(x) !== -1
                        && to[x] !== null
                        && !deepEqual(from[x], to[x])) {
                        delta.updated[x] = to[x];
                    }
                }
            }
            for (var _b = 0, _c = Object.keys(to); _b < _c.length; _b++) {
                var x = _c[_b];
                if (!from || (Object.keys(from).indexOf(x) === -1)) {
                    if (to[x] !== null) {
                        delta.added[x] = to[x];
                    }
                }
                else if (to[x] === null) {
                    delta.removed.push(x);
                }
            }
            return delta;
        };
        GW3Bridge.prototype.calculateContextDeltaV2 = function (from, to) {
            var _a, _b;
            var delta = { added: {}, updated: {}, removed: [], reset: undefined, commands: [] };
            for (var _i = 0, _c = Object.keys(to); _i < _c.length; _i++) {
                var x = _c[_i];
                if (to[x] !== null) {
                    var fromX = from ? from[x] : null;
                    if (!deepEqual(fromX, to[x])) {
                        (_a = delta.commands) === null || _a === void 0 ? void 0 : _a.push({ type: "set", path: x, value: to[x] });
                    }
                }
                else {
                    (_b = delta.commands) === null || _b === void 0 ? void 0 : _b.push({ type: "remove", path: x });
                }
            }
            return delta;
        };
        return GW3Bridge;
    }());

    var ContextsModule = (function () {
        function ContextsModule(config) {
            this._bridge = new GW3Bridge(config);
        }
        ContextsModule.prototype.all = function () {
            return this._bridge.all();
        };
        ContextsModule.prototype.update = function (name, data) {
            this.checkName(name);
            this.checkData(data);
            return this._bridge.update(name, data);
        };
        ContextsModule.prototype.set = function (name, data) {
            this.checkName(name);
            this.checkData(data);
            return this._bridge.set(name, data);
        };
        ContextsModule.prototype.setPath = function (name, path, data) {
            this.checkName(name);
            this.checkPath(path);
            var isTopLevelPath = path === "";
            if (isTopLevelPath) {
                this.checkData(data);
                return this.set(name, data);
            }
            return this._bridge.setPath(name, path, data);
        };
        ContextsModule.prototype.setPaths = function (name, paths) {
            this.checkName(name);
            if (!Array.isArray(paths)) {
                throw new Error("Please provide the paths as an array of PathValues!");
            }
            for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
                var _a = paths_1[_i], path = _a.path, value = _a.value;
                this.checkPath(path);
                var isTopLevelPath = path === "";
                if (isTopLevelPath) {
                    this.checkData(value);
                }
            }
            return this._bridge.setPaths(name, paths);
        };
        ContextsModule.prototype.subscribe = function (name, callback) {
            var _this = this;
            this.checkName(name);
            if (typeof callback !== "function") {
                throw new Error("Please provide the callback as a function!");
            }
            return this._bridge
                .subscribe(name, function (data, delta, removed, key, extraData) { return callback(data, delta, removed, function () { return _this._bridge.unsubscribe(key); }, extraData); })
                .then(function (key) {
                return function () {
                    _this._bridge.unsubscribe(key);
                };
            });
        };
        ContextsModule.prototype.get = function (name) {
            this.checkName(name);
            return this._bridge.get(name);
        };
        ContextsModule.prototype.ready = function () {
            return Promise.resolve(this);
        };
        ContextsModule.prototype.destroy = function (name) {
            this.checkName(name);
            return this._bridge.destroy(name);
        };
        Object.defineProperty(ContextsModule.prototype, "setPathSupported", {
            get: function () {
                return this._bridge.setPathSupported;
            },
            enumerable: true,
            configurable: true
        });
        ContextsModule.prototype.checkName = function (name) {
            if (typeof name !== "string" || name === "") {
                throw new Error("Please provide the name as a non-empty string!");
            }
        };
        ContextsModule.prototype.checkPath = function (path) {
            if (typeof path !== "string") {
                throw new Error("Please provide the path as a dot delimited string!");
            }
        };
        ContextsModule.prototype.checkData = function (data) {
            if (typeof data !== "object") {
                throw new Error("Please provide the data as an object!");
            }
        };
        return ContextsModule;
    }());

    function promisify (promise, successCallback, errorCallback) {
        if (typeof successCallback !== "function" && typeof errorCallback !== "function") {
            return promise;
        }
        if (typeof successCallback !== "function") {
            successCallback = function () { };
        }
        else if (typeof errorCallback !== "function") {
            errorCallback = function () { };
        }
        return promise.then(successCallback, errorCallback);
    }

    function rejectAfter(ms, promise, error) {
        if (ms === void 0) { ms = 0; }
        var timeout;
        var clearTimeoutIfThere = function () {
            if (timeout) {
                clearTimeout(timeout);
            }
        };
        promise
            .then(function () {
            clearTimeoutIfThere();
        })
            .catch(function () {
            clearTimeoutIfThere();
        });
        return new Promise(function (resolve, reject) {
            timeout = setTimeout(function () { return reject(error); }, ms);
        });
    }

    var InvokeStatus;
    (function (InvokeStatus) {
        InvokeStatus[InvokeStatus["Success"] = 0] = "Success";
        InvokeStatus[InvokeStatus["Error"] = 1] = "Error";
    })(InvokeStatus || (InvokeStatus = {}));
    var Client = (function () {
        function Client(protocol, repo, instance, configuration) {
            this.protocol = protocol;
            this.repo = repo;
            this.instance = instance;
            this.configuration = configuration;
        }
        Client.prototype.subscribe = function (method, options, successCallback, errorCallback, existingSub) {
            var _this = this;
            var callProtocolSubscribe = function (targetServers, stream, successProxy, errorProxy) {
                var _a;
                options.methodResponseTimeout = (_a = options.methodResponseTimeout) !== null && _a !== void 0 ? _a : options.waitTimeoutMs;
                _this.protocol.client.subscribe(stream, options, targetServers, successProxy, errorProxy, existingSub);
            };
            var promise = new Promise(function (resolve, reject) {
                var successProxy = function (sub) {
                    resolve(sub);
                };
                var errorProxy = function (err) {
                    reject(err);
                };
                if (!method) {
                    reject("Method definition is required. Please, provide either a unique string for a method name or a \u201CmethodDefinition\u201D object with a required \u201Cname\u201D property.");
                    return;
                }
                var methodDef;
                if (typeof method === "string") {
                    methodDef = { name: method };
                }
                else {
                    methodDef = method;
                }
                if (!methodDef.name) {
                    reject("Method definition is required. Please, provide either a unique string for a method name or a \u201CmethodDefinition\u201D object with a required \u201Cname\u201D property.");
                    return;
                }
                if (options === undefined) {
                    options = {};
                }
                var target = options.target;
                if (target === undefined) {
                    target = "best";
                }
                if (typeof target === "string" && target !== "all" && target !== "best") {
                    reject(new Error("\"" + target + "\" is not a valid target. Valid targets are \"all\", \"best\", or an instance."));
                    return;
                }
                if (options.methodResponseTimeout === undefined) {
                    options.methodResponseTimeout = options.method_response_timeout;
                    if (options.methodResponseTimeout === undefined) {
                        options.methodResponseTimeout = _this.configuration.methodResponseTimeout;
                    }
                }
                if (options.waitTimeoutMs === undefined) {
                    options.waitTimeoutMs = options.wait_for_method_timeout;
                    if (options.waitTimeoutMs === undefined) {
                        options.waitTimeoutMs = _this.configuration.waitTimeoutMs;
                    }
                }
                var delayStep = 500;
                var delayTillNow = 0;
                var currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);
                if (currentServers.length > 0) {
                    callProtocolSubscribe(currentServers, currentServers[0].methods[0], successProxy, errorProxy);
                }
                else {
                    var retry_1 = function () {
                        if (!target || !(options.waitTimeoutMs)) {
                            return;
                        }
                        delayTillNow += delayStep;
                        currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);
                        if (currentServers.length > 0) {
                            var streamInfo = currentServers[0].methods[0];
                            callProtocolSubscribe(currentServers, streamInfo, successProxy, errorProxy);
                        }
                        else if (delayTillNow >= options.waitTimeoutMs) {
                            var def = typeof method === "string" ? { name: method } : method;
                            callProtocolSubscribe(currentServers, def, successProxy, errorProxy);
                        }
                        else {
                            setTimeout(retry_1, delayStep);
                        }
                    };
                    setTimeout(retry_1, delayStep);
                }
            });
            return promisify(promise, successCallback, errorCallback);
        };
        Client.prototype.servers = function (methodFilter) {
            var filterCopy = methodFilter === undefined
                ? undefined
                : __assign$1({}, methodFilter);
            return this.getServers(filterCopy).map(function (serverMethodMap) {
                return serverMethodMap.server.instance;
            });
        };
        Client.prototype.methods = function (methodFilter) {
            if (typeof methodFilter === "string") {
                methodFilter = { name: methodFilter };
            }
            else {
                methodFilter = __assign$1({}, methodFilter);
            }
            return this.getMethods(methodFilter);
        };
        Client.prototype.methodsForInstance = function (instance) {
            return this.getMethodsForInstance(instance);
        };
        Client.prototype.methodAdded = function (callback) {
            return this.repo.onMethodAdded(callback);
        };
        Client.prototype.methodRemoved = function (callback) {
            return this.repo.onMethodRemoved(callback);
        };
        Client.prototype.serverAdded = function (callback) {
            return this.repo.onServerAdded(callback);
        };
        Client.prototype.serverRemoved = function (callback) {
            return this.repo.onServerRemoved(function (server, reason) {
                callback(server, reason);
            });
        };
        Client.prototype.serverMethodAdded = function (callback) {
            return this.repo.onServerMethodAdded(function (server, method) {
                callback({ server: server, method: method });
            });
        };
        Client.prototype.serverMethodRemoved = function (callback) {
            return this.repo.onServerMethodRemoved(function (server, method) {
                callback({ server: server, method: method });
            });
        };
        Client.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {
            return __awaiter$1(this, void 0, void 0, function () {
                var getInvokePromise;
                var _this = this;
                return __generator$1(this, function (_a) {
                    getInvokePromise = function () { return __awaiter$1(_this, void 0, void 0, function () {
                        var methodDefinition, serversMethodMap, err_1, method, errorObj, timeout, additionalOptionsCopy, invokePromises, invocationMessages, results, allRejected;
                        var _this = this;
                        var _a, _b, _c;
                        return __generator$1(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    if (typeof methodFilter === "string") {
                                        methodDefinition = { name: methodFilter };
                                    }
                                    else {
                                        methodDefinition = __assign$1({}, methodFilter);
                                    }
                                    if (!methodDefinition.name) {
                                        return [2, Promise.reject("Method definition is required. Please, provide either a unique string for a method name or a \u201CmethodDefinition\u201D object with a required \u201Cname\u201D property.")];
                                    }
                                    if (!argumentObj) {
                                        argumentObj = {};
                                    }
                                    if (!target) {
                                        target = "best";
                                    }
                                    if (typeof target === "string" && target !== "all" && target !== "best" && target !== "skipMine") {
                                        return [2, Promise.reject(new Error("\"" + target + "\" is not a valid target. Valid targets are \"all\" and \"best\"."))];
                                    }
                                    if (!additionalOptions) {
                                        additionalOptions = {};
                                    }
                                    if (additionalOptions.methodResponseTimeoutMs === undefined) {
                                        additionalOptions.methodResponseTimeoutMs = additionalOptions.method_response_timeout;
                                        if (additionalOptions.methodResponseTimeoutMs === undefined) {
                                            additionalOptions.methodResponseTimeoutMs = this.configuration.methodResponseTimeout;
                                        }
                                    }
                                    if (additionalOptions.waitTimeoutMs === undefined) {
                                        additionalOptions.waitTimeoutMs = additionalOptions.wait_for_method_timeout;
                                        if (additionalOptions.waitTimeoutMs === undefined) {
                                            additionalOptions.waitTimeoutMs = this.configuration.waitTimeoutMs;
                                        }
                                    }
                                    if (additionalOptions.waitTimeoutMs !== undefined && typeof additionalOptions.waitTimeoutMs !== "number") {
                                        return [2, Promise.reject(new Error("\"" + additionalOptions.waitTimeoutMs + "\" is not a valid number for \"waitTimeoutMs\" "))];
                                    }
                                    if (typeof argumentObj !== "object") {
                                        return [2, Promise.reject(new Error("The method arguments must be an object. method: " + methodDefinition.name))];
                                    }
                                    serversMethodMap = this.getServerMethodsByFilterAndTarget(methodDefinition, target);
                                    if (!(serversMethodMap.length === 0)) return [3, 4];
                                    _d.label = 1;
                                case 1:
                                    _d.trys.push([1, 3, , 4]);
                                    return [4, this.tryToAwaitForMethods(methodDefinition, target, additionalOptions)];
                                case 2:
                                    serversMethodMap = _d.sent();
                                    return [3, 4];
                                case 3:
                                    err_1 = _d.sent();
                                    method = __assign$1(__assign$1({}, methodDefinition), { getServers: function () { return []; }, supportsStreaming: false, objectTypes: (_a = methodDefinition.objectTypes) !== null && _a !== void 0 ? _a : [], flags: (_c = (_b = methodDefinition.flags) === null || _b === void 0 ? void 0 : _b.metadata) !== null && _c !== void 0 ? _c : {} });
                                    errorObj = {
                                        method: method,
                                        called_with: argumentObj,
                                        message: "Can not find a method matching " + JSON.stringify(methodFilter) + " with server filter " + JSON.stringify(target),
                                        executed_by: undefined,
                                        returned: undefined,
                                        status: undefined,
                                    };
                                    return [2, Promise.reject(errorObj)];
                                case 4:
                                    timeout = additionalOptions.methodResponseTimeoutMs;
                                    additionalOptionsCopy = additionalOptions;
                                    invokePromises = serversMethodMap.map(function (serversMethodPair) {
                                        var invId = shortid();
                                        var method = serversMethodPair.methods[0];
                                        var server = serversMethodPair.server;
                                        var invokePromise = _this.protocol.client.invoke(invId, method, argumentObj, server, additionalOptionsCopy);
                                        return Promise.race([
                                            invokePromise,
                                            rejectAfter(timeout, invokePromise, {
                                                invocationId: invId,
                                                message: "Invocation timeout (" + timeout + " ms) reached for method name: " + (method === null || method === void 0 ? void 0 : method.name) + ", target instance: " + JSON.stringify(server.instance) + ", options: " + JSON.stringify(additionalOptionsCopy),
                                                status: InvokeStatus.Error,
                                            })
                                        ]);
                                    });
                                    return [4, Promise.all(invokePromises)];
                                case 5:
                                    invocationMessages = _d.sent();
                                    results = this.getInvocationResultObj(invocationMessages, methodDefinition, argumentObj);
                                    allRejected = invocationMessages.every(function (result) { return result.status === InvokeStatus.Error; });
                                    if (allRejected) {
                                        return [2, Promise.reject(results)];
                                    }
                                    return [2, results];
                            }
                        });
                    }); };
                    return [2, promisify(getInvokePromise(), success, error)];
                });
            });
        };
        Client.prototype.getInvocationResultObj = function (invocationResults, method, calledWith) {
            var all_return_values = invocationResults
                .filter(function (invokeMessage) { return invokeMessage.status === InvokeStatus.Success; })
                .reduce(function (allValues, currentValue) {
                allValues = __spreadArrays(allValues, [
                    {
                        executed_by: currentValue.instance,
                        returned: currentValue.result,
                        called_with: calledWith,
                        method: method,
                        message: currentValue.message,
                        status: currentValue.status,
                    }
                ]);
                return allValues;
            }, []);
            var all_errors = invocationResults
                .filter(function (invokeMessage) { return invokeMessage.status === InvokeStatus.Error; })
                .reduce(function (allErrors, currError) {
                allErrors = __spreadArrays(allErrors, [
                    {
                        executed_by: currError.instance,
                        called_with: calledWith,
                        name: method.name,
                        message: currError.message,
                    }
                ]);
                return allErrors;
            }, []);
            var invResult = invocationResults[0];
            var result = {
                method: method,
                called_with: calledWith,
                returned: invResult.result,
                executed_by: invResult.instance,
                all_return_values: all_return_values,
                all_errors: all_errors,
                message: invResult.message,
                status: invResult.status
            };
            return result;
        };
        Client.prototype.tryToAwaitForMethods = function (methodDefinition, target, additionalOptions) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (additionalOptions.waitTimeoutMs === 0) {
                    reject();
                    return;
                }
                var delayStep = 500;
                var delayTillNow = 0;
                var retry = function () {
                    delayTillNow += delayStep;
                    var serversMethodMap = _this.getServerMethodsByFilterAndTarget(methodDefinition, target);
                    if (serversMethodMap.length > 0) {
                        clearInterval(interval);
                        resolve(serversMethodMap);
                    }
                    else if (delayTillNow >= (additionalOptions.waitTimeoutMs || 10000)) {
                        clearInterval(interval);
                        reject();
                        return;
                    }
                };
                var interval = setInterval(retry, delayStep);
            });
        };
        Client.prototype.filterByTarget = function (target, serverMethodMap) {
            var _this = this;
            if (typeof target === "string") {
                if (target === "all") {
                    return __spreadArrays(serverMethodMap);
                }
                else if (target === "best") {
                    var localMachine = serverMethodMap
                        .find(function (s) { return s.server.instance.isLocal; });
                    if (localMachine) {
                        return [localMachine];
                    }
                    if (serverMethodMap[0] !== undefined) {
                        return [serverMethodMap[0]];
                    }
                }
                else if (target === "skipMine") {
                    return serverMethodMap.filter(function (_a) {
                        var server = _a.server;
                        return server.instance.peerId !== _this.instance.peerId;
                    });
                }
            }
            else {
                var targetArray = void 0;
                if (!Array.isArray(target)) {
                    targetArray = [target];
                }
                else {
                    targetArray = target;
                }
                var allServersMatching = targetArray.reduce(function (matches, filter) {
                    var myMatches = serverMethodMap.filter(function (serverMethodPair) {
                        return _this.instanceMatch(filter, serverMethodPair.server.instance);
                    });
                    return matches.concat(myMatches);
                }, []);
                return allServersMatching;
            }
            return [];
        };
        Client.prototype.instanceMatch = function (instanceFilter, instanceDefinition) {
            return this.containsProps(instanceFilter, instanceDefinition);
        };
        Client.prototype.methodMatch = function (methodFilter, methodDefinition) {
            return this.containsProps(methodFilter, methodDefinition);
        };
        Client.prototype.containsProps = function (filter, repoMethod) {
            var filterProps = Object.keys(filter)
                .filter(function (prop) {
                return filter[prop] !== undefined
                    && typeof filter[prop] !== "function"
                    && prop !== "object_types"
                    && prop !== "display_name"
                    && prop !== "id"
                    && prop !== "gatewayId"
                    && prop !== "identifier"
                    && prop[0] !== "_";
            });
            return filterProps.every(function (prop) {
                var isMatch;
                var filterValue = filter[prop];
                var repoMethodValue = repoMethod[prop];
                switch (prop) {
                    case "objectTypes":
                        isMatch = (filterValue || []).every(function (filterValueEl) {
                            return (repoMethodValue || []).includes(filterValueEl);
                        });
                        break;
                    case "flags":
                        isMatch = isSubset(repoMethodValue || {}, filterValue || {});
                        break;
                    default:
                        isMatch = String(filterValue).toLowerCase() === String(repoMethodValue).toLowerCase();
                }
                return isMatch;
            });
        };
        Client.prototype.getMethods = function (methodFilter) {
            var _this = this;
            if (methodFilter === undefined) {
                return this.repo.getMethods();
            }
            var methods = this.repo.getMethods().filter(function (method) {
                return _this.methodMatch(methodFilter, method);
            });
            return methods;
        };
        Client.prototype.getMethodsForInstance = function (instanceFilter) {
            var _this = this;
            var allServers = this.repo.getServers();
            var matchingServers = allServers.filter(function (server) {
                return _this.instanceMatch(instanceFilter, server.instance);
            });
            if (matchingServers.length === 0) {
                return [];
            }
            var resultMethodsObject = {};
            if (matchingServers.length === 1) {
                resultMethodsObject = matchingServers[0].methods;
            }
            else {
                matchingServers.forEach(function (server) {
                    Object.keys(server.methods).forEach(function (methodKey) {
                        var method = server.methods[methodKey];
                        resultMethodsObject[method.identifier] = method;
                    });
                });
            }
            return Object.keys(resultMethodsObject)
                .map(function (key) {
                return resultMethodsObject[key];
            });
        };
        Client.prototype.getServers = function (methodFilter) {
            var _this = this;
            var servers = this.repo.getServers();
            if (methodFilter === undefined) {
                return servers.map(function (server) {
                    return { server: server, methods: [] };
                });
            }
            return servers.reduce(function (prev, current) {
                var methodsForServer = Object.values(current.methods);
                var matchingMethods = methodsForServer.filter(function (method) {
                    return _this.methodMatch(methodFilter, method);
                });
                if (matchingMethods.length > 0) {
                    prev.push({ server: current, methods: matchingMethods });
                }
                return prev;
            }, []);
        };
        Client.prototype.getServerMethodsByFilterAndTarget = function (methodFilter, target) {
            var serversMethodMap = this.getServers(methodFilter);
            return this.filterByTarget(target, serversMethodMap);
        };
        return Client;
    }());

    var ServerSubscription = (function () {
        function ServerSubscription(protocol, repoMethod, subscription) {
            this.protocol = protocol;
            this.repoMethod = repoMethod;
            this.subscription = subscription;
        }
        Object.defineProperty(ServerSubscription.prototype, "stream", {
            get: function () {
                if (!this.repoMethod.stream) {
                    throw new Error("no stream");
                }
                return this.repoMethod.stream;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ServerSubscription.prototype, "arguments", {
            get: function () { return this.subscription.arguments || {}; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ServerSubscription.prototype, "branchKey", {
            get: function () { return this.subscription.branchKey; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ServerSubscription.prototype, "instance", {
            get: function () {
                if (!this.subscription.instance) {
                    throw new Error("no instance");
                }
                return this.subscription.instance;
            },
            enumerable: true,
            configurable: true
        });
        ServerSubscription.prototype.close = function () {
            this.protocol.server.closeSingleSubscription(this.repoMethod, this.subscription);
        };
        ServerSubscription.prototype.push = function (data) {
            this.protocol.server.pushDataToSingle(this.repoMethod, this.subscription, data);
        };
        return ServerSubscription;
    }());

    var Request = (function () {
        function Request(protocol, repoMethod, requestContext) {
            this.protocol = protocol;
            this.repoMethod = repoMethod;
            this.requestContext = requestContext;
            this.arguments = requestContext.arguments;
            this.instance = requestContext.instance;
        }
        Request.prototype.accept = function () {
            this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, "");
        };
        Request.prototype.acceptOnBranch = function (branch) {
            this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, branch);
        };
        Request.prototype.reject = function (reason) {
            this.protocol.server.rejectRequest(this.requestContext, this.repoMethod, reason);
        };
        return Request;
    }());

    var ServerStreaming = (function () {
        function ServerStreaming(protocol, server) {
            var _this = this;
            this.protocol = protocol;
            this.server = server;
            protocol.server.onSubRequest(function (rc, rm) { return _this.handleSubRequest(rc, rm); });
            protocol.server.onSubAdded(function (sub, rm) { return _this.handleSubAdded(sub, rm); });
            protocol.server.onSubRemoved(function (sub, rm) { return _this.handleSubRemoved(sub, rm); });
        }
        ServerStreaming.prototype.handleSubRequest = function (requestContext, repoMethod) {
            if (!(repoMethod &&
                repoMethod.streamCallbacks &&
                typeof repoMethod.streamCallbacks.subscriptionRequestHandler === "function")) {
                return;
            }
            var request = new Request(this.protocol, repoMethod, requestContext);
            repoMethod.streamCallbacks.subscriptionRequestHandler(request);
        };
        ServerStreaming.prototype.handleSubAdded = function (subscription, repoMethod) {
            if (!(repoMethod &&
                repoMethod.streamCallbacks &&
                typeof repoMethod.streamCallbacks.subscriptionAddedHandler === "function")) {
                return;
            }
            var sub = new ServerSubscription(this.protocol, repoMethod, subscription);
            repoMethod.streamCallbacks.subscriptionAddedHandler(sub);
        };
        ServerStreaming.prototype.handleSubRemoved = function (subscription, repoMethod) {
            if (!(repoMethod &&
                repoMethod.streamCallbacks &&
                typeof repoMethod.streamCallbacks.subscriptionRemovedHandler === "function")) {
                return;
            }
            var sub = new ServerSubscription(this.protocol, repoMethod, subscription);
            repoMethod.streamCallbacks.subscriptionRemovedHandler(sub);
        };
        return ServerStreaming;
    }());

    var ServerBranch = (function () {
        function ServerBranch(key, protocol, repoMethod) {
            this.key = key;
            this.protocol = protocol;
            this.repoMethod = repoMethod;
        }
        ServerBranch.prototype.subscriptions = function () {
            var _this = this;
            var subList = this.protocol.server.getSubscriptionList(this.repoMethod, this.key);
            return subList.map(function (sub) {
                return new ServerSubscription(_this.protocol, _this.repoMethod, sub);
            });
        };
        ServerBranch.prototype.close = function () {
            this.protocol.server.closeAllSubscriptions(this.repoMethod, this.key);
        };
        ServerBranch.prototype.push = function (data) {
            this.protocol.server.pushData(this.repoMethod, data, [this.key]);
        };
        return ServerBranch;
    }());

    var ServerStream = (function () {
        function ServerStream(_protocol, _repoMethod, _server) {
            this._protocol = _protocol;
            this._repoMethod = _repoMethod;
            this._server = _server;
            this.name = this._repoMethod.definition.name;
        }
        ServerStream.prototype.branches = function (key) {
            var _this = this;
            var bList = this._protocol.server.getBranchList(this._repoMethod);
            if (key) {
                if (bList.indexOf(key) > -1) {
                    return new ServerBranch(key, this._protocol, this._repoMethod);
                }
                return undefined;
            }
            else {
                return bList.map(function (branchKey) {
                    return new ServerBranch(branchKey, _this._protocol, _this._repoMethod);
                });
            }
        };
        ServerStream.prototype.branch = function (key) {
            return this.branches(key);
        };
        ServerStream.prototype.subscriptions = function () {
            var _this = this;
            var subList = this._protocol.server.getSubscriptionList(this._repoMethod);
            return subList.map(function (sub) {
                return new ServerSubscription(_this._protocol, _this._repoMethod, sub);
            });
        };
        Object.defineProperty(ServerStream.prototype, "definition", {
            get: function () {
                var _a;
                var def2 = this._repoMethod.definition;
                return {
                    accepts: def2.accepts,
                    description: def2.description,
                    displayName: def2.displayName,
                    name: def2.name,
                    objectTypes: def2.objectTypes,
                    returns: def2.returns,
                    supportsStreaming: def2.supportsStreaming,
                    flags: (_a = def2.flags) === null || _a === void 0 ? void 0 : _a.metadata,
                };
            },
            enumerable: true,
            configurable: true
        });
        ServerStream.prototype.close = function () {
            this._protocol.server.closeAllSubscriptions(this._repoMethod);
            this._server.unregister(this._repoMethod.definition, true);
        };
        ServerStream.prototype.push = function (data, branches) {
            if (typeof branches !== "string" && !Array.isArray(branches) && branches !== undefined) {
                throw new Error("invalid branches should be string or string array");
            }
            if (typeof data !== "object") {
                throw new Error("Invalid arguments. Data must be an object.");
            }
            this._protocol.server.pushData(this._repoMethod, data, branches);
        };
        ServerStream.prototype.updateRepoMethod = function (repoMethod) {
            this._repoMethod = repoMethod;
        };
        return ServerStream;
    }());

    var Server = (function () {
        function Server(protocol, serverRepository) {
            this.protocol = protocol;
            this.serverRepository = serverRepository;
            this.invocations = 0;
            this.currentlyUnregistering = {};
            this.streaming = new ServerStreaming(protocol, this);
            this.protocol.server.onInvoked(this.onMethodInvoked.bind(this));
        }
        Server.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback, existingStream) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                if (!streamDef) {
                    reject("The stream name must be unique! Please, provide either a unique string for a stream name to \u201Cglue.interop.createStream()\u201D or a \u201CmethodDefinition\u201D object with a unique \u201Cname\u201D property for the stream.");
                    return;
                }
                var streamMethodDefinition;
                if (typeof streamDef === "string") {
                    streamMethodDefinition = { name: "" + streamDef };
                }
                else {
                    streamMethodDefinition = __assign$1({}, streamDef);
                }
                if (!streamMethodDefinition.name) {
                    return reject("The \u201Cname\u201D property is required for the \u201CstreamDefinition\u201D object and must be unique. Stream definition: " + JSON.stringify(streamMethodDefinition));
                }
                var nameAlreadyExists = _this.serverRepository.getList()
                    .some(function (serverMethod) { return serverMethod.definition.name === streamMethodDefinition.name; });
                if (nameAlreadyExists) {
                    return reject("A stream with the name \"" + streamMethodDefinition.name + "\" already exists! Please, provide a unique name for the stream.");
                }
                streamMethodDefinition.supportsStreaming = true;
                if (!callbacks) {
                    callbacks = {};
                }
                if (typeof callbacks.subscriptionRequestHandler !== "function") {
                    callbacks.subscriptionRequestHandler = function (request) {
                        request.accept();
                    };
                }
                var repoMethod = _this.serverRepository.add({
                    definition: streamMethodDefinition,
                    streamCallbacks: callbacks,
                    protocolState: {},
                });
                _this.protocol.server.createStream(repoMethod)
                    .then(function () {
                    var streamUserObject;
                    if (existingStream) {
                        streamUserObject = existingStream;
                        existingStream.updateRepoMethod(repoMethod);
                    }
                    else {
                        streamUserObject = new ServerStream(_this.protocol, repoMethod, _this);
                    }
                    repoMethod.stream = streamUserObject;
                    resolve(streamUserObject);
                })
                    .catch(function (err) {
                    if (repoMethod.repoId) {
                        _this.serverRepository.remove(repoMethod.repoId);
                    }
                    reject(err);
                });
            });
            return promisify(promise, successCallback, errorCallback);
        };
        Server.prototype.register = function (methodDefinition, callback) {
            var _this = this;
            if (!methodDefinition) {
                return Promise.reject("Method definition is required. Please, provide either a unique string for a method name or a \u201CmethodDefinition\u201D object with a required \u201Cname\u201D property.");
            }
            if (typeof callback !== "function") {
                return Promise.reject("The second parameter must be a callback function. Method: " + (typeof methodDefinition === "string" ? methodDefinition : methodDefinition.name));
            }
            var wrappedCallbackFunction = function (context, resultCallback) { return __awaiter$1(_this, void 0, void 0, function () {
                var result, resultValue, e_1;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 4, , 5]);
                            result = callback(context.args, context.instance);
                            if (!(result && typeof result.then === "function")) return [3, 2];
                            return [4, result];
                        case 1:
                            resultValue = _a.sent();
                            resultCallback(undefined, resultValue);
                            return [3, 3];
                        case 2:
                            resultCallback(undefined, result);
                            _a.label = 3;
                        case 3: return [3, 5];
                        case 4:
                            e_1 = _a.sent();
                            if (!e_1) {
                                e_1 = "";
                            }
                            resultCallback(e_1, e_1);
                            return [3, 5];
                        case 5: return [2];
                    }
                });
            }); };
            wrappedCallbackFunction.userCallback = callback;
            return this.registerCore(methodDefinition, wrappedCallbackFunction);
        };
        Server.prototype.registerAsync = function (methodDefinition, callback) {
            if (!methodDefinition) {
                return Promise.reject("Method definition is required. Please, provide either a unique string for a method name or a \u201CmethodDefinition\u201D object with a required \u201Cname\u201D property.");
            }
            if (typeof callback !== "function") {
                return Promise.reject("The second parameter must be a callback function. Method: " + (typeof methodDefinition === "string" ? methodDefinition : methodDefinition.name));
            }
            var wrappedCallback = function (context, resultCallback) {
                try {
                    var resultCalled_1 = false;
                    var success = function (result) {
                        if (!resultCalled_1) {
                            resultCallback(undefined, result);
                        }
                        resultCalled_1 = true;
                    };
                    var error = function (e) {
                        if (!resultCalled_1) {
                            if (!e) {
                                e = "";
                            }
                            resultCallback(e, e);
                        }
                        resultCalled_1 = true;
                    };
                    var methodResult = callback(context.args, context.instance, success, error);
                    if (methodResult && typeof methodResult.then === "function") {
                        methodResult
                            .then(success)
                            .catch(error);
                    }
                }
                catch (e) {
                    resultCallback(e, undefined);
                }
            };
            wrappedCallback.userCallbackAsync = callback;
            return this.registerCore(methodDefinition, wrappedCallback);
        };
        Server.prototype.unregister = function (methodFilter, forStream) {
            if (forStream === void 0) { forStream = false; }
            return __awaiter$1(this, void 0, void 0, function () {
                var methodDefinition, methodToBeRemoved;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (methodFilter === undefined) {
                                return [2, Promise.reject("Please, provide either a unique string for a name or an object containing a \u201Cname\u201D property.")];
                            }
                            if (!(typeof methodFilter === "function")) return [3, 2];
                            return [4, this.unregisterWithPredicate(methodFilter, forStream)];
                        case 1:
                            _a.sent();
                            return [2];
                        case 2:
                            if (typeof methodFilter === "string") {
                                methodDefinition = { name: methodFilter };
                            }
                            else {
                                methodDefinition = methodFilter;
                            }
                            if (methodDefinition.name === undefined) {
                                return [2, Promise.reject("Method name is required. Cannot find a method if the method name is undefined!")];
                            }
                            methodToBeRemoved = this.serverRepository.getList().find(function (serverMethod) {
                                return serverMethod.definition.name === methodDefinition.name
                                    && (serverMethod.definition.supportsStreaming || false) === forStream;
                            });
                            if (!methodToBeRemoved) {
                                return [2, Promise.reject("Method with a name \"" + methodDefinition.name + "\" does not exist or is not registered by your application!")];
                            }
                            return [4, this.removeMethodsOrStreams([methodToBeRemoved])];
                        case 3:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        Server.prototype.unregisterWithPredicate = function (filterPredicate, forStream) {
            return __awaiter$1(this, void 0, void 0, function () {
                var methodsOrStreamsToRemove;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            methodsOrStreamsToRemove = this.serverRepository.getList()
                                .filter(function (sm) { return filterPredicate(sm.definition); })
                                .filter(function (serverMethod) {
                                return (serverMethod.definition.supportsStreaming || false) === forStream;
                            });
                            if (!methodsOrStreamsToRemove || methodsOrStreamsToRemove.length === 0) {
                                return [2, Promise.reject("Could not find a " + (forStream ? "stream" : "method") + " matching the specified condition!")];
                            }
                            return [4, this.removeMethodsOrStreams(methodsOrStreamsToRemove)];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        Server.prototype.removeMethodsOrStreams = function (methodsToRemove) {
            var _this = this;
            var methodUnregPromises = [];
            methodsToRemove.forEach(function (method) {
                var promise = _this.protocol.server.unregister(method)
                    .then(function () {
                    if (method.repoId) {
                        _this.serverRepository.remove(method.repoId);
                    }
                });
                methodUnregPromises.push(promise);
                _this.addAsCurrentlyUnregistering(method.definition.name, promise);
            });
            return Promise.all(methodUnregPromises);
        };
        Server.prototype.addAsCurrentlyUnregistering = function (methodName, promise) {
            return __awaiter$1(this, void 0, void 0, function () {
                var timeout;
                var _this = this;
                return __generator$1(this, function (_a) {
                    timeout = new Promise(function (resolve) { return setTimeout(resolve, 5000); });
                    this.currentlyUnregistering[methodName] = Promise.race([promise, timeout]).then(function () {
                        delete _this.currentlyUnregistering[methodName];
                    });
                    return [2];
                });
            });
        };
        Server.prototype.registerCore = function (method, theFunction) {
            return __awaiter$1(this, void 0, void 0, function () {
                var methodDefinition, unregisterInProgress, nameAlreadyExists, repoMethod;
                var _this = this;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (typeof method === "string") {
                                methodDefinition = { name: "" + method };
                            }
                            else {
                                methodDefinition = __assign$1({}, method);
                            }
                            if (!methodDefinition.name) {
                                return [2, Promise.reject("Please, provide a (unique) string value for the \u201Cname\u201D property in the \u201CmethodDefinition\u201D object: " + JSON.stringify(method))];
                            }
                            unregisterInProgress = this.currentlyUnregistering[methodDefinition.name];
                            if (!unregisterInProgress) return [3, 2];
                            return [4, unregisterInProgress];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            nameAlreadyExists = this.serverRepository.getList()
                                .some(function (serverMethod) { return serverMethod.definition.name === methodDefinition.name; });
                            if (nameAlreadyExists) {
                                return [2, Promise.reject("A method with the name \"" + methodDefinition.name + "\" already exists! Please, provide a unique name for the method.")];
                            }
                            if (methodDefinition.supportsStreaming) {
                                return [2, Promise.reject("When you create methods with \u201Cglue.interop.register()\u201D or \u201Cglue.interop.registerAsync()\u201D the property \u201CsupportsStreaming\u201D cannot be \u201Ctrue\u201D. If you want \u201C" + methodDefinition.name + "\u201D to be a stream, please use the \u201Cglue.interop.createStream()\u201D method.")];
                            }
                            repoMethod = this.serverRepository.add({
                                definition: methodDefinition,
                                theFunction: theFunction,
                                protocolState: {},
                            });
                            return [2, this.protocol.server.register(repoMethod)
                                    .catch(function (err) {
                                    if (repoMethod === null || repoMethod === void 0 ? void 0 : repoMethod.repoId) {
                                        _this.serverRepository.remove(repoMethod.repoId);
                                    }
                                    throw err;
                                })];
                    }
                });
            });
        };
        Server.prototype.onMethodInvoked = function (methodToExecute, invocationId, invocationArgs) {
            var _this = this;
            if (!methodToExecute || !methodToExecute.theFunction) {
                return;
            }
            methodToExecute.theFunction(invocationArgs, function (err, result) {
                if (err !== undefined && err !== null) {
                    if (err.message && typeof err.message === "string") {
                        err = err.message;
                    }
                    else if (typeof err !== "string") {
                        try {
                            err = JSON.stringify(err);
                        }
                        catch (unStrException) {
                            err = "un-stringifyable error in onMethodInvoked! Top level prop names: " + Object.keys(err);
                        }
                    }
                }
                if (!result) {
                    result = {};
                }
                else if (typeof result !== "object" || Array.isArray(result)) {
                    result = { _value: result };
                }
                _this.protocol.server.methodInvocationResult(methodToExecute, invocationId, err, result);
            });
        };
        return Server;
    }());

    var InstanceWrapper = (function () {
        function InstanceWrapper(API, instance, connection) {
            var _this = this;
            this.wrapped = {};
            this.wrapped.getMethods = function () {
                return API.methodsForInstance(this);
            };
            this.wrapped.getStreams = function () {
                return API.methodsForInstance(this).filter(function (m) { return m.supportsStreaming; });
            };
            if (instance) {
                this.refreshWrappedObject(instance);
            }
            if (connection) {
                connection.loggedIn(function () {
                    _this.refresh(connection);
                });
                this.refresh(connection);
            }
        }
        InstanceWrapper.prototype.unwrap = function () {
            return this.wrapped;
        };
        InstanceWrapper.prototype.refresh = function (connection) {
            if (!connection) {
                return;
            }
            var resolvedIdentity = connection === null || connection === void 0 ? void 0 : connection.resolvedIdentity;
            var instance = Object.assign({}, resolvedIdentity !== null && resolvedIdentity !== void 0 ? resolvedIdentity : {}, { peerId: connection === null || connection === void 0 ? void 0 : connection.peerId });
            this.refreshWrappedObject(instance);
        };
        InstanceWrapper.prototype.refreshWrappedObject = function (resolvedIdentity) {
            var _a, _b, _c;
            this.wrapped.user = resolvedIdentity.user;
            this.wrapped.instance = resolvedIdentity.instance;
            this.wrapped.application = (_a = resolvedIdentity.application) !== null && _a !== void 0 ? _a : shortid();
            this.wrapped.applicationName = resolvedIdentity.applicationName;
            this.wrapped.pid = (_c = (_b = resolvedIdentity.pid) !== null && _b !== void 0 ? _b : resolvedIdentity.process) !== null && _c !== void 0 ? _c : Math.floor(Math.random() * 10000000000);
            this.wrapped.machine = resolvedIdentity.machine;
            this.wrapped.environment = resolvedIdentity.environment;
            this.wrapped.region = resolvedIdentity.region;
            this.wrapped.windowId = resolvedIdentity.windowId;
            this.wrapped.isLocal = true;
            this.wrapped.api = resolvedIdentity.api;
            this.wrapped.service = resolvedIdentity.service;
            this.wrapped.peerId = resolvedIdentity.peerId;
        };
        return InstanceWrapper;
    }());

    var hideMethodSystemFlags = function (method) {
        return __assign$1(__assign$1({}, method), { flags: method.flags.metadata || {} });
    };
    var ClientRepository = (function () {
        function ClientRepository(logger, API) {
            this.logger = logger;
            this.API = API;
            this.servers = {};
            this.methodsCount = {};
            this.callbacks = lib();
            var peerId = this.API.instance.peerId;
            this.myServer = {
                id: peerId,
                methods: {},
                instance: this.API.instance,
                wrapper: this.API.unwrappedInstance,
            };
            this.servers[peerId] = this.myServer;
        }
        ClientRepository.prototype.addServer = function (info, serverId) {
            this.logger.debug("adding server " + serverId);
            var current = this.servers[serverId];
            if (current) {
                return current.id;
            }
            var wrapper = new InstanceWrapper(this.API, info);
            var serverEntry = {
                id: serverId,
                methods: {},
                instance: wrapper.unwrap(),
                wrapper: wrapper,
            };
            this.servers[serverId] = serverEntry;
            this.callbacks.execute("onServerAdded", serverEntry.instance);
            return serverId;
        };
        ClientRepository.prototype.removeServerById = function (id, reason) {
            var _this = this;
            var server = this.servers[id];
            if (!server) {
                this.logger.warn("not aware of server " + id + ", my state " + JSON.stringify(Object.keys(this.servers)));
                return;
            }
            else {
                this.logger.debug("removing server " + id);
            }
            Object.keys(server.methods).forEach(function (methodId) {
                _this.removeServerMethod(id, methodId);
            });
            delete this.servers[id];
            this.callbacks.execute("onServerRemoved", server.instance, reason);
        };
        ClientRepository.prototype.addServerMethod = function (serverId, method) {
            var _a;
            var server = this.servers[serverId];
            if (!server) {
                throw new Error("server does not exists");
            }
            if (server.methods[method.id]) {
                return;
            }
            var identifier = this.createMethodIdentifier(method);
            var that = this;
            var methodDefinition = {
                identifier: identifier,
                gatewayId: method.id,
                name: method.name,
                displayName: method.display_name,
                description: method.description,
                version: method.version,
                objectTypes: method.object_types || [],
                accepts: method.input_signature,
                returns: method.result_signature,
                supportsStreaming: typeof method.flags !== "undefined" ? method.flags.streaming : false,
                flags: (_a = method.flags) !== null && _a !== void 0 ? _a : {},
                getServers: function () {
                    return that.getServersByMethod(identifier);
                }
            };
            methodDefinition.object_types = methodDefinition.objectTypes;
            methodDefinition.display_name = methodDefinition.displayName;
            methodDefinition.version = methodDefinition.version;
            server.methods[method.id] = methodDefinition;
            var clientMethodDefinition = hideMethodSystemFlags(methodDefinition);
            if (!this.methodsCount[identifier]) {
                this.methodsCount[identifier] = 0;
                this.callbacks.execute("onMethodAdded", clientMethodDefinition);
            }
            this.methodsCount[identifier] = this.methodsCount[identifier] + 1;
            this.callbacks.execute("onServerMethodAdded", server.instance, clientMethodDefinition);
            return methodDefinition;
        };
        ClientRepository.prototype.removeServerMethod = function (serverId, methodId) {
            var server = this.servers[serverId];
            if (!server) {
                throw new Error("server does not exists");
            }
            var method = server.methods[methodId];
            delete server.methods[methodId];
            var clientMethodDefinition = hideMethodSystemFlags(method);
            this.methodsCount[method.identifier] = this.methodsCount[method.identifier] - 1;
            if (this.methodsCount[method.identifier] === 0) {
                this.callbacks.execute("onMethodRemoved", clientMethodDefinition);
            }
            this.callbacks.execute("onServerMethodRemoved", server.instance, clientMethodDefinition);
        };
        ClientRepository.prototype.getMethods = function () {
            return this.extractMethodsFromServers(Object.values(this.servers)).map(hideMethodSystemFlags);
        };
        ClientRepository.prototype.getServers = function () {
            return Object.values(this.servers).map(this.hideServerMethodSystemFlags);
        };
        ClientRepository.prototype.onServerAdded = function (callback) {
            var unsubscribeFunc = this.callbacks.add("onServerAdded", callback);
            var serversWithMethodsToReplay = this.getServers().map(function (s) { return s.instance; });
            return this.returnUnsubWithDelayedReplay(unsubscribeFunc, serversWithMethodsToReplay, callback);
        };
        ClientRepository.prototype.onMethodAdded = function (callback) {
            var unsubscribeFunc = this.callbacks.add("onMethodAdded", callback);
            var methodsToReplay = this.getMethods();
            return this.returnUnsubWithDelayedReplay(unsubscribeFunc, methodsToReplay, callback);
        };
        ClientRepository.prototype.onServerMethodAdded = function (callback) {
            var unsubscribeFunc = this.callbacks.add("onServerMethodAdded", callback);
            var unsubCalled = false;
            var servers = this.getServers();
            setTimeout(function () {
                servers.forEach(function (server) {
                    var methods = server.methods;
                    Object.keys(methods).forEach(function (methodId) {
                        if (!unsubCalled) {
                            callback(server.instance, methods[methodId]);
                        }
                    });
                });
            }, 0);
            return function () {
                unsubCalled = true;
                unsubscribeFunc();
            };
        };
        ClientRepository.prototype.onMethodRemoved = function (callback) {
            var unsubscribeFunc = this.callbacks.add("onMethodRemoved", callback);
            return unsubscribeFunc;
        };
        ClientRepository.prototype.onServerRemoved = function (callback) {
            var unsubscribeFunc = this.callbacks.add("onServerRemoved", callback);
            return unsubscribeFunc;
        };
        ClientRepository.prototype.onServerMethodRemoved = function (callback) {
            var unsubscribeFunc = this.callbacks.add("onServerMethodRemoved", callback);
            return unsubscribeFunc;
        };
        ClientRepository.prototype.getServerById = function (id) {
            return this.hideServerMethodSystemFlags(this.servers[id]);
        };
        ClientRepository.prototype.reset = function () {
            var _a;
            var _this = this;
            Object.keys(this.servers).forEach(function (key) {
                _this.removeServerById(key, "reset");
            });
            this.servers = (_a = {},
                _a[this.myServer.id] = this.myServer,
                _a);
            this.methodsCount = {};
        };
        ClientRepository.prototype.createMethodIdentifier = function (methodInfo) {
            var accepts = methodInfo.input_signature !== undefined ? methodInfo.input_signature : "";
            var returns = methodInfo.result_signature !== undefined ? methodInfo.result_signature : "";
            return (methodInfo.name + accepts + returns).toLowerCase();
        };
        ClientRepository.prototype.getServersByMethod = function (identifier) {
            var allServers = [];
            Object.values(this.servers).forEach(function (server) {
                Object.values(server.methods).forEach(function (method) {
                    if (method.identifier === identifier) {
                        allServers.push(server.instance);
                    }
                });
            });
            return allServers;
        };
        ClientRepository.prototype.returnUnsubWithDelayedReplay = function (unsubscribeFunc, collectionToReplay, callback) {
            var unsubCalled = false;
            setTimeout(function () {
                collectionToReplay.forEach(function (item) {
                    if (!unsubCalled) {
                        callback(item);
                    }
                });
            }, 0);
            return function () {
                unsubCalled = true;
                unsubscribeFunc();
            };
        };
        ClientRepository.prototype.hideServerMethodSystemFlags = function (server) {
            var clientMethods = {};
            Object.entries(server.methods).forEach(function (_a) {
                var name = _a[0], method = _a[1];
                clientMethods[name] = hideMethodSystemFlags(method);
            });
            return __assign$1(__assign$1({}, server), { methods: clientMethods });
        };
        ClientRepository.prototype.extractMethodsFromServers = function (servers) {
            var methods = Object.values(servers).reduce(function (clientMethods, server) {
                return __spreadArrays(clientMethods, Object.values(server.methods));
            }, []);
            return methods;
        };
        return ClientRepository;
    }());

    var ServerRepository = (function () {
        function ServerRepository() {
            this.nextId = 0;
            this.methods = [];
        }
        ServerRepository.prototype.add = function (method) {
            method.repoId = String(this.nextId);
            this.nextId += 1;
            this.methods.push(method);
            return method;
        };
        ServerRepository.prototype.remove = function (repoId) {
            if (typeof repoId !== "string") {
                return new TypeError("Expecting a string");
            }
            this.methods = this.methods.filter(function (m) {
                return m.repoId !== repoId;
            });
        };
        ServerRepository.prototype.getById = function (id) {
            if (typeof id !== "string") {
                return undefined;
            }
            return this.methods.find(function (m) {
                return m.repoId === id;
            });
        };
        ServerRepository.prototype.getList = function () {
            return this.methods.map(function (m) { return m; });
        };
        ServerRepository.prototype.length = function () {
            return this.methods.length;
        };
        ServerRepository.prototype.reset = function () {
            this.methods = [];
        };
        return ServerRepository;
    }());

    var SUBSCRIPTION_REQUEST = "onSubscriptionRequest";
    var SUBSCRIPTION_ADDED = "onSubscriptionAdded";
    var SUBSCRIPTION_REMOVED = "onSubscriptionRemoved";
    var ServerStreaming$1 = (function () {
        function ServerStreaming(session, repository, serverRepository) {
            var _this = this;
            this.session = session;
            this.repository = repository;
            this.serverRepository = serverRepository;
            this.ERR_URI_SUBSCRIPTION_FAILED = "com.tick42.agm.errors.subscription.failure";
            this.callbacks = lib();
            this.nextStreamId = 0;
            session.on("add-interest", function (msg) {
                _this.handleAddInterest(msg);
            });
            session.on("remove-interest", function (msg) {
                _this.handleRemoveInterest(msg);
            });
        }
        ServerStreaming.prototype.acceptRequestOnBranch = function (requestContext, streamingMethod, branch) {
            if (typeof branch !== "string") {
                branch = "";
            }
            if (typeof streamingMethod.protocolState.subscriptionsMap !== "object") {
                throw new TypeError("The streaming method is missing its subscriptions.");
            }
            if (!Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {
                throw new TypeError("The streaming method is missing its branches.");
            }
            var streamId = this.getStreamId(streamingMethod, branch);
            var key = requestContext.msg.subscription_id;
            var subscription = {
                id: key,
                arguments: requestContext.arguments,
                instance: requestContext.instance,
                branchKey: branch,
                streamId: streamId,
                subscribeMsg: requestContext.msg,
            };
            streamingMethod.protocolState.subscriptionsMap[key] = subscription;
            this.session.sendFireAndForget({
                type: "accepted",
                subscription_id: key,
                stream_id: streamId,
            });
            this.callbacks.execute(SUBSCRIPTION_ADDED, subscription, streamingMethod);
        };
        ServerStreaming.prototype.rejectRequest = function (requestContext, streamingMethod, reason) {
            if (typeof reason !== "string") {
                reason = "";
            }
            this.sendSubscriptionFailed("Subscription rejected by user. " + reason, requestContext.msg.subscription_id);
        };
        ServerStreaming.prototype.pushData = function (streamingMethod, data, branches) {
            var _this = this;
            if (typeof streamingMethod !== "object" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {
                return;
            }
            if (typeof data !== "object") {
                throw new Error("Invalid arguments. Data must be an object.");
            }
            if (typeof branches === "string") {
                branches = [branches];
            }
            else if (!Array.isArray(branches) || branches.length <= 0) {
                branches = [];
            }
            var streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap
                .filter(function (br) {
                if (!branches || branches.length === 0) {
                    return true;
                }
                return branches.indexOf(br.key) >= 0;
            }).map(function (br) {
                return br.streamId;
            });
            streamIdList.forEach(function (streamId) {
                var publishMessage = {
                    type: "publish",
                    stream_id: streamId,
                    data: data,
                };
                _this.session.sendFireAndForget(publishMessage);
            });
        };
        ServerStreaming.prototype.pushDataToSingle = function (method, subscription, data) {
            if (typeof data !== "object") {
                throw new Error("Invalid arguments. Data must be an object.");
            }
            var postMessage = {
                type: "post",
                subscription_id: subscription.id,
                data: data,
            };
            this.session.sendFireAndForget(postMessage);
        };
        ServerStreaming.prototype.closeSingleSubscription = function (streamingMethod, subscription) {
            if (streamingMethod.protocolState.subscriptionsMap) {
                delete streamingMethod.protocolState.subscriptionsMap[subscription.id];
            }
            var dropSubscriptionMessage = {
                type: "drop-subscription",
                subscription_id: subscription.id,
                reason: "Server dropping a single subscription",
            };
            this.session.sendFireAndForget(dropSubscriptionMessage);
            var subscriber = subscription.instance;
            this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);
        };
        ServerStreaming.prototype.closeMultipleSubscriptions = function (streamingMethod, branchKey) {
            var _this = this;
            if (typeof streamingMethod !== "object" || typeof streamingMethod.protocolState.subscriptionsMap !== "object") {
                return;
            }
            if (!streamingMethod.protocolState.subscriptionsMap) {
                return;
            }
            var subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;
            var subscriptionsToClose = Object.keys(subscriptionsMap)
                .map(function (key) {
                return subscriptionsMap[key];
            });
            if (typeof branchKey === "string") {
                subscriptionsToClose = subscriptionsToClose.filter(function (sub) {
                    return sub.branchKey === branchKey;
                });
            }
            subscriptionsToClose.forEach(function (subscription) {
                delete subscriptionsMap[subscription.id];
                var drop = {
                    type: "drop-subscription",
                    subscription_id: subscription.id,
                    reason: "Server dropping all subscriptions on stream_id: " + subscription.streamId,
                };
                _this.session.sendFireAndForget(drop);
            });
        };
        ServerStreaming.prototype.getSubscriptionList = function (streamingMethod, branchKey) {
            if (typeof streamingMethod !== "object") {
                return [];
            }
            var subscriptions = [];
            if (!streamingMethod.protocolState.subscriptionsMap) {
                return [];
            }
            var subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;
            var allSubscriptions = Object.keys(subscriptionsMap)
                .map(function (key) {
                return subscriptionsMap[key];
            });
            if (typeof branchKey !== "string") {
                subscriptions = allSubscriptions;
            }
            else {
                subscriptions = allSubscriptions.filter(function (sub) {
                    return sub.branchKey === branchKey;
                });
            }
            return subscriptions;
        };
        ServerStreaming.prototype.getBranchList = function (streamingMethod) {
            if (typeof streamingMethod !== "object") {
                return [];
            }
            if (!streamingMethod.protocolState.subscriptionsMap) {
                return [];
            }
            var subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;
            var allSubscriptions = Object.keys(subscriptionsMap)
                .map(function (key) {
                return subscriptionsMap[key];
            });
            var result = [];
            allSubscriptions.forEach(function (sub) {
                var branch = "";
                if (typeof sub === "object" && typeof sub.branchKey === "string") {
                    branch = sub.branchKey;
                }
                if (result.indexOf(branch) === -1) {
                    result.push(branch);
                }
            });
            return result;
        };
        ServerStreaming.prototype.onSubAdded = function (callback) {
            this.onSubscriptionLifetimeEvent(SUBSCRIPTION_ADDED, callback);
        };
        ServerStreaming.prototype.onSubRequest = function (callback) {
            this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REQUEST, callback);
        };
        ServerStreaming.prototype.onSubRemoved = function (callback) {
            this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REMOVED, callback);
        };
        ServerStreaming.prototype.handleRemoveInterest = function (msg) {
            var streamingMethod = this.serverRepository.getById(msg.method_id);
            if (typeof msg.subscription_id !== "string" ||
                typeof streamingMethod !== "object") {
                return;
            }
            if (!streamingMethod.protocolState.subscriptionsMap) {
                return;
            }
            if (typeof streamingMethod.protocolState.subscriptionsMap[msg.subscription_id] !== "object") {
                return;
            }
            var subscription = streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];
            delete streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];
            this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);
        };
        ServerStreaming.prototype.onSubscriptionLifetimeEvent = function (eventName, handlerFunc) {
            this.callbacks.add(eventName, handlerFunc);
        };
        ServerStreaming.prototype.getNextStreamId = function () {
            return this.nextStreamId++ + "";
        };
        ServerStreaming.prototype.handleAddInterest = function (msg) {
            var caller = this.repository.getServerById(msg.caller_id);
            var instance = caller.instance;
            var requestContext = {
                msg: msg,
                arguments: msg.arguments_kv || {},
                instance: instance,
            };
            var streamingMethod = this.serverRepository.getById(msg.method_id);
            if (streamingMethod === undefined) {
                var errorMsg = "No method with id " + msg.method_id + " on this server.";
                this.sendSubscriptionFailed(errorMsg, msg.subscription_id);
                return;
            }
            if (streamingMethod.protocolState.subscriptionsMap &&
                streamingMethod.protocolState.subscriptionsMap[msg.subscription_id]) {
                this.sendSubscriptionFailed("A subscription with id " + msg.subscription_id + " already exists.", msg.subscription_id);
                return;
            }
            this.callbacks.execute(SUBSCRIPTION_REQUEST, requestContext, streamingMethod);
        };
        ServerStreaming.prototype.sendSubscriptionFailed = function (reason, subscriptionId) {
            var errorMessage = {
                type: "error",
                reason_uri: this.ERR_URI_SUBSCRIPTION_FAILED,
                reason: reason,
                request_id: subscriptionId,
            };
            this.session.sendFireAndForget(errorMessage);
        };
        ServerStreaming.prototype.getStreamId = function (streamingMethod, branchKey) {
            if (typeof branchKey !== "string") {
                branchKey = "";
            }
            if (!streamingMethod.protocolState.branchKeyToStreamIdMap) {
                throw new Error("streaming " + streamingMethod.definition.name + " method without protocol state");
            }
            var needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {
                return branch.key === branchKey;
            })[0];
            var streamId = (needleBranch ? needleBranch.streamId : undefined);
            if (typeof streamId !== "string" || streamId === "") {
                streamId = this.getNextStreamId();
                streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });
            }
            return streamId;
        };
        return ServerStreaming;
    }());

    var ServerProtocol = (function () {
        function ServerProtocol(session, clientRepository, serverRepository, logger) {
            var _this = this;
            this.session = session;
            this.clientRepository = clientRepository;
            this.serverRepository = serverRepository;
            this.logger = logger;
            this.callbacks = lib();
            this.streaming = new ServerStreaming$1(session, clientRepository, serverRepository);
            this.session.on("invoke", function (msg) { return _this.handleInvokeMessage(msg); });
        }
        ServerProtocol.prototype.createStream = function (repoMethod) {
            repoMethod.protocolState.subscriptionsMap = {};
            repoMethod.protocolState.branchKeyToStreamIdMap = [];
            return this.register(repoMethod, true);
        };
        ServerProtocol.prototype.register = function (repoMethod, isStreaming) {
            var _this = this;
            var _a;
            var methodDef = repoMethod.definition;
            var flags = Object.assign({}, { metadata: (_a = methodDef.flags) !== null && _a !== void 0 ? _a : {} }, { streaming: isStreaming || false });
            var registerMsg = {
                type: "register",
                methods: [{
                        id: repoMethod.repoId,
                        name: methodDef.name,
                        display_name: methodDef.displayName,
                        description: methodDef.description,
                        version: methodDef.version,
                        flags: flags,
                        object_types: methodDef.objectTypes || methodDef.object_types,
                        input_signature: methodDef.accepts,
                        result_signature: methodDef.returns,
                        restrictions: undefined,
                    }],
            };
            return this.session.send(registerMsg, { methodId: repoMethod.repoId })
                .then(function () {
                _this.logger.debug("registered method " + repoMethod.definition.name + " with id " + repoMethod.repoId);
            })
                .catch(function (msg) {
                _this.logger.warn("failed to register method " + repoMethod.definition.name + " with id " + repoMethod.repoId + " - " + JSON.stringify(msg));
                throw msg;
            });
        };
        ServerProtocol.prototype.onInvoked = function (callback) {
            this.callbacks.add("onInvoked", callback);
        };
        ServerProtocol.prototype.methodInvocationResult = function (method, invocationId, err, result) {
            var msg;
            if (err || err === "") {
                msg = {
                    type: "error",
                    request_id: invocationId,
                    reason_uri: "agm.errors.client_error",
                    reason: err,
                    context: result,
                    peer_id: undefined,
                };
            }
            else {
                msg = {
                    type: "yield",
                    invocation_id: invocationId,
                    peer_id: this.session.peerId,
                    result: result,
                    request_id: undefined,
                };
            }
            this.session.sendFireAndForget(msg);
        };
        ServerProtocol.prototype.unregister = function (method) {
            return __awaiter$1(this, void 0, void 0, function () {
                var msg;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            msg = {
                                type: "unregister",
                                methods: [method.repoId],
                            };
                            return [4, this.session.send(msg)];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        ServerProtocol.prototype.getBranchList = function (method) {
            return this.streaming.getBranchList(method);
        };
        ServerProtocol.prototype.getSubscriptionList = function (method, branchKey) {
            return this.streaming.getSubscriptionList(method, branchKey);
        };
        ServerProtocol.prototype.closeAllSubscriptions = function (method, branchKey) {
            this.streaming.closeMultipleSubscriptions(method, branchKey);
        };
        ServerProtocol.prototype.pushData = function (method, data, branches) {
            this.streaming.pushData(method, data, branches);
        };
        ServerProtocol.prototype.pushDataToSingle = function (method, subscription, data) {
            this.streaming.pushDataToSingle(method, subscription, data);
        };
        ServerProtocol.prototype.closeSingleSubscription = function (method, subscription) {
            this.streaming.closeSingleSubscription(method, subscription);
        };
        ServerProtocol.prototype.acceptRequestOnBranch = function (requestContext, method, branch) {
            this.streaming.acceptRequestOnBranch(requestContext, method, branch);
        };
        ServerProtocol.prototype.rejectRequest = function (requestContext, method, reason) {
            this.streaming.rejectRequest(requestContext, method, reason);
        };
        ServerProtocol.prototype.onSubRequest = function (callback) {
            this.streaming.onSubRequest(callback);
        };
        ServerProtocol.prototype.onSubAdded = function (callback) {
            this.streaming.onSubAdded(callback);
        };
        ServerProtocol.prototype.onSubRemoved = function (callback) {
            this.streaming.onSubRemoved(callback);
        };
        ServerProtocol.prototype.handleInvokeMessage = function (msg) {
            var invocationId = msg.invocation_id;
            var callerId = msg.caller_id;
            var methodId = msg.method_id;
            var args = msg.arguments_kv;
            var methodList = this.serverRepository.getList();
            var method = methodList.filter(function (m) {
                return m.repoId === methodId;
            })[0];
            if (method === undefined) {
                return;
            }
            var client = this.clientRepository.getServerById(callerId).instance;
            var invocationArgs = { args: args, instance: client };
            this.callbacks.execute("onInvoked", method, invocationId, invocationArgs);
        };
        return ServerProtocol;
    }());

    var UserSubscription = (function () {
        function UserSubscription(repository, subscriptionData) {
            this.repository = repository;
            this.subscriptionData = subscriptionData;
        }
        Object.defineProperty(UserSubscription.prototype, "requestArguments", {
            get: function () {
                return this.subscriptionData.params.arguments || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserSubscription.prototype, "servers", {
            get: function () {
                var _this = this;
                return this.subscriptionData.trackedServers
                    .filter(function (pair) { return pair.subscriptionId; })
                    .map(function (pair) { return _this.repository.getServerById(pair.serverId).instance; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserSubscription.prototype, "serverInstance", {
            get: function () {
                return this.servers[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UserSubscription.prototype, "stream", {
            get: function () {
                return this.subscriptionData.method;
            },
            enumerable: true,
            configurable: true
        });
        UserSubscription.prototype.onData = function (dataCallback) {
            if (typeof dataCallback !== "function") {
                throw new TypeError("The data callback must be a function.");
            }
            this.subscriptionData.handlers.onData.push(dataCallback);
            if (this.subscriptionData.handlers.onData.length === 1 && this.subscriptionData.queued.data.length > 0) {
                this.subscriptionData.queued.data.forEach(function (dataItem) {
                    dataCallback(dataItem);
                });
            }
        };
        UserSubscription.prototype.onClosed = function (closedCallback) {
            if (typeof closedCallback !== "function") {
                throw new TypeError("The callback must be a function.");
            }
            this.subscriptionData.handlers.onClosed.push(closedCallback);
        };
        UserSubscription.prototype.onFailed = function (callback) {
        };
        UserSubscription.prototype.onConnected = function (callback) {
            if (typeof callback !== "function") {
                throw new TypeError("The callback must be a function.");
            }
            this.subscriptionData.handlers.onConnected.push(callback);
        };
        UserSubscription.prototype.close = function () {
            this.subscriptionData.close();
        };
        UserSubscription.prototype.setNewSubscription = function (newSub) {
            this.subscriptionData = newSub;
        };
        return UserSubscription;
    }());

    var STATUS_AWAITING_ACCEPT = "awaitingAccept";
    var STATUS_SUBSCRIBED = "subscribed";
    var ERR_MSG_SUB_FAILED = "Subscription failed.";
    var ERR_MSG_SUB_REJECTED = "Subscription rejected.";
    var ON_CLOSE_MSG_SERVER_INIT = "ServerInitiated";
    var ON_CLOSE_MSG_CLIENT_INIT = "ClientInitiated";
    var ClientStreaming = (function () {
        function ClientStreaming(session, repository, logger) {
            var _this = this;
            this.session = session;
            this.repository = repository;
            this.logger = logger;
            this.subscriptionsList = {};
            this.subscriptionIdToLocalKeyMap = {};
            this.nextSubLocalKey = 0;
            this.handleErrorSubscribing = function (errorResponse) {
                var tag = errorResponse._tag;
                var subLocalKey = tag.subLocalKey;
                var pendingSub = _this.subscriptionsList[subLocalKey];
                if (typeof pendingSub !== "object") {
                    return;
                }
                pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {
                    return server.serverId !== tag.serverId;
                });
                if (pendingSub.trackedServers.length <= 0) {
                    clearTimeout(pendingSub.timeoutId);
                    if (pendingSub.status === STATUS_AWAITING_ACCEPT) {
                        var reason = (typeof errorResponse.reason === "string" && errorResponse.reason !== "") ?
                            ' Publisher said "' + errorResponse.reason + '".' :
                            " No reason given.";
                        var callArgs = typeof pendingSub.params.arguments === "object" ?
                            JSON.stringify(pendingSub.params.arguments) :
                            "{}";
                        pendingSub.error({
                            message: ERR_MSG_SUB_REJECTED + reason + " Called with:" + callArgs,
                            called_with: pendingSub.params.arguments,
                            method: pendingSub.method,
                        });
                    }
                    else if (pendingSub.status === STATUS_SUBSCRIBED) {
                        _this.callOnClosedHandlers(pendingSub);
                    }
                    delete _this.subscriptionsList[subLocalKey];
                }
            };
            this.handleSubscribed = function (msg) {
                var subLocalKey = msg._tag.subLocalKey;
                var pendingSub = _this.subscriptionsList[subLocalKey];
                if (typeof pendingSub !== "object") {
                    return;
                }
                var serverId = msg._tag.serverId;
                var acceptingServer = pendingSub.trackedServers
                    .filter(function (server) {
                    return server.serverId === serverId;
                })[0];
                if (typeof acceptingServer !== "object") {
                    return;
                }
                acceptingServer.subscriptionId = msg.subscription_id;
                _this.subscriptionIdToLocalKeyMap[msg.subscription_id] = subLocalKey;
                var isFirstResponse = (pendingSub.status === STATUS_AWAITING_ACCEPT);
                pendingSub.status = STATUS_SUBSCRIBED;
                if (isFirstResponse) {
                    var reconnect = false;
                    var sub = pendingSub.subscription;
                    if (sub) {
                        sub.setNewSubscription(pendingSub);
                        pendingSub.success(sub);
                        reconnect = true;
                    }
                    else {
                        sub = new UserSubscription(_this.repository, pendingSub);
                        pendingSub.subscription = sub;
                        pendingSub.success(sub);
                    }
                    for (var _i = 0, _a = pendingSub.handlers.onConnected; _i < _a.length; _i++) {
                        var handler = _a[_i];
                        try {
                            handler(sub.serverInstance, reconnect);
                        }
                        catch (e) {
                        }
                    }
                }
            };
            this.handleEventData = function (msg) {
                var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];
                if (typeof subLocalKey === "undefined") {
                    return;
                }
                var subscription = _this.subscriptionsList[subLocalKey];
                if (typeof subscription !== "object") {
                    return;
                }
                var trackedServersFound = subscription.trackedServers.filter(function (server) {
                    return server.subscriptionId === msg.subscription_id;
                });
                if (trackedServersFound.length !== 1) {
                    return;
                }
                var isPrivateData = msg.oob;
                var sendingServerId = trackedServersFound[0].serverId;
                var receivedStreamData = function () {
                    return {
                        data: msg.data,
                        server: _this.repository.getServerById(sendingServerId).instance,
                        requestArguments: subscription.params.arguments,
                        message: undefined,
                        private: isPrivateData,
                    };
                };
                var onDataHandlers = subscription.handlers.onData;
                var queuedData = subscription.queued.data;
                if (onDataHandlers.length > 0) {
                    onDataHandlers.forEach(function (callback) {
                        if (typeof callback === "function") {
                            callback(receivedStreamData());
                        }
                    });
                }
                else {
                    queuedData.push(receivedStreamData());
                }
            };
            this.handleSubscriptionCancelled = function (msg) {
                var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];
                if (typeof subLocalKey === "undefined") {
                    return;
                }
                var subscription = _this.subscriptionsList[subLocalKey];
                if (typeof subscription !== "object") {
                    return;
                }
                var expectedNewLength = subscription.trackedServers.length - 1;
                subscription.trackedServers = subscription.trackedServers.filter(function (server) {
                    if (server.subscriptionId === msg.subscription_id) {
                        subscription.queued.closers.push(server.serverId);
                        return false;
                    }
                    else {
                        return true;
                    }
                });
                if (subscription.trackedServers.length !== expectedNewLength) {
                    return;
                }
                if (subscription.trackedServers.length <= 0) {
                    clearTimeout(subscription.timeoutId);
                    _this.callOnClosedHandlers(subscription);
                    delete _this.subscriptionsList[subLocalKey];
                }
                delete _this.subscriptionIdToLocalKeyMap[msg.subscription_id];
            };
            session.on("subscribed", this.handleSubscribed);
            session.on("event", this.handleEventData);
            session.on("subscription-cancelled", this.handleSubscriptionCancelled);
        }
        ClientStreaming.prototype.subscribe = function (streamingMethod, params, targetServers, success, error, existingSub) {
            var _this = this;
            if (targetServers.length === 0) {
                error({
                    method: streamingMethod,
                    called_with: params.arguments,
                    message: ERR_MSG_SUB_FAILED + " No available servers matched the target params.",
                });
                return;
            }
            var subLocalKey = this.getNextSubscriptionLocalKey();
            var pendingSub = this.registerSubscription(subLocalKey, streamingMethod, params, success, error, params.methodResponseTimeout || 10000, existingSub);
            if (typeof pendingSub !== "object") {
                error({
                    method: streamingMethod,
                    called_with: params.arguments,
                    message: ERR_MSG_SUB_FAILED + " Unable to register the user callbacks.",
                });
                return;
            }
            targetServers.forEach(function (target) {
                var serverId = target.server.id;
                var method = target.methods.find(function (m) { return m.name === streamingMethod.name; });
                if (!method) {
                    _this.logger.error("can not find method " + streamingMethod.name + " for target " + target.server.id);
                    return;
                }
                pendingSub.trackedServers.push({
                    serverId: serverId,
                    subscriptionId: undefined,
                });
                var msg = {
                    type: "subscribe",
                    server_id: serverId,
                    method_id: method.gatewayId,
                    arguments_kv: params.arguments,
                };
                _this.session.send(msg, { serverId: serverId, subLocalKey: subLocalKey })
                    .then(function (m) { return _this.handleSubscribed(m); })
                    .catch(function (err) { return _this.handleErrorSubscribing(err); });
            });
        };
        ClientStreaming.prototype.drainSubscriptions = function () {
            var existing = Object.values(this.subscriptionsList);
            this.subscriptionsList = {};
            this.subscriptionIdToLocalKeyMap = {};
            return existing;
        };
        ClientStreaming.prototype.getNextSubscriptionLocalKey = function () {
            var current = this.nextSubLocalKey;
            this.nextSubLocalKey += 1;
            return current;
        };
        ClientStreaming.prototype.registerSubscription = function (subLocalKey, method, params, success, error, timeout, existingSub) {
            var _this = this;
            var subsInfo = {
                localKey: subLocalKey,
                status: STATUS_AWAITING_ACCEPT,
                method: method,
                params: params,
                success: success,
                error: error,
                trackedServers: [],
                handlers: {
                    onData: (existingSub === null || existingSub === void 0 ? void 0 : existingSub.handlers.onData) || [],
                    onClosed: (existingSub === null || existingSub === void 0 ? void 0 : existingSub.handlers.onClosed) || [],
                    onConnected: (existingSub === null || existingSub === void 0 ? void 0 : existingSub.handlers.onConnected) || [],
                },
                queued: {
                    data: [],
                    closers: [],
                },
                timeoutId: undefined,
                close: function () { return _this.closeSubscription(subLocalKey); },
                subscription: existingSub === null || existingSub === void 0 ? void 0 : existingSub.subscription
            };
            if (!existingSub) {
                if (params.onData) {
                    subsInfo.handlers.onData.push(params.onData);
                }
                if (params.onClosed) {
                    subsInfo.handlers.onClosed.push(params.onClosed);
                }
                if (params.onConnected) {
                    subsInfo.handlers.onConnected.push(params.onConnected);
                }
            }
            this.subscriptionsList[subLocalKey] = subsInfo;
            subsInfo.timeoutId = setTimeout(function () {
                if (_this.subscriptionsList[subLocalKey] === undefined) {
                    return;
                }
                var pendingSub = _this.subscriptionsList[subLocalKey];
                if (pendingSub.status === STATUS_AWAITING_ACCEPT) {
                    error({
                        method: method,
                        called_with: params.arguments,
                        message: ERR_MSG_SUB_FAILED + " Subscription attempt timed out after " + timeout + " ms.",
                    });
                    delete _this.subscriptionsList[subLocalKey];
                }
                else if (pendingSub.status === STATUS_SUBSCRIBED && pendingSub.trackedServers.length > 0) {
                    pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {
                        return (typeof server.subscriptionId !== "undefined");
                    });
                    delete pendingSub.timeoutId;
                    if (pendingSub.trackedServers.length <= 0) {
                        _this.callOnClosedHandlers(pendingSub);
                        delete _this.subscriptionsList[subLocalKey];
                    }
                }
            }, timeout);
            return subsInfo;
        };
        ClientStreaming.prototype.callOnClosedHandlers = function (subscription, reason) {
            var closersCount = subscription.queued.closers.length;
            var closingServerId = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;
            var closingServer;
            if (closingServerId !== undefined && typeof closingServerId === "string") {
                closingServer = this.repository.getServerById(closingServerId).instance;
            }
            subscription.handlers.onClosed.forEach(function (callback) {
                if (typeof callback !== "function") {
                    return;
                }
                callback({
                    message: reason || ON_CLOSE_MSG_SERVER_INIT,
                    requestArguments: subscription.params.arguments || {},
                    server: closingServer,
                    stream: subscription.method,
                });
            });
        };
        ClientStreaming.prototype.closeSubscription = function (subLocalKey) {
            var _this = this;
            var subscription = this.subscriptionsList[subLocalKey];
            if (typeof subscription !== "object") {
                return;
            }
            subscription.trackedServers.forEach(function (server) {
                if (typeof server.subscriptionId === "undefined") {
                    return;
                }
                subscription.queued.closers.push(server.serverId);
                _this.session.sendFireAndForget({
                    type: "unsubscribe",
                    subscription_id: server.subscriptionId,
                    reason_uri: "",
                    reason: ON_CLOSE_MSG_CLIENT_INIT,
                });
                delete _this.subscriptionIdToLocalKeyMap[server.subscriptionId];
            });
            subscription.trackedServers = [];
            this.callOnClosedHandlers(subscription, ON_CLOSE_MSG_CLIENT_INIT);
            delete this.subscriptionsList[subLocalKey];
        };
        return ClientStreaming;
    }());

    var ClientProtocol = (function () {
        function ClientProtocol(session, repository, logger) {
            var _this = this;
            this.session = session;
            this.repository = repository;
            this.logger = logger;
            session.on("peer-added", function (msg) { return _this.handlePeerAdded(msg); });
            session.on("peer-removed", function (msg) { return _this.handlePeerRemoved(msg); });
            session.on("methods-added", function (msg) { return _this.handleMethodsAddedMessage(msg); });
            session.on("methods-removed", function (msg) { return _this.handleMethodsRemovedMessage(msg); });
            this.streaming = new ClientStreaming(session, repository, logger);
        }
        ClientProtocol.prototype.subscribe = function (stream, options, targetServers, success, error, existingSub) {
            this.streaming.subscribe(stream, options, targetServers, success, error, existingSub);
        };
        ClientProtocol.prototype.invoke = function (id, method, args, target) {
            var _this = this;
            var serverId = target.id;
            var methodId = method.gatewayId;
            var msg = {
                type: "call",
                server_id: serverId,
                method_id: methodId,
                arguments_kv: args,
            };
            return this.session.send(msg, { invocationId: id, serverId: serverId })
                .then(function (m) { return _this.handleResultMessage(m); })
                .catch(function (err) { return _this.handleInvocationError(err); });
        };
        ClientProtocol.prototype.drainSubscriptions = function () {
            return this.streaming.drainSubscriptions();
        };
        ClientProtocol.prototype.handlePeerAdded = function (msg) {
            var newPeerId = msg.new_peer_id;
            var remoteId = msg.identity;
            var isLocal = msg.meta ? msg.meta.local : true;
            var pid = Number(remoteId.process);
            var serverInfo = {
                machine: remoteId.machine,
                pid: isNaN(pid) ? remoteId.process : pid,
                instance: remoteId.instance,
                application: remoteId.application,
                applicationName: remoteId.applicationName,
                environment: remoteId.environment,
                region: remoteId.region,
                user: remoteId.user,
                windowId: remoteId.windowId,
                peerId: newPeerId,
                api: remoteId.api,
                isLocal: isLocal
            };
            this.repository.addServer(serverInfo, newPeerId);
        };
        ClientProtocol.prototype.handlePeerRemoved = function (msg) {
            var removedPeerId = msg.removed_id;
            var reason = msg.reason;
            this.repository.removeServerById(removedPeerId, reason);
        };
        ClientProtocol.prototype.handleMethodsAddedMessage = function (msg) {
            var _this = this;
            var serverId = msg.server_id;
            var methods = msg.methods;
            methods.forEach(function (method) {
                _this.repository.addServerMethod(serverId, method);
            });
        };
        ClientProtocol.prototype.handleMethodsRemovedMessage = function (msg) {
            var _this = this;
            var serverId = msg.server_id;
            var methodIdList = msg.methods;
            var server = this.repository.getServerById(serverId);
            var serverMethodKeys = Object.keys(server.methods);
            serverMethodKeys.forEach(function (methodKey) {
                var method = server.methods[methodKey];
                if (methodIdList.indexOf(method.gatewayId) > -1) {
                    _this.repository.removeServerMethod(serverId, methodKey);
                }
            });
        };
        ClientProtocol.prototype.handleResultMessage = function (msg) {
            var invocationId = msg._tag.invocationId;
            var result = msg.result;
            var serverId = msg._tag.serverId;
            var server = this.repository.getServerById(serverId);
            return {
                invocationId: invocationId,
                result: result,
                instance: server.instance,
                status: InvokeStatus.Success,
                message: ""
            };
        };
        ClientProtocol.prototype.handleInvocationError = function (msg) {
            this.logger.debug("handle invocation error " + JSON.stringify(msg));
            if ("_tag" in msg) {
                var invocationId = msg._tag.invocationId;
                var serverId = msg._tag.serverId;
                var server = this.repository.getServerById(serverId);
                var message = msg.reason;
                var context_1 = msg.context;
                return {
                    invocationId: invocationId,
                    result: context_1,
                    instance: server.instance,
                    status: InvokeStatus.Error,
                    message: message
                };
            }
            else {
                return {
                    invocationId: "",
                    message: msg.message,
                    status: InvokeStatus.Error,
                    error: msg
                };
            }
        };
        return ClientProtocol;
    }());

    function gW3ProtocolFactory (instance, connection, clientRepository, serverRepository, libConfig, interop) {
        var logger = libConfig.logger.subLogger("gw3-protocol");
        var resolveReadyPromise;
        var readyPromise = new Promise(function (resolve) {
            resolveReadyPromise = resolve;
        });
        var session = connection.domain("agm", ["subscribed"]);
        var server = new ServerProtocol(session, clientRepository, serverRepository, logger.subLogger("server"));
        var client = new ClientProtocol(session, clientRepository, logger.subLogger("client"));
        function handleReconnect() {
            logger.info("reconnected - will replay registered methods and subscriptions");
            var existingSubscriptions = client.drainSubscriptions();
            for (var _i = 0, existingSubscriptions_1 = existingSubscriptions; _i < existingSubscriptions_1.length; _i++) {
                var sub = existingSubscriptions_1[_i];
                var methodInfo = sub.method;
                var params = Object.assign({}, sub.params);
                logger.info("trying to re-subscribe to method " + methodInfo.name);
                interop.client.subscribe(methodInfo, params, undefined, undefined, sub);
            }
            var registeredMethods = serverRepository.getList();
            serverRepository.reset();
            for (var _a = 0, registeredMethods_1 = registeredMethods; _a < registeredMethods_1.length; _a++) {
                var method = registeredMethods_1[_a];
                var def = method.definition;
                logger.info("re-publishing method " + def.name);
                if (method.stream) {
                    interop.server.createStream(def, method.streamCallbacks, undefined, undefined, method.stream);
                }
                else if (method.theFunction && method.theFunction.userCallback) {
                    interop.register(def, method.theFunction.userCallback);
                }
                else if (method.theFunction && method.theFunction.userCallbackAsync) {
                    interop.registerAsync(def, method.theFunction.userCallbackAsync);
                }
            }
        }
        function handleInitialJoin() {
            if (resolveReadyPromise) {
                resolveReadyPromise({
                    client: client,
                    server: server,
                });
                resolveReadyPromise = undefined;
            }
        }
        session.onJoined(function (reconnect) {
            clientRepository.addServer(instance, connection.peerId);
            if (reconnect) {
                handleReconnect();
            }
            else {
                handleInitialJoin();
            }
        });
        session.onLeft(function () {
            clientRepository.reset();
        });
        session.join();
        return readyPromise;
    }

    var Interop = (function () {
        function Interop(configuration) {
            var _this = this;
            if (typeof configuration === "undefined") {
                throw new Error("configuration is required");
            }
            if (typeof configuration.connection === "undefined") {
                throw new Error("configuration.connections is required");
            }
            var connection = configuration.connection;
            if (typeof configuration.methodResponseTimeout !== "number") {
                configuration.methodResponseTimeout = 30 * 1000;
            }
            if (typeof configuration.waitTimeoutMs !== "number") {
                configuration.waitTimeoutMs = 30 * 1000;
            }
            this.unwrappedInstance = new InstanceWrapper(this, undefined, connection);
            this.instance = this.unwrappedInstance.unwrap();
            this.clientRepository = new ClientRepository(configuration.logger.subLogger("cRep"), this);
            this.serverRepository = new ServerRepository();
            var protocolPromise;
            if (connection.protocolVersion === 3) {
                protocolPromise = gW3ProtocolFactory(this.instance, connection, this.clientRepository, this.serverRepository, configuration, this);
            }
            else {
                throw new Error("protocol " + connection.protocolVersion + " not supported");
            }
            this.readyPromise = protocolPromise.then(function (protocol) {
                _this.protocol = protocol;
                _this.client = new Client(_this.protocol, _this.clientRepository, _this.instance, configuration);
                _this.server = new Server(_this.protocol, _this.serverRepository);
                return _this;
            });
        }
        Interop.prototype.ready = function () {
            return this.readyPromise;
        };
        Interop.prototype.serverRemoved = function (callback) {
            return this.client.serverRemoved(callback);
        };
        Interop.prototype.serverAdded = function (callback) {
            return this.client.serverAdded(callback);
        };
        Interop.prototype.serverMethodRemoved = function (callback) {
            return this.client.serverMethodRemoved(callback);
        };
        Interop.prototype.serverMethodAdded = function (callback) {
            return this.client.serverMethodAdded(callback);
        };
        Interop.prototype.methodRemoved = function (callback) {
            return this.client.methodRemoved(callback);
        };
        Interop.prototype.methodAdded = function (callback) {
            return this.client.methodAdded(callback);
        };
        Interop.prototype.methodsForInstance = function (instance) {
            return this.client.methodsForInstance(instance);
        };
        Interop.prototype.methods = function (methodFilter) {
            return this.client.methods(methodFilter);
        };
        Interop.prototype.servers = function (methodFilter) {
            return this.client.servers(methodFilter);
        };
        Interop.prototype.subscribe = function (method, options, successCallback, errorCallback) {
            return this.client.subscribe(method, options, successCallback, errorCallback);
        };
        Interop.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback) {
            return this.server.createStream(streamDef, callbacks, successCallback, errorCallback);
        };
        Interop.prototype.unregister = function (methodFilter) {
            return this.server.unregister(methodFilter);
        };
        Interop.prototype.registerAsync = function (methodDefinition, callback) {
            return this.server.registerAsync(methodDefinition, callback);
        };
        Interop.prototype.register = function (methodDefinition, callback) {
            return this.server.register(methodDefinition, callback);
        };
        Interop.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {
            return this.client.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);
        };
        Interop.prototype.waitForMethod = function (name) {
            var pw = new PromiseWrapper();
            var unsubscribe = this.client.methodAdded(function (m) {
                if (m.name === name) {
                    unsubscribe();
                    pw.resolve(m);
                }
            });
            return pw.promise;
        };
        return Interop;
    }());

    var successMessages = ["subscribed", "success"];
    var MessageBus = (function () {
        function MessageBus(connection, logger) {
            var _this = this;
            this.publish = function (topic, data, options) {
                var _a = options || {}, routingKey = _a.routingKey, target = _a.target;
                var args = _this.removeEmptyValues({
                    type: "publish",
                    topic: topic,
                    data: data,
                    peer_id: _this.peerId,
                    routing_key: routingKey,
                    target_identity: target
                });
                _this.session.send(args);
            };
            this.subscribe = function (topic, callback, options) {
                return new Promise(function (resolve, reject) {
                    var _a = options || {}, routingKey = _a.routingKey, target = _a.target;
                    var args = _this.removeEmptyValues({
                        type: "subscribe",
                        topic: topic,
                        peer_id: _this.peerId,
                        routing_key: routingKey,
                        source: target
                    });
                    _this.session.send(args)
                        .then(function (response) {
                        var subscription_id = response.subscription_id;
                        _this.subscriptions.push({ subscription_id: subscription_id, topic: topic, callback: callback, source: target });
                        resolve({
                            unsubscribe: function () {
                                _this.session.send({ type: "unsubscribe", subscription_id: subscription_id, peer_id: _this.peerId });
                                _this.subscriptions = _this.subscriptions.filter(function (s) { return s.subscription_id !== subscription_id; });
                                return Promise.resolve();
                            }
                        });
                    })
                        .catch(function (error) { return reject(error); });
                });
            };
            this.watchOnEvent = function () {
                _this.session.on("event", function (args) {
                    var data = args.data, subscription_id = args.subscription_id;
                    var source = args["publisher-identity"];
                    var subscription = _this.subscriptions.find(function (s) { return s.subscription_id === subscription_id; });
                    if (subscription) {
                        if (!subscription.source) {
                            subscription.callback(data, subscription.topic, source);
                        }
                        else {
                            if (_this.keysMatch(subscription.source, source)) {
                                subscription.callback(data, subscription.topic, source);
                            }
                        }
                    }
                });
            };
            this.connection = connection;
            this.logger = logger;
            this.peerId = connection.peerId;
            this.subscriptions = [];
            this.session = connection.domain("bus", successMessages);
            this.readyPromise = this.session.join();
            this.readyPromise.then(function () {
                _this.watchOnEvent();
            });
        }
        MessageBus.prototype.ready = function () {
            return this.readyPromise;
        };
        MessageBus.prototype.removeEmptyValues = function (obj) {
            var cleaned = {};
            Object.keys(obj).forEach(function (key) {
                if (obj[key] !== undefined && obj[key] !== null) {
                    cleaned[key] = obj[key];
                }
            });
            return cleaned;
        };
        MessageBus.prototype.keysMatch = function (obj1, obj2) {
            var keysObj1 = Object.keys(obj1);
            var allMatch = true;
            keysObj1.forEach(function (key) {
                if (obj1[key] !== obj2[key]) {
                    allMatch = false;
                }
            });
            return allMatch;
        };
        return MessageBus;
    }());

    var GlueCore = function (userConfig, ext) {
        var gdVersion = Utils.getGDMajorVersion();
        var glue42gd;
        var preloadPromise = Promise.resolve();
        if (gdVersion) {
            if (gdVersion < 3) {
                throw new Error("GD v2 is not supported. Use v4 of the API to run in that context.");
            }
            else if (gdVersion >= 3) {
                glue42gd = window.glue42gd;
                preloadPromise = window.gdPreloadPromise || preloadPromise;
            }
        }
        var glueInitTimer = timer("glue");
        userConfig = userConfig || {};
        ext = ext || {};
        var internalConfig = prepareConfig(userConfig, ext, glue42gd);
        var _connection;
        var _interop;
        var _logger;
        var _metrics;
        var _contexts;
        var _bus;
        var _allowTrace;
        var libs = {};
        function registerLib(name, inner, t) {
            _allowTrace = _logger.canPublish("trace");
            if (_allowTrace) {
                _logger.trace("registering " + name + " module");
            }
            var done = function () {
                inner.initTime = t.stop();
                inner.initEndTime = t.endTime;
                inner.marks = t.marks;
                if (_allowTrace) {
                    _logger.trace(name + " is ready - " + (t.endTime - t.startTime));
                }
            };
            inner.initStartTime = t.startTime;
            if (inner.ready) {
                inner.ready().then(function () {
                    done();
                });
            }
            else {
                done();
            }
            if (!Array.isArray(name)) {
                name = [name];
            }
            name.forEach(function (n) {
                libs[n] = inner;
                GlueCore[n] = inner;
            });
        }
        function setupConnection() {
            var initTimer = timer("connection");
            _connection = new Connection(internalConfig.connection, _logger.subLogger("connection"));
            var authPromise = Promise.resolve(internalConfig.auth);
            if (internalConfig.connection && !internalConfig.auth) {
                if (glue42gd) {
                    authPromise = glue42gd.getGWToken()
                        .then(function (token) {
                        return {
                            gatewayToken: token
                        };
                    });
                }
                else {
                    authPromise = Promise.reject("You need to provide auth information");
                }
            }
            return authPromise
                .then(function (authConfig) {
                initTimer.mark("auth-promise-resolved");
                var authRequest;
                if (Object.prototype.toString.call(authConfig) === "[object Object]") {
                    authRequest = authConfig;
                }
                else {
                    throw new Error("Invalid auth object - " + JSON.stringify(authConfig));
                }
                return _connection.login(authRequest);
            })
                .then(function () {
                registerLib("connection", _connection, initTimer);
                return internalConfig;
            })
                .catch(function (e) {
                if (_connection) {
                    _connection.logout();
                }
                throw e;
            });
        }
        function setupLogger() {
            var _a;
            var initTimer = timer("logger");
            _logger = new Logger("" + ((_a = internalConfig.connection.identity) === null || _a === void 0 ? void 0 : _a.application), undefined, internalConfig.customLogger);
            _logger.consoleLevel(internalConfig.logger.console);
            _logger.publishLevel(internalConfig.logger.publish);
            if (_logger.canPublish("debug")) {
                _logger.debug("initializing glue...");
            }
            registerLib("logger", _logger, initTimer);
            return Promise.resolve(undefined);
        }
        function setupMetrics() {
            var _a, _b, _c, _d, _e;
            var initTimer = timer("metrics");
            var config = internalConfig.metrics;
            var metricsPublishingEnabledFunc = glue42gd === null || glue42gd === void 0 ? void 0 : glue42gd.getMetricsPublishingEnabled;
            var identity = internalConfig.connection.identity;
            var canUpdateMetric = metricsPublishingEnabledFunc ? metricsPublishingEnabledFunc : function () { return true; };
            var disableAutoAppSystem = (_a = (typeof config !== "boolean" && config.disableAutoAppSystem)) !== null && _a !== void 0 ? _a : false;
            _metrics = metrics({
                connection: config ? _connection : undefined,
                logger: _logger.subLogger("metrics"),
                canUpdateMetric: canUpdateMetric,
                system: "Glue42",
                service: (_c = (_b = identity === null || identity === void 0 ? void 0 : identity.service) !== null && _b !== void 0 ? _b : glue42gd === null || glue42gd === void 0 ? void 0 : glue42gd.applicationName) !== null && _c !== void 0 ? _c : internalConfig.application,
                instance: (_e = (_d = identity === null || identity === void 0 ? void 0 : identity.instance) !== null && _d !== void 0 ? _d : identity === null || identity === void 0 ? void 0 : identity.windowId) !== null && _e !== void 0 ? _e : shortid(),
                disableAutoAppSystem: disableAutoAppSystem,
                pagePerformanceMetrics: typeof config !== "boolean" ? config === null || config === void 0 ? void 0 : config.pagePerformanceMetrics : undefined
            });
            registerLib("metrics", _metrics, initTimer);
            return Promise.resolve();
        }
        function setupInterop() {
            var initTimer = timer("interop");
            var agmConfig = {
                connection: _connection,
                logger: _logger.subLogger("interop"),
            };
            _interop = new Interop(agmConfig);
            Logger.Interop = _interop;
            registerLib(["interop", "agm"], _interop, initTimer);
            return Promise.resolve();
        }
        function setupContexts() {
            var hasActivities = (internalConfig.activities && _connection.protocolVersion === 3);
            var needsContexts = internalConfig.contexts || hasActivities;
            if (needsContexts) {
                var initTimer = timer("contexts");
                _contexts = new ContextsModule({
                    connection: _connection,
                    logger: _logger.subLogger("contexts")
                });
                registerLib("contexts", _contexts, initTimer);
                return _contexts;
            }
            else {
                var replayer = _connection.replayer;
                if (replayer) {
                    replayer.drain(ContextMessageReplaySpec.name);
                }
            }
        }
        function setupBus() {
            return __awaiter$1(this, void 0, void 0, function () {
                var initTimer;
                return __generator$1(this, function (_a) {
                    if (!internalConfig.bus) {
                        return [2, Promise.resolve()];
                    }
                    initTimer = timer("bus");
                    _bus = new MessageBus(_connection, _logger.subLogger("bus"));
                    registerLib("bus", _bus, initTimer);
                    return [2, Promise.resolve()];
                });
            });
        }
        function setupExternalLibs(externalLibs) {
            try {
                externalLibs.forEach(function (lib) {
                    setupExternalLib(lib.name, lib.create);
                });
                return Promise.resolve();
            }
            catch (e) {
                return Promise.reject(e);
            }
        }
        function setupExternalLib(name, createCallback) {
            var initTimer = timer(name);
            var lib = createCallback(libs);
            if (lib) {
                registerLib(name, lib, initTimer);
            }
        }
        function waitForLibs() {
            var libsReadyPromises = Object.keys(libs).map(function (key) {
                var lib = libs[key];
                return lib.ready ?
                    lib.ready() : Promise.resolve();
            });
            return Promise.all(libsReadyPromises);
        }
        function constructGlueObject() {
            var feedbackFunc = function (feedbackInfo) {
                if (!_interop) {
                    return;
                }
                _interop.invoke("T42.ACS.Feedback", feedbackInfo, "best");
            };
            var info = {
                coreVersion: version,
                version: internalConfig.version
            };
            glueInitTimer.stop();
            var glue = {
                feedback: feedbackFunc,
                info: info,
                logger: _logger,
                interop: _interop,
                agm: _interop,
                connection: _connection,
                metrics: _metrics,
                contexts: _contexts,
                bus: _bus,
                version: internalConfig.version,
                userConfig: userConfig,
                done: function () {
                    _logger === null || _logger === void 0 ? void 0 : _logger.info("done called by user...");
                    return _connection.logout();
                }
            };
            glue.performance = {
                get glueVer() {
                    return internalConfig.version;
                },
                get glueConfig() {
                    return JSON.stringify(userConfig);
                },
                get browser() {
                    return window.performance.timing.toJSON();
                },
                get memory() {
                    return window.performance.memory;
                },
                get initTimes() {
                    var all = getAllTimers();
                    return Object.keys(all).map(function (key) {
                        var t = all[key];
                        return {
                            name: key,
                            duration: t.endTime - t.startTime,
                            marks: t.marks
                        };
                    });
                }
            };
            Object.keys(libs).forEach(function (key) {
                var lib = libs[key];
                glue[key] = lib;
            });
            glue.config = {};
            Object.keys(internalConfig).forEach(function (k) {
                glue.config[k] = internalConfig[k];
            });
            if (ext && ext.extOptions) {
                Object.keys(ext.extOptions).forEach(function (k) {
                    glue.config[k] = ext === null || ext === void 0 ? void 0 : ext.extOptions[k];
                });
            }
            if (ext === null || ext === void 0 ? void 0 : ext.enrichGlue) {
                ext.enrichGlue(glue);
            }
            if (glue42gd && glue42gd.updatePerfData) {
                glue42gd.updatePerfData(glue.performance);
            }
            if (glue.agm) {
                var deprecatedDecorator = function (fn, wrong, proper) {
                    return function () {
                        glue.logger.warn("glue.js - 'glue.agm." + wrong + "' method is deprecated, use 'glue.interop." + proper + "' instead.");
                        return fn.apply(glue.agm, arguments);
                    };
                };
                var agmAny = glue.agm;
                agmAny.method_added = deprecatedDecorator(glue.agm.methodAdded, "method_added", "methodAdded");
                agmAny.method_removed = deprecatedDecorator(glue.agm.methodRemoved, "method_removed", "methodRemoved");
                agmAny.server_added = deprecatedDecorator(glue.agm.serverAdded, "server_added", "serverAdded");
                agmAny.server_method_aded = deprecatedDecorator(glue.agm.serverMethodAdded, "server_method_aded", "serverMethodAdded");
                agmAny.server_method_removed = deprecatedDecorator(glue.agm.serverMethodRemoved, "server_method_removed", "serverMethodRemoved");
            }
            return glue;
        }
        return preloadPromise
            .then(setupLogger)
            .then(setupConnection)
            .then(function () { return Promise.all([setupMetrics(), setupInterop(), setupContexts(), setupBus()]); })
            .then(function () { return _interop.readyPromise; })
            .then(function () {
            return setupExternalLibs(internalConfig.libs || []);
        })
            .then(waitForLibs)
            .then(constructGlueObject)
            .catch(function (err) {
            return Promise.reject({
                err: err,
                libs: libs
            });
        });
    };
    if (typeof window !== "undefined") {
        window.GlueCore = GlueCore;
    }
    GlueCore.version = version;
    GlueCore.default = GlueCore;

    var ActivityEntity = (function () {
        function ActivityEntity(id) {
            this._id = id;
        }
        Object.defineProperty(ActivityEntity.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        ActivityEntity.prototype._update = function (other) {
            if (other._id !== this._id) {
                throw Error("Can not update from entity with different id.");
            }
            this._updateCore(other);
        };
        ActivityEntity.prototype._updateCore = function (other) {
            return;
        };
        ActivityEntity.prototype._beforeDelete = function (other) {
            return;
        };
        return ActivityEntity;
    }());

    function isNumber(arg) {
        return typeof arg === "number";
    }
    function isString(arg) {
        return typeof arg === "string";
    }
    function isObject(arg) {
        return typeof arg === "object" && arg !== null;
    }
    function isArray(arg) {
        if (Array.isArray) {
            return Array.isArray(arg);
        }
        return toString.call(arg) === "[object Array]";
    }
    function isUndefined(arg) {
        return typeof arg === "undefined";
    }
    function isUndefinedOrNull(arg) {
        return !arg || typeof arg === "undefined";
    }
    function isFunction(arg) {
        return !!(arg && arg.constructor && arg.call && arg.apply);
    }
    function some(array, predicate) {
        for (var index = 0; index < array.length; index++) {
            if (predicate(array[index], index)) {
                return true;
            }
        }
        return false;
    }
    function ifNotUndefined(what, doWithIt) {
        if (typeof what !== "undefined") {
            doWithIt(what);
        }
    }
    function promisify$1(promise, successCallback, errorCallback) {
        if (typeof successCallback !== "function" && typeof errorCallback !== "function") {
            return promise;
        }
        if (typeof successCallback !== "function") {
            successCallback = function () { return; };
        }
        else if (typeof errorCallback !== "function") {
            errorCallback = function () { return; };
        }
        promise.then(successCallback, errorCallback);
    }

    var ActivityType = (function (_super) {
        __extends(ActivityType, _super);
        function ActivityType(name, ownerWindow, helperWindows, description) {
            var _this = _super.call(this, name) || this;
            _this._name = name;
            _this._description = description;
            _this._ownerWindow = ownerWindow;
            _this._helperWindows = helperWindows || [];
            return _this;
        }
        Object.defineProperty(ActivityType.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityType.prototype, "description", {
            get: function () {
                return this._description;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityType.prototype, "helperWindows", {
            get: function () {
                var _this = this;
                return this._helperWindows.map(function (hw) { return _this.covertToWindowDef(hw); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityType.prototype, "ownerWindow", {
            get: function () {
                return this.covertToWindowDef(this._ownerWindow);
            },
            enumerable: true,
            configurable: true
        });
        ActivityType.prototype.initiate = function (context, callback, configuration) {
            return this._manager.initiate(this._name, context, callback, configuration);
        };
        ActivityType.prototype._updateCore = function (other) {
            var _this = this;
            _super.prototype._updateCore.call(this, other);
            ifNotUndefined(other._description, function (x) { return _this._description = x; });
            ifNotUndefined(other._ownerWindow, function (x) { return _this._ownerWindow = x; });
            ifNotUndefined(other._helperWindows, function (x) { return _this._helperWindows = x; });
        };
        ActivityType.prototype.covertToWindowDef = function (windowType) {
            var _a, _b, _c, _d;
            return {
                type: (_b = (_a = windowType) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b.type,
                name: (_d = (_c = windowType) === null || _c === void 0 ? void 0 : _c.id) === null || _d === void 0 ? void 0 : _d.name
            };
        };
        return ActivityType;
    }(ActivityEntity));

    var WindowType = (function (_super) {
        __extends(WindowType, _super);
        function WindowType(name, appByWindowTypeGetter) {
            var _this = _super.call(this, name) || this;
            _this._name = name;
            _this._appByWindowTypeGetter = appByWindowTypeGetter;
            return _this;
        }
        Object.defineProperty(WindowType.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WindowType.prototype, "config", {
            get: function () {
                return this._appByWindowTypeGetter(this._name);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WindowType.prototype, "windows", {
            get: function () {
                return this._manager.getWindows({ type: this._name });
            },
            enumerable: true,
            configurable: true
        });
        WindowType.prototype.create = function (activity, configuration) {
            var definition = Object.assign({ type: this.name, name: this.name, isIndependent: false }, configuration);
            return this._manager.createWindow(activity, definition);
        };
        return WindowType;
    }(ActivityEntity));

    var EntityEvent = (function () {
        function EntityEvent(entitiy, context) {
            this.entity = entitiy;
            this.context = context;
        }
        return EntityEvent;
    }());
    var EntityEventContext = (function () {
        function EntityEventContext(eventType) {
            this.type = eventType;
        }
        return EntityEventContext;
    }());
    var ActivityStatusChangeEventContext = (function (_super) {
        __extends(ActivityStatusChangeEventContext, _super);
        function ActivityStatusChangeEventContext(newStatus, oldStatus) {
            var _this = _super.call(this, EntityEventType.StatusChange) || this;
            _this.newStatus = newStatus;
            _this.oldStatus = oldStatus;
            return _this;
        }
        return ActivityStatusChangeEventContext;
    }(EntityEventContext));
    var ActivityContextChangedEventContext = (function (_super) {
        __extends(ActivityContextChangedEventContext, _super);
        function ActivityContextChangedEventContext(context, updated, removed) {
            var _this = _super.call(this, EntityEventType.ActivityContextChange) || this;
            _this.context = typeof context === "string" ? JSON.parse(context) : context;
            _this.updated = updated;
            _this.removed = removed;
            return _this;
        }
        return ActivityContextChangedEventContext;
    }(EntityEventContext));
    var EntityEventType = (function () {
        function EntityEventType() {
        }
        EntityEventType.Added = "added";
        EntityEventType.Removed = "removed";
        EntityEventType.Updated = "updated";
        EntityEventType.Closed = "closed";
        EntityEventType.StatusChange = "statusChange";
        EntityEventType.ActivityContextChange = "activityContextUpdate";
        EntityEventType.ActivityWindowEvent = "activityWindowEvent";
        EntityEventType.ActivityWindowJoinedActivity = "joined";
        EntityEventType.ActivityWindowLeftActivity = "left";
        return EntityEventType;
    }());
    var ActivityState = (function () {
        function ActivityState() {
        }
        ActivityState.Created = "created";
        ActivityState.Started = "started";
        ActivityState.Destroyed = "destroyed";
        return ActivityState;
    }());

    var ActivityAGM = (function () {
        function ActivityAGM(activity) {
            this._activity = activity;
        }
        ActivityAGM.prototype.register = function (definition, handler) {
            this._ensureHasAgm();
            ActivityAGM.AGM.register(definition, handler);
        };
        ActivityAGM.prototype.servers = function () {
            this._ensureHasAgm();
            if (isUndefinedOrNull(this._activity)) {
                return [];
            }
            return this._activity.windows.map(function (w) {
                return w.instance;
            });
        };
        ActivityAGM.prototype.methods = function () {
            var _this = this;
            this._ensureHasAgm();
            if (isUndefinedOrNull(this._activity)) {
                return [];
            }
            var windows = this._activity.windows;
            var methodNames = [];
            var methods = [];
            windows.forEach(function (window) {
                var windowMethods = _this.methodsForWindow(window);
                windowMethods.forEach(function (currentWindowMethod) {
                    if (methodNames.indexOf(currentWindowMethod.name) === -1) {
                        methodNames.push(currentWindowMethod.name);
                        methods.push(currentWindowMethod);
                    }
                });
            });
            return methods;
        };
        ActivityAGM.prototype.methodsForWindow = function (window) {
            this._ensureHasAgm();
            if (!window.instance) {
                return [];
            }
            return ActivityAGM.AGM.methodsForInstance(window.instance);
        };
        ActivityAGM.prototype.invoke = function (methodName, arg, target, options, success, error) {
            this._ensureHasAgm();
            var activityServers = this.servers();
            var serversToInvokeAgainst = [];
            if (isUndefinedOrNull(target)) {
                target = "activity.all";
            }
            if (isString(target)) {
                if (target === "activity.all") {
                    serversToInvokeAgainst = activityServers;
                }
                else if (target === "activity.best") {
                    var potentialTargets = activityServers.filter(function (server) {
                        var methods = ActivityAGM.AGM.methodsForInstance(server);
                        return methods.filter(function (m) {
                            return m.name === methodName;
                        }).length > 0;
                    });
                    if (potentialTargets.length > 0) {
                        serversToInvokeAgainst = [potentialTargets[0]];
                    }
                }
                else if (target === "all" || target === "best") {
                    return promisify$1(ActivityAGM.AGM.invoke(methodName, arg, target, options), success, error);
                }
                else {
                    throw new Error("Invalid invoke target " + target);
                }
            }
            else if (isArray(target)) {
                if (target.length >= 0) {
                    var firstElem = target[0];
                    if (this._isInstance(firstElem)) {
                        serversToInvokeAgainst = target.map(function (instance) { return instance; });
                    }
                    else if (this._isActivityWindow(firstElem)) {
                        serversToInvokeAgainst = target.map(function (win) { return win.instance; });
                    }
                    else {
                        throw new Error("Unknown target object");
                    }
                }
            }
            else {
                if (this._isInstance(target)) {
                    serversToInvokeAgainst = [target];
                }
                else if (this._isActivityWindow(target)) {
                    serversToInvokeAgainst = [target.instance];
                }
                else {
                    throw new Error("Unknown target object");
                }
            }
            throw new Error("Not implemented");
        };
        ActivityAGM.prototype.unregister = function (definition) {
            this._ensureHasAgm();
            return ActivityAGM.AGM.unregister(definition);
        };
        ActivityAGM.prototype.createStream = function (methodDefinition, subscriptionAddedHandler, subscriptionRemovedHandler) {
            this._ensureHasAgm();
            ActivityAGM.AGM.createStream(methodDefinition, {
                subscriptionAddedHandler: subscriptionAddedHandler,
                subscriptionRemovedHandler: subscriptionRemovedHandler,
                subscriptionRequestHandler: undefined
            });
        };
        ActivityAGM.prototype.subscribe = function (methodDefinition, parameters, target) {
            this._ensureHasAgm();
            return ActivityAGM.AGM.subscribe(methodDefinition, parameters);
        };
        ActivityAGM.prototype._ensureHasAgm = function () {
            if (isUndefinedOrNull(ActivityAGM.AGM)) {
                throw new Error("Agm should be configured to be used in activity");
            }
        };
        ActivityAGM.prototype._isInstance = function (obj) {
            return obj.application !== undefined;
        };
        ActivityAGM.prototype._isActivityWindow = function (obj) {
            return obj.instance !== undefined;
        };
        return ActivityAGM;
    }());

    var AttachedActivityDescriptor = (function () {
        function AttachedActivityDescriptor(manager, ownerActivityId, state) {
            this._manager = manager;
            this._ownerActivityId = ownerActivityId;
            this._state = state;
        }
        Object.defineProperty(AttachedActivityDescriptor.prototype, "ownerId", {
            get: function () {
                return this._state.ownerId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AttachedActivityDescriptor.prototype, "windowIds", {
            get: function () {
                return this._state.windowIds;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AttachedActivityDescriptor.prototype, "frameColor", {
            get: function () {
                return this._state.frameColor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AttachedActivityDescriptor.prototype, "context", {
            get: function () {
                return this._state.context;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AttachedActivityDescriptor.prototype, "tag", {
            get: function () {
                return this._state.tag;
            },
            enumerable: true,
            configurable: true
        });
        AttachedActivityDescriptor.prototype.detach = function (descriptor) {
            var _this = this;
            descriptor = descriptor || {};
            var merged = {};
            Object.keys(this._state).forEach(function (prop) {
                merged[prop] = _this._state[prop];
            });
            merged.context = descriptor.context || merged.context;
            merged.frameColor = descriptor.frameColor || merged.frameColor;
            return this._manager.detachActivities(this._ownerActivityId, merged);
        };
        return AttachedActivityDescriptor;
    }());

    var nextTick = function (cb) {
        setTimeout(cb, 0);
    };
    function nodeify(promise, callback) {
        if (!isFunction(callback)) {
            return promise;
        }
        promise.then(function (resp) {
            nextTick(function () {
                callback(null, resp);
            });
        }, function (err) {
            nextTick(function () {
                callback(err, null);
            });
        });
    }

    var Activity = (function (_super) {
        __extends(Activity, _super);
        function Activity(id, actType, status, context, ownerId) {
            var _this = _super.call(this, id) || this;
            _this._id = id;
            _this._actType = actType;
            _this._status = status;
            _this._context = context;
            _this._ownerId = ownerId;
            _this._agm = new ActivityAGM(_this);
            return _this;
        }
        Object.defineProperty(Activity.prototype, "type", {
            get: function () {
                if (this._manager) {
                    return this._manager.getActivityType(this._actType);
                }
                return undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Activity.prototype, "context", {
            get: function () {
                return this._context;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Activity.prototype, "status", {
            get: function () {
                return this._status;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Activity.prototype, "owner", {
            get: function () {
                if (!this._ownerId) {
                    return null;
                }
                return this._manager.getWindows({ id: this._ownerId })[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Activity.prototype, "windows", {
            get: function () {
                return this._manager.getWindows({ activityId: this._id });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Activity.prototype, "agm", {
            get: function () {
                return this._agm;
            },
            enumerable: true,
            configurable: true
        });
        Activity.prototype.addWindow = function (window, callback) {
            return this._manager.addWindowToActivity(this, window, callback);
        };
        Activity.prototype.createWindow = function (windowType, callback) {
            return this._manager.createWindow(this, windowType, callback);
        };
        Activity.prototype.createStackedWindows = function (windowTypes, timeout, callback) {
            return this._manager.createStackedWindows(this, windowTypes, timeout, callback);
        };
        Activity.prototype.leave = function (window, callback) {
            return this._manager.leaveWindowFromActivity(this, window, callback);
        };
        Activity.prototype.getWindowsByType = function (windowType) {
            var filter = { activityId: this._id, type: windowType };
            return this._manager.getWindows(filter);
        };
        Activity.prototype.setContext = function (context, callback) {
            return this._manager.setActivityContext(this, context, callback);
        };
        Activity.prototype.updateContext = function (context, callback) {
            return this._manager.updateActivityContext(this, context, callback);
        };
        Activity.prototype.onStatusChange = function (handler) {
            var _this = this;
            return this._manager.subscribeActivityEvents(function (a, ns, os) {
                if (a.id === _this.id) {
                    handler(a, ns, os);
                }
            });
        };
        Activity.prototype.onWindowEvent = function (handler) {
            var _this = this;
            return this._manager.subscribeWindowEvents(function (a, w, e) {
                if (a.id === _this.id) {
                    handler(a, w, e);
                }
            });
        };
        Activity.prototype.onContextChanged = function (handler) {
            var _this = this;
            this._manager.subscribeActivityContextChanged(function (act, context, updated, removed) {
                if (act.id === _this.id) {
                    handler(context, updated, removed, act);
                }
            });
            try {
                handler(this.context, this.context, [], this);
            }
            catch (e) {
                return;
            }
        };
        Activity.prototype.stop = function () {
            this._manager.stopActivity(this);
        };
        Activity.prototype.clone = function (options) {
            return this._manager.clone(this, options);
        };
        Activity.prototype.attach = function (activity, tag) {
            var activityId;
            if (typeof activity === "string") {
                activityId = activity;
            }
            else {
                activityId = activity.id;
            }
            return this._manager.attachActivities(activityId, this.id, tag);
        };
        Activity.prototype.onActivityAttached = function (callback) {
            var _this = this;
            this._manager.subscribeActivitiesAttached(function (newActId, oldActId, descriptor) {
                if (newActId !== _this._id) {
                    return;
                }
                callback(descriptor);
            });
        };
        Activity.prototype.onDetached = function (callback) {
            var _this = this;
            this._manager.subscribeActivitiesDetached(function (newAct, originalActivity, state) {
                if (originalActivity.id !== _this._id) {
                    return;
                }
                callback(newAct, state);
            });
        };
        Activity.prototype._updateCore = function (other) {
            var _this = this;
            _super.prototype._updateCore.call(this, other);
            ifNotUndefined(other._actType, function (x) { return _this._actType = x; });
            ifNotUndefined(other._context, function (x) { return _this._context = x; });
            ifNotUndefined(other._ownerId, function (x) { return _this._ownerId = x; });
            if (other._status && (!this._status || (this._status.state !== other._status.state))) {
                this._status = other._status;
            }
        };
        Activity.prototype._updateDescriptors = function (allStates) {
            var _this = this;
            this._attached = allStates.map(function (s) {
                return new AttachedActivityDescriptor(_this._manager, _this._id, s);
            });
        };
        Object.defineProperty(Activity.prototype, "attached", {
            get: function () {
                return this._attached;
            },
            enumerable: true,
            configurable: true
        });
        Activity.prototype.setFrameColor = function (color, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                var callbacksToWait = _this.windows.length;
                if (callbacksToWait === 0) {
                    resolve(_this);
                }
                _this.windows.forEach(function (w) {
                    w.underlyingWindow.setFrameColor(color, function () {
                        callbacksToWait--;
                        if (callbacksToWait <= 0) {
                            resolve(_this);
                        }
                    });
                });
                setTimeout(function () {
                    if (callbacksToWait > 0) {
                        reject(_this.id + " - timed out waiting for setFrameColor with" + color);
                    }
                }, 5000);
            });
            return nodeify(promise, callback);
        };
        Activity.prototype.getFrameColor = function () {
            if (!this.windows || this.windows.length === 0) {
                return "";
            }
            return this.windows[0].underlyingWindow.frameColor;
        };
        return Activity;
    }(ActivityEntity));

    var LogLevel = (function () {
        function LogLevel() {
        }
        LogLevel.Trace = "trace";
        LogLevel.Debug = "debug";
        LogLevel.Info = "info";
        LogLevel.Warn = "warn";
        LogLevel.Error = "error";
        return LogLevel;
    }());
    var Logger$1 = (function () {
        function Logger(name) {
            this._name = name;
            if (!isUndefinedOrNull(Logger.GlueLogger)) {
                this._glueLogger = Logger.GlueLogger.subLogger(name);
            }
        }
        Logger.GetNamed = function (name) {
            return new Logger(name);
        };
        Logger.Get = function (owner) {
            return new Logger(Logger.GetTypeName(owner));
        };
        Logger.prototype.trace = function (message) {
            if (!isUndefinedOrNull(this._glueLogger)) {
                this._glueLogger.trace(message);
            }
            else {
                if (Logger.Level === LogLevel.Trace) {
                    console.info(this._getMessage(message, LogLevel.Trace));
                }
            }
        };
        Logger.prototype.debug = function (message) {
            if (!isUndefinedOrNull(this._glueLogger)) {
                this._glueLogger.debug(message);
            }
            else {
                if (Logger.Level === LogLevel.Debug ||
                    Logger.Level === LogLevel.Trace) {
                    console.info(this._getMessage(message, LogLevel.Debug));
                }
            }
        };
        Logger.prototype.info = function (message) {
            if (!isUndefinedOrNull(this._glueLogger)) {
                this._glueLogger.info(message);
            }
            else {
                if (Logger.Level === LogLevel.Debug ||
                    Logger.Level === LogLevel.Trace ||
                    Logger.Level === LogLevel.Info) {
                    console.info(this._getMessage(message, LogLevel.Info));
                }
            }
        };
        Logger.prototype.warn = function (message) {
            if (!isUndefinedOrNull(this._glueLogger)) {
                this._glueLogger.warn(message);
            }
            else {
                if (Logger.Level === LogLevel.Debug ||
                    Logger.Level === LogLevel.Trace ||
                    Logger.Level === LogLevel.Info ||
                    Logger.Level === LogLevel.Warn) {
                    console.info(this._getMessage(message, LogLevel.Info));
                }
            }
        };
        Logger.prototype.error = function (message) {
            if (!isUndefinedOrNull(this._glueLogger)) {
                this._glueLogger.error(message);
            }
            else {
                console.error(this._getMessage(message, LogLevel.Error));
                console.trace();
            }
        };
        Logger.prototype._getMessage = function (message, level) {
            return "[" + level + "] " + this._name + " - " + message;
        };
        Logger.GetTypeName = function (object) {
            var funcNameRegex = /function (.{1,})\(/;
            var results = (funcNameRegex).exec(object.constructor.toString());
            return (results && results.length > 1) ? results[1] : "";
        };
        Logger.Level = LogLevel.Info;
        return Logger;
    }());

    var ActivityWindow = (function (_super) {
        __extends(ActivityWindow, _super);
        function ActivityWindow(id, name, type, activityId, instance, isIndependent, windowGetter, hcWindowId) {
            var _this = _super.call(this, id) || this;
            _this._logger = Logger$1.Get("window");
            _this._type = type;
            _this._activityId = activityId;
            _this._name = name;
            _this._instance = instance;
            _this._isIndependent = isIndependent;
            _this._windowGetter = windowGetter;
            _this._hcWindowId = hcWindowId;
            return _this;
        }
        ActivityWindow.prototype.getBounds = function () {
            return this._manager.getWindowBounds(this.id);
        };
        Object.defineProperty(ActivityWindow.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityWindow.prototype, "isIndependent", {
            get: function () {
                return this._isIndependent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityWindow.prototype, "type", {
            get: function () {
                if (this._manager) {
                    return this._manager.getWindowType(this._type);
                }
                return undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityWindow.prototype, "activity", {
            get: function () {
                if (isUndefined(this._activityId)) {
                    return undefined;
                }
                return this._manager.getActivityById(this._activityId);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityWindow.prototype, "isOwner", {
            get: function () {
                var act = this.activity;
                if (isUndefined(act)) {
                    return false;
                }
                return act.owner.id === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ActivityWindow.prototype.setVisible = function (isVisible, callback) {
            return this._manager.setWindowVisibility(this.id, isVisible);
        };
        ActivityWindow.prototype.activate = function (focus) {
            return this._manager.activateWindow(this.id, focus);
        };
        ActivityWindow.prototype.setBounds = function (bounds, callback) {
            return this._manager.setWindowBounds(this.id, bounds, callback);
        };
        ActivityWindow.prototype.close = function () {
            return this._manager.closeWindow(this.id);
        };
        Object.defineProperty(ActivityWindow.prototype, "instance", {
            get: function () {
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityWindow.prototype, "underlyingWindow", {
            get: function () {
                var window = this._windowGetter();
                if (!window) {
                    return {
                        id: this._hcWindowId
                    };
                }
                return window;
            },
            enumerable: true,
            configurable: true
        });
        ActivityWindow.prototype.onActivityJoined = function (callback) {
            this._subscribeForActivityWindowEvent(EntityEventType.ActivityWindowJoinedActivity, callback);
        };
        ActivityWindow.prototype.onActivityRemoved = function (callback) {
            this._subscribeForActivityWindowEvent(EntityEventType.ActivityWindowLeftActivity, callback);
        };
        ActivityWindow.prototype._updateCore = function (other) {
            var _this = this;
            ifNotUndefined(other._activityId, function (x) { return _this._activityId = x; });
            ifNotUndefined(other._isIndependent, function (x) { return _this._isIndependent = x; });
            ifNotUndefined(other._hcWindowId, function (x) { return _this._hcWindowId = x; });
            ifNotUndefined(other._type, function (x) { return _this._type = x; });
            ifNotUndefined(other._name, function (x) { return _this._name = x; });
            if (!isUndefinedOrNull(other._instance)) {
                this._instance = other._instance;
            }
        };
        ActivityWindow.prototype._subscribeForActivityWindowEvent = function (eventName, callback) {
            var _this = this;
            this._manager.subscribeWindowEvents(function (activity, window, event) {
                if (window.id !== _this.id) {
                    return;
                }
                if (event === eventName) {
                    callback(activity);
                }
            });
        };
        ActivityWindow.prototype._beforeDelete = function (other) {
            this._hcWindowId = other._hcWindowId;
        };
        return ActivityWindow;
    }(ActivityEntity));

    var ActivityStatus = (function () {
        function ActivityStatus(state, message, time) {
            this.state = state;
            this.message = message;
            this.time = time;
        }
        ActivityStatus.prototype.getState = function () {
            return this.state;
        };
        ActivityStatus.prototype.getMessage = function () {
            return this.message;
        };
        ActivityStatus.prototype.getTime = function () {
            return this.time;
        };
        return ActivityStatus;
    }());

    var gwMmessageError = "error";
    var gwMessageAddActivityTypes = "add-types";
    var gwMmessageActivityTypesAdded = "types-added";
    var gwMessageRemoveActivityTypes = "remove-types";
    var gwMessageActivityTypesRemoved = "types-removed";
    var gwMessageActivityCreated = "created";
    var gwMessageActivityDestroyed = "destroyed";
    var gwMessageActivityInitiated = "initiated";
    var gwMmessageJoinActivity = "join-activity";
    var gwMessageJoinedActivity = "joined";
    var gwMessageActivityJoined = "activity-joined";
    var gwMessageLeaveActivity = "leave-activity";
    var gwMessageActivityLeft = "left";
    var gwNmessageMergeActivities = "merge";
    var gwMessageSplitActivities = "split";
    var gwMessageOwnerChanged = "owner-changed";
    var gwMessageAddPeerFactories = "add-peer-factories";
    var gwMessagePeerFactoriesAdded = "peer-factories-added";
    var gwMessageRemovePeerFactories = "remove-peer-factories";
    var gwMessagePeerFactoriesRemoved = "peer-factories-removed";
    var gwMessageCreateActivity = "create";
    var gwMessageCreatePeer = "create-peer";
    var gwMessagePeerRequested = "peer-requested";
    var gwMessageReady = "ready";
    var gwMessagePeerCreated = "peer-created";
    var gwMessageDestroyActivity = "destroy";
    var gwMessageDisposePeer = "dispose-peer";
    var gwMessageDestroyPeer = "destroy-peer";
    var GW3Bridge$1 = (function () {
        function GW3Bridge(config) {
            var _this = this;
            this._activityChangeCallbacks = [];
            this._activityTypeStatusChangeCallbacks = [];
            this._activityWindowChangeCallbacks = [];
            this._windowTypeStatusChangeCallbacks = [];
            this._peerIdAndFactoryIdToPeerType = {};
            this._peerFactoriesRegisteredByUs = {};
            this._gw3Subscriptions = [];
            this._contextSubscriptions = {};
            this._activityTypesInitiatedFromMe = {};
            this._config = config;
            this._connection = config.connection;
            this._logger = config.logger;
            this._contexts = config.contexts;
            this._windows = config.windows;
            this._sessionJoinedPromise = new Promise(function (resolve) {
                _this._sessionJoinedPromiseResolve = resolve;
            });
            this._activityJoinedPromise = new Promise(function (resolve) {
                _this._activityJoinedPromiseResolve = resolve;
            });
            if (!this._config.activityId) {
                this._activityJoinedPromiseResolve({});
            }
            this._gw3Session = this._connection.domain("activity", ["joined", "initiated", "peer-created", "token"]);
            if (typeof window !== "undefined") {
                var glue42gd_1 = window.glue42gd;
                if (glue42gd_1 && typeof glue42gd_1.addRefreshHandler === "function") {
                    glue42gd_1.addRefreshHandler(function (success, error) {
                        _this._gw3Session
                            .send({
                            type: "reload"
                        })
                            .then(function (msg) {
                            if (!msg.token) {
                                error("Expected gateway token for refreshing.");
                                return;
                            }
                            try {
                                glue42gd_1.setGWToken(msg.token);
                            }
                            catch (e) {
                                error(e.message || e);
                                return;
                            }
                            success();
                        }, error);
                    });
                }
            }
        }
        GW3Bridge.activityTypeGwMessageEntityToActivityType = function (entity, description) {
            var nameToWindowType = function (windowName) {
                return new WindowType(windowName, undefined);
            };
            return new ActivityType(entity.name, entity.owner_type && nameToWindowType(entity.owner_type), entity.helper_types && entity.helper_types.map(nameToWindowType), description);
        };
        GW3Bridge.peerFactoryGwMessageEntityToWindowType = function (entity) {
            return new WindowType(entity.peer_type, function (_) { return undefined; });
        };
        GW3Bridge.activityGwMessageToActivity = function (msg, status) {
            var ownerId = msg.owner !== undefined ? msg.owner.peer_id : msg.owner_id;
            return new Activity(msg.activity_id, msg.activity_type, status, msg.context_snapshot, ownerId);
        };
        GW3Bridge.activityToActivityStatusChangeEvent = function (act) {
            return new EntityEvent(act, new ActivityStatusChangeEventContext(act.status, undefined));
        };
        Object.defineProperty(GW3Bridge.prototype, "bridgeType", {
            get: function () {
                return "GW3";
            },
            enumerable: true,
            configurable: true
        });
        GW3Bridge.prototype.init = function () {
            var _this = this;
            this.forwardActivityTypeMessagesToStatusEventHandlers();
            this.subscribe(gwMessageActivityCreated, this.handleActivityCreatedMessage);
            this.subscribe(gwMessageActivityDestroyed, this.handleActivityDestroyedMessage);
            this.forwardActivityMessagesToStatusEventHandlers();
            this.forwardActivityCreatedAndJoinedActivityToActivityWindowEventHandlers();
            this.forwardPeerFactoryMessagesToStatusEventHandlers();
            this.forwardPeerFactoryMessagesToPeerFactoryRequests();
            this.subscribe(gwMessagePeerFactoriesAdded, this.handlePeerFactoriesAdded);
            this.subscribe(gwMessagePeerFactoriesRemoved, this.handlePeerFactoriesRemoved);
            this.forwardActivityWindowMessagesToEventHandlers();
            this.subscribe(gwMessageDisposePeer, function () {
                if (_this._config.disposeRequestHandling === "dispose") {
                    _this.dispose();
                    return;
                }
                if (_this._config.disposeRequestHandling === "exit") {
                    if (_this._windows && typeof _this._windows.my() !== "undefined") {
                        _this._windows.my().close();
                        return;
                    }
                    if (typeof window !== "undefined" && typeof window.close === "function") {
                        window.close();
                        return;
                    }
                    if (typeof process !== "undefined" && typeof process.exit === "function") {
                        process.exit();
                        return;
                    }
                }
            });
            this._gw3Session.onJoined(function () {
                if (_this._config.mode === "trackMyOnly" ||
                    _this._config.mode === "trackMyTypeAndInitiatedFromMe") {
                    _this._sessionJoinedPromiseResolve(_this);
                }
                else {
                    _this._gw3Session
                        .send({
                        type: "subscribe",
                        activity_types: (_this._config.mode === "trackAll" ? [] :
                            _this._config.mode === "trackTypes" ? _this._config.typesToTrack : [])
                    })
                        .then(function () {
                        _this._sessionJoinedPromiseResolve(_this);
                    });
                }
            });
            this._gw3Session.join();
        };
        GW3Bridge.prototype.dispose = function () {
            var _this = this;
            this._gw3Subscriptions.forEach(function (sub) { return sub && _this._connection.off(sub); });
            this._gw3Subscriptions.length = 0;
        };
        GW3Bridge.prototype.ready = function () {
            return Promise.all([this._sessionJoinedPromise, this._activityJoinedPromise]);
        };
        GW3Bridge.prototype.initReady = function () {
            return this._sessionJoinedPromise;
        };
        GW3Bridge.prototype.onActivityTypeStatusChange = function (callback) {
            this._activityTypeStatusChangeCallbacks.push(callback);
        };
        GW3Bridge.prototype.registerActivityType = function (activityTypeName, ownerWindow, helperWindows, config, description) {
            var _this = this;
            var entity = {};
            entity.name = activityTypeName;
            var toActivityPeerConfig = function (windowDefinition) { return ({ type: windowDefinition.type, name: windowDefinition.name, configuration: windowDefinition }); };
            entity.owner_type = toActivityPeerConfig(ownerWindow);
            entity.helper_types = helperWindows.map(toActivityPeerConfig);
            return this._gw3Session
                .send({
                type: gwMessageAddActivityTypes,
                types: [entity]
            })
                .then(function () {
                var activityType = GW3Bridge.activityTypeGwMessageEntityToActivityType(entity, description);
                _this.invokeCallbacks(_this._activityTypeStatusChangeCallbacks, new EntityEvent(activityType, new EntityEventContext(EntityEventType.Added)), gwMessageAddActivityTypes);
                return activityType;
            });
        };
        GW3Bridge.prototype.unregisterActivityType = function (activityTypeName) {
            var _this = this;
            return this._gw3Session
                .send({
                type: gwMessageRemoveActivityTypes,
                types: [activityTypeName]
            })
                .then(function () {
                var activityType = new ActivityType(activityTypeName, undefined, undefined, undefined);
                _this.invokeCallbacks(_this._activityTypeStatusChangeCallbacks, new EntityEvent(activityType, new EntityEventContext(EntityEventType.Removed)), gwMessageAddActivityTypes);
            });
        };
        GW3Bridge.prototype.onWindowTypeStatusChange = function (callback) {
            this._windowTypeStatusChangeCallbacks.push(callback);
        };
        GW3Bridge.prototype.registerWindowFactory = function (windowType, factory, parameters) {
            var _this = this;
            if (this._peerFactoriesRegisteredByUs[windowType]) {
                return Promise.reject(new Error("Factory for windowType " + windowType + " already registered."));
            }
            this._peerFactoriesRegisteredByUs[windowType] = factory;
            var entity = {
                id: windowType,
                peer_type: windowType,
                configuration: parameters
            };
            return this._gw3Session.send({
                type: gwMessageAddPeerFactories,
                factories: [entity]
            })
                .then(function () {
                _this.invokeCallbacks(_this._windowTypeStatusChangeCallbacks, new EntityEvent(GW3Bridge.peerFactoryGwMessageEntityToWindowType(entity), new EntityEventContext(EntityEventType.Added)), gwMessageAddPeerFactories);
            })
                .catch(function () {
                delete _this._peerFactoriesRegisteredByUs[windowType];
            });
        };
        GW3Bridge.prototype.unregisterWindowFactory = function (windowType) {
            var _this = this;
            var factory = this._peerFactoriesRegisteredByUs[windowType];
            if (!factory) {
                return Promise.reject(new Error("Factory for windowType " + windowType + " not registered."));
            }
            delete this._peerFactoriesRegisteredByUs[windowType];
            return this._gw3Session.send({
                type: gwMessageRemovePeerFactories,
                factory_ids: [windowType]
            }).then(function () {
                _this.invokeCallbacks(_this._windowTypeStatusChangeCallbacks, new EntityEvent(new WindowType(windowType, undefined), new EntityEventContext(EntityEventType.Removed)), gwMessageAddPeerFactories);
            });
        };
        GW3Bridge.prototype.onActivityStatusChange = function (callback) {
            this._activityChangeCallbacks.push(callback);
        };
        GW3Bridge.prototype.initiateActivity = function (activityType, context, configuration) {
            var _this = this;
            var initiateMsg = {
                type: gwMessageCreateActivity,
                activity_type: activityType,
                initial_context: context,
            };
            if (this.isOverrideTypeDefinition(configuration)) {
                initiateMsg.types_override = {
                    owner_type: { type: configuration.owner.type, name: configuration.owner.name, configuration: configuration.owner },
                    helper_types: configuration.helpers && configuration.helpers.map(function (wd) { return ({ type: wd.type, name: wd.name, configuration: wd }); })
                };
            }
            else {
                initiateMsg.configuration = configuration && configuration.map(function (wd) { return ({ type: wd.type, name: wd.name, configuration: wd }); });
            }
            return this.sendCreateAndMapResultingMessagesToPromise(initiateMsg, gwMessageActivityInitiated, function (msg, requestId) { return msg.request_id === requestId; }, gwMessageActivityCreated, function (msg, requestId, initMsg) { return msg.activity_id === initMsg.activity_id; }, gwMessageActivityDestroyed, function (msg, requestId, initMsg) { return msg.activity_id === initMsg.activity_id; }, function (msg) { return msg.activity_id; }).then(function (id) {
                if (_this._config.mode === "trackMyTypeAndInitiatedFromMe") {
                    if (!_this._activityTypesInitiatedFromMe[activityType]) {
                        _this._activityTypesInitiatedFromMe[activityType] = true;
                        return _this._gw3Session
                            .send({
                            type: "subscribe",
                            activity_types: [activityType]
                        })
                            .then(function () {
                            return id;
                        });
                    }
                }
                return id;
            });
        };
        GW3Bridge.prototype.stopActivity = function (activity) {
            return this._gw3Session.send({
                type: gwMessageDestroyActivity,
                activity_id: activity.id,
                reason_uri: "com.tick42.glue.activity.constants.destroyReason.general",
                reason: "Destroying activity"
            }).then(function (_) { return true; });
        };
        GW3Bridge.prototype.updateActivityContext = function (activity, context, fullReplace, removedKeys) {
            if (fullReplace) {
                return this._contexts.set(activity.id, context);
            }
            else {
                removedKeys = removedKeys || [];
                for (var _i = 0, removedKeys_1 = removedKeys; _i < removedKeys_1.length; _i++) {
                    var x = removedKeys_1[_i];
                    context[x] = null;
                }
                return this._contexts.update(activity.id, context);
            }
        };
        GW3Bridge.prototype.announceWindow = function (windowType, activityWindowId) {
            throw new Error("Invalid operation 'announceWindow' for GW3 protocol");
        };
        GW3Bridge.prototype.registerWindow = function (type, name, independent) {
            var shouldSendReady = typeof this._connection.gatewayToken !== "undefined";
            var peerId = this._connection.peerId;
            if (typeof window !== "undefined") {
                var glue42gd = window.glue42gd;
                if (glue42gd) {
                    shouldSendReady = typeof glue42gd.activityInfo !== "undefined";
                }
            }
            if (shouldSendReady) {
                this._gw3Session.send({
                    type: gwMessageReady,
                });
            }
            this.invokeCallbacks(this._activityWindowChangeCallbacks, new EntityEvent(new ActivityWindow(peerId, name, type, undefined, this.getAgmInstance(peerId), independent, this.generateWindowGetter(peerId), undefined), new EntityEventContext(EntityEventType.Added)), "register window");
            return Promise.resolve(peerId);
        };
        GW3Bridge.prototype.onActivityWindowChange = function (callback) {
            this._activityWindowChangeCallbacks.push(callback);
        };
        GW3Bridge.prototype.createWindow = function (activityId, windowDefinition) {
            var _this = this;
            if (!windowDefinition.layout) {
                if (windowDefinition.left || windowDefinition.width || windowDefinition.height || windowDefinition.top) {
                    windowDefinition.layout = {
                        mode: "pixels",
                        cellSize: 1,
                    };
                }
            }
            return this.sendCreateAndMapResultingMessagesToPromise({
                type: gwMessageCreatePeer,
                peer_type: windowDefinition.type,
                peer_name: windowDefinition.name || windowDefinition.type,
                configuration: windowDefinition,
                activity_id: activityId,
            }, undefined, undefined, gwMessagePeerCreated, function (msg, requestId) { return msg.request_id === requestId; }, undefined, undefined, function (msg) { return msg.created_id; })
                .then(function (id) {
                if (!activityId) {
                    return;
                }
                return _this.joinActivity(activityId, id, windowDefinition.name)
                    .then(function () {
                    return id;
                });
            });
        };
        GW3Bridge.prototype.closeWindow = function (id) {
            return this._gw3Session.send({
                type: gwMessageDestroyPeer,
                destroy_peer_id: id
            }).then(function (_) { return undefined; });
        };
        GW3Bridge.prototype.getAnnouncementInfo = function () {
            var activityId = this._config.activityId || (this._config.announcementInfo && this._config.announcementInfo.activityId);
            var activityWindowType = (this._config.announcementInfo && this._config.announcementInfo.activityWindowType);
            var activityWindowIndependent = (this._config.announcementInfo && this._config.announcementInfo.activityWindowIndependent);
            var activityWindowName = (this._config.announcementInfo && this._config.announcementInfo.activityWindowName);
            if (typeof window !== "undefined" &&
                typeof window.location !== "undefined" &&
                window.location.search &&
                typeof URLSearchParams === "function") {
                var searchParams = new URLSearchParams(location.search.slice(1));
                activityWindowType = activityWindowType || searchParams.get("t42PeerType");
                activityWindowType = activityWindowType || searchParams.get("t42ActivityWindowType");
                if (typeof activityWindowIndependent === "undefined") {
                    activityWindowIndependent = searchParams.get("t42ActivityWindowIndependent");
                }
                activityWindowName = activityWindowName || searchParams.get("t42ActivityWindowName");
                activityId = activityId || searchParams.get("t42ActivityId");
            }
            activityWindowType = activityWindowType || "unknown";
            activityWindowIndependent = activityWindowIndependent || false;
            activityWindowName = activityWindowName || this._connection.peerId;
            return {
                activityWindowId: undefined,
                activityId: activityId,
                activityWindowType: activityWindowType,
                activityWindowIndependent: activityWindowIndependent,
                activityWindowName: activityWindowName,
            };
        };
        GW3Bridge.prototype.joinActivity = function (activityId, windowId, name) {
            var _this = this;
            var maybeName = (name && { name: name }) || {};
            return this._gw3Session.send(__assign({ type: gwMmessageJoinActivity, target_id: windowId, activity_id: activityId }, maybeName)).then(function () {
                _this.invokeCallbacks(_this._activityWindowChangeCallbacks, new EntityEvent(new ActivityWindow(windowId, undefined, undefined, activityId, _this.getAgmInstance(windowId), undefined, _this.generateWindowGetter(windowId), undefined), new EntityEventContext(EntityEventType.ActivityWindowJoinedActivity)), "activity joined - ActivityWindow");
                _this.invokeCallbacks(_this._activityChangeCallbacks, new EntityEvent(new Activity(activityId, undefined, new ActivityStatus("created", undefined, undefined), undefined, undefined), new EntityEventContext(EntityEventType.Updated)), "activity joined - Activity");
            });
        };
        GW3Bridge.prototype.leaveActivity = function (activityId, windowId) {
            var _this = this;
            return this._gw3Session.send({
                type: gwMessageLeaveActivity,
                target_id: windowId,
                activity_id: activityId
            }).then(function () {
                _this.invokeCallbacks(_this._activityWindowChangeCallbacks, new EntityEvent(new ActivityWindow(windowId, undefined, undefined, null, _this.getAgmInstance(windowId), undefined, _this.generateWindowGetter(windowId), undefined), new EntityEventContext(EntityEventType.ActivityWindowLeftActivity)), "activity left - ActivityWindow");
                _this.invokeCallbacks(_this._activityChangeCallbacks, new EntityEvent(new Activity(activityId, undefined, new ActivityStatus("created", undefined, undefined), undefined, undefined), new EntityEventContext(EntityEventType.Updated)), "activity left - Activity");
            });
        };
        GW3Bridge.prototype.getActivityTypes = function () {
            return Promise.resolve([]);
        };
        GW3Bridge.prototype.getWindowTypes = function () {
            return Promise.resolve([]);
        };
        GW3Bridge.prototype.getActivities = function () {
            return Promise.resolve([]);
        };
        GW3Bridge.prototype.getActivityWindows = function () {
            return Promise.resolve([]);
        };
        GW3Bridge.prototype.createStackedWindows = function (id, windowDefinitions, timeout) {
            return undefined;
        };
        GW3Bridge.prototype.getWindowBounds = function (id) {
            return undefined;
        };
        GW3Bridge.prototype.setWindowBounds = function (id, bounds) {
            return undefined;
        };
        GW3Bridge.prototype.activateWindow = function (id, focus) {
            return undefined;
        };
        GW3Bridge.prototype.setWindowVisibility = function (id, visible) {
            return undefined;
        };
        GW3Bridge.prototype.cloneActivity = function (id, cloneOptions) {
            return undefined;
        };
        GW3Bridge.prototype.attachActivities = function (from, to, tag) {
            return this._gw3Session.send({
                type: gwNmessageMergeActivities,
                into: to,
                merge: from
            });
        };
        GW3Bridge.prototype.detachActivities = function (activityId, newActivityInfo) {
            return this._gw3Session.send({
                type: gwMessageSplitActivities,
                from: activityId,
            }).then(function () { return ""; });
        };
        GW3Bridge.prototype.onActivitiesAttached = function (callback) {
        };
        GW3Bridge.prototype.onActivitiesDetached = function (callback) {
        };
        GW3Bridge.prototype.onActivityAttachedDescriptorsRefreshed = function (callback) {
        };
        GW3Bridge.prototype.getAttachedDescriptors = function () {
            return Promise.resolve([]);
        };
        GW3Bridge.prototype.getRandomRequestId = function () {
            return this._connection.peerId + ":" + Math.floor(Math.random() * 1e9) + "";
        };
        GW3Bridge.prototype.forwardAddedAndRemovedMessagesToEventHandler = function (addedMessageType, removedMessageType, mapper, handlers) {
            var getGetEntityEvent = function (isAdded) { return function (entity) { return new EntityEvent(entity, new EntityEventContext(isAdded ?
                EntityEventType.Added :
                EntityEventType.Removed)); }; };
            var sub1;
            var sub2;
            sub1 = addedMessageType && this.forwardMessageToEventHandler(addedMessageType, function (msg) { return mapper(msg, true); }, getGetEntityEvent(true), handlers);
            sub2 = removedMessageType && this.forwardMessageToEventHandler(removedMessageType, function (msg) { return mapper(msg, false); }, getGetEntityEvent(false), handlers);
            return [sub1, sub2].filter(function (x) { return x; });
        };
        GW3Bridge.prototype.forwardMessageToEventHandler = function (messageType, mapper, getEntityEvent, handler) {
            return this.subscribe(messageType, function (msg) {
                mapper(msg)
                    .forEach(function (ent) {
                    return handler.forEach(function (h) { return h(getEntityEvent(ent, msg)); });
                });
            });
        };
        GW3Bridge.prototype.sendCreateAndMapResultingMessagesToPromise = function (msg, initiatedMessageType, initiatedMessageFilter, createdMessageType, createdMessageFilter, cancelledMessageType, cancelledMessageFilter, createdMessageToPromiseResolution) {
            var _this = this;
            var reqId = this.getRandomRequestId();
            var resolveCreatedPromise;
            var rejectCreatedPromise;
            var createdPromise = new Promise(function (resolve, reject) {
                resolveCreatedPromise = resolve;
                rejectCreatedPromise = reject;
            });
            var initiatedMessageAck = null;
            var initiatedSubscription;
            var createdSubscription;
            var cancelledSubscription;
            var errorSubscription;
            var dropSubscriptions = function () {
                _this.dropSubscription(initiatedSubscription);
                _this.dropSubscription(createdSubscription);
                _this.dropSubscription(cancelledSubscription);
                _this.dropSubscription(errorSubscription);
            };
            initiatedSubscription = initiatedMessageType &&
                this.subscribe(initiatedMessageType, function (msg4) {
                    if (!initiatedMessageFilter(msg4, reqId)) {
                        return;
                    }
                    initiatedMessageAck = msg4;
                    _this.dropSubscription(initiatedSubscription);
                });
            createdSubscription =
                this.subscribe(createdMessageType, function (msg1) {
                    if (!createdMessageFilter(msg1, reqId, initiatedMessageAck)) {
                        return;
                    }
                    resolveCreatedPromise(createdMessageToPromiseResolution(msg1));
                });
            cancelledSubscription = cancelledMessageType &&
                this.subscribe(cancelledMessageType, function (msg2) {
                    if (!cancelledMessageFilter(msg2, reqId, initiatedMessageAck)) {
                        return;
                    }
                    rejectCreatedPromise(msg2);
                });
            errorSubscription = cancelledMessageType &&
                this.subscribe(gwMmessageError, function (msg3) {
                    if (msg3.request_id !== reqId) {
                        return;
                    }
                    rejectCreatedPromise(msg3);
                });
            msg.request_id = reqId;
            var toReturn = this._gw3Session
                .send(msg)
                .then(function () {
                return createdPromise;
            });
            toReturn.then(dropSubscriptions, dropSubscriptions);
            return toReturn;
        };
        GW3Bridge.prototype.peerFactoryIdAndOwnerIdToWindowType = function (factoryId, ownerId) {
            var peerType = this._peerIdAndFactoryIdToPeerType[ownerId + ":" + factoryId];
            if (!peerType) {
                return null;
            }
            else {
                return new WindowType(peerType, undefined);
            }
        };
        GW3Bridge.prototype.subscribe = function (messageType, handler) {
            var _this = this;
            var sub = this._connection.on(messageType, function (msg) { return handler.bind(_this)(msg); });
            this._gw3Subscriptions.push(sub);
            return sub;
        };
        GW3Bridge.prototype.dropSubscription = function (subscription) {
            if (subscription) {
                this._connection.off(subscription);
                delete this._gw3Subscriptions[this._gw3Subscriptions.indexOf(subscription)];
            }
        };
        GW3Bridge.prototype.invokeCallbacks = function (callbacks, event, description) {
            var _this = this;
            callbacks.forEach(function (cb) {
                try {
                    cb(event);
                }
                catch (err) {
                    _this._logger.error("Error in " + (description || event.context.type) + " callback: " + JSON.stringify(err));
                }
            });
        };
        GW3Bridge.prototype.handleActivityCreatedMessage = function (msg) {
            if (!msg.context_id) {
                this._logger.error("Activity created with unknown context_id: " + msg.activity_id);
            }
            else {
                if (!this._contextSubscriptions[msg.activity_id]) {
                    this.subscribeToContext(msg);
                }
            }
        };
        GW3Bridge.prototype.subscribeToContext = function (msg) {
            return __awaiter(this, void 0, void 0, function () {
                var activityId, _a, _b;
                var _this = this;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            activityId = msg.activity_id;
                            _a = this._contextSubscriptions;
                            _b = activityId;
                            return [4, this._contexts.subscribe(activityId, function (data, updated, removed) {
                                    var event = new EntityEvent(new Activity(activityId, undefined, undefined, data, undefined), new ActivityContextChangedEventContext(data, updated, removed));
                                    _this.invokeCallbacks(_this._activityChangeCallbacks, event, "context updated");
                                })];
                        case 1:
                            _a[_b] =
                                _c.sent();
                            return [2];
                    }
                });
            });
        };
        GW3Bridge.prototype.handleActivityDestroyedMessage = function (msg) {
            var unsubscribeContext = this._contextSubscriptions[msg.activity_id];
            if (typeof unsubscribeContext === "function") {
                unsubscribeContext();
            }
            delete this._contextSubscriptions[msg.activity_id];
        };
        GW3Bridge.prototype.handlePeerFactoriesAdded = function (msg) {
            var _this = this;
            msg.factories.forEach(function (entity) {
                _this._peerIdAndFactoryIdToPeerType[msg.owner_id + ":" + entity.id] = entity.peer_type;
            });
        };
        GW3Bridge.prototype.handlePeerFactoriesRemoved = function (msg) {
            var _this = this;
            msg.factory_ids.forEach(function (factoryId) {
                delete _this._peerIdAndFactoryIdToPeerType[msg.owner_id + ":" + factoryId];
            });
        };
        GW3Bridge.prototype.forwardActivityTypeMessagesToStatusEventHandlers = function () {
            this.forwardAddedAndRemovedMessagesToEventHandler(gwMmessageActivityTypesAdded, gwMessageActivityTypesRemoved, function (msg, isAdded) { return isAdded
                ? msg.types.map(function (t) { return GW3Bridge.activityTypeGwMessageEntityToActivityType(t, undefined); })
                : msg.types.map(function (t) { return new ActivityType(t.name, undefined, undefined, undefined); }); }, this._activityTypeStatusChangeCallbacks);
        };
        GW3Bridge.prototype.forwardActivityCreatedAndJoinedActivityToActivityWindowEventHandlers = function () {
            var _this = this;
            for (var _i = 0, _a = [gwMessageActivityCreated, gwMessageJoinedActivity, gwMessageOwnerChanged]; _i < _a.length; _i++) {
                var activityCreatedMessage = _a[_i];
                this.forwardMessageToEventHandler(activityCreatedMessage, function (msg) {
                    return ([msg.owner || __assign(__assign({}, msg), { type: msg.peer_type, name: msg.peer_name, peer_id: msg.owner_id })])
                        .concat(msg.participants || [])
                        .map(function (info) { return new ActivityWindow(info.peer_id, info.name, info.type, msg.activity_id, _this.getAgmInstance(info.peer_id), undefined, _this.generateWindowGetter(info.peer_id), undefined); });
                }, function (ent, msg) { return new EntityEvent(ent, new EntityEventContext(EntityEventType.ActivityWindowJoinedActivity)); }, this._activityWindowChangeCallbacks);
            }
        };
        GW3Bridge.prototype.forwardActivityMessagesToStatusEventHandlers = function () {
            for (var _i = 0, _a = [gwMessageActivityCreated, gwMessageJoinedActivity]; _i < _a.length; _i++) {
                var createdMessage = _a[_i];
                this.forwardMessageToEventHandler(createdMessage, function (msg) { return [GW3Bridge.activityGwMessageToActivity(msg, new ActivityStatus("started", "", new Date()))]; }, function (ent, msg) { return GW3Bridge.activityToActivityStatusChangeEvent(ent); }, this._activityChangeCallbacks);
            }
            this.forwardMessageToEventHandler(gwMessageActivityDestroyed, function (msg) { return [GW3Bridge.activityGwMessageToActivity(msg, new ActivityStatus("destroyed", msg.reason, new Date()))]; }, function (ent, msg) { return GW3Bridge.activityToActivityStatusChangeEvent(ent); }, this._activityChangeCallbacks);
            this.forwardMessageToEventHandler(gwMessageActivityInitiated, function (msg) { return [GW3Bridge.activityGwMessageToActivity(msg, new ActivityStatus("created", "", new Date()))]; }, function (ent, msg) { return GW3Bridge.activityToActivityStatusChangeEvent(ent); }, this._activityChangeCallbacks);
            this.forwardMessageToEventHandler(gwMessageOwnerChanged, function (msg) { return [GW3Bridge.activityGwMessageToActivity(msg, new ActivityStatus("created", "", new Date()))]; }, function (ent, msg) { return GW3Bridge.activityToActivityStatusChangeEvent(ent); }, this._activityChangeCallbacks);
        };
        GW3Bridge.prototype.forwardPeerFactoryMessagesToStatusEventHandlers = function () {
            var _this = this;
            this.forwardAddedAndRemovedMessagesToEventHandler(gwMessagePeerFactoriesAdded, gwMessagePeerFactoriesRemoved, function (msg, isAdded) { return isAdded
                ? msg.factories.map(GW3Bridge.peerFactoryGwMessageEntityToWindowType)
                : msg.factory_ids.map(function (id) { return _this.peerFactoryIdAndOwnerIdToWindowType(id, msg.owner_id); }).filter(function (x) { return x != null; }); }, this._windowTypeStatusChangeCallbacks);
        };
        GW3Bridge.prototype.forwardPeerFactoryMessagesToPeerFactoryRequests = function () {
            var _this = this;
            this.subscribe(gwMessagePeerRequested, function (msg) {
                var factory = _this._peerFactoriesRegisteredByUs[msg.peer_factory];
                if (!factory) {
                    _this._gw3Session.send({
                        type: gwMmessageError,
                        request_id: msg.request_id,
                        reason: "Unknown peer factory " + msg.peer_factory
                    });
                    return;
                }
                try {
                    var configuration = msg.configuration || {};
                    configuration.gateway_token = configuration.gateway_token || msg.gateway_token;
                    configuration.peer_factory = configuration.peer_factory || msg.peer_factory;
                    var promise = factory({
                        activityId: msg.activity && msg.activity.id,
                        activityType: msg.activity && msg.activity.type,
                        type: msg.configuration && msg.configuration.type,
                        gwToken: configuration.gateway_token,
                        configuration: configuration
                    });
                    if (promise && promise.then && promise.catch) {
                        promise.catch(function (err) { return _this._gw3Session.send({
                            type: gwMmessageError,
                            request_id: msg.request_id,
                            reason: err && (err.message || JSON.stringify(err))
                        }); });
                    }
                }
                catch (err) {
                    _this._gw3Session.send({
                        type: gwMmessageError,
                        request_id: msg.request_id,
                        reason: err && (err.message || JSON.stringify(err))
                    });
                }
            });
        };
        GW3Bridge.prototype.forwardActivityWindowMessagesToEventHandlers = function () {
            var _this = this;
            var _loop_1 = function (joinedMessage) {
                this_1.subscribe(joinedMessage, function (msg) {
                    var joinedId = (joinedMessage === gwMessageActivityJoined) ? msg.joined_id : msg.peer_id;
                    var joinedType = (joinedMessage === gwMessageActivityJoined) ? msg.joined_type : msg.peer_type;
                    var joinedName = (joinedMessage === gwMessageActivityJoined) ? msg.joined_name : msg.peer_name;
                    var entity = new ActivityWindow(joinedId, joinedName, joinedType, msg.activity_id, _this.getAgmInstance(joinedId), undefined, _this.generateWindowGetter(joinedId), undefined);
                    if (!_this._contextSubscriptions[msg.activity_id]) {
                        _this.subscribeToContext(msg).then(function () {
                            if (joinedMessage === gwMessageJoinedActivity) {
                                _this._activityJoinedPromiseResolve({});
                            }
                        });
                    }
                    else if (joinedMessage === gwMessageJoinedActivity) {
                        _this._activityJoinedPromiseResolve({});
                    }
                    _this.invokeCallbacks(_this._activityWindowChangeCallbacks, new EntityEvent(entity, new EntityEventContext(EntityEventType.ActivityWindowJoinedActivity)), joinedMessage);
                });
            };
            var this_1 = this;
            for (var _i = 0, _a = [gwMessageActivityJoined, gwMessageJoinedActivity]; _i < _a.length; _i++) {
                var joinedMessage = _a[_i];
                _loop_1(joinedMessage);
            }
            this.subscribe(gwMessageActivityLeft, function (msg) {
                var entity = new ActivityWindow(msg.left_id, undefined, undefined, null, _this.getAgmInstance(msg.left_id), undefined, _this.generateWindowGetter(msg.left_id), undefined);
                _this.invokeCallbacks(_this._activityWindowChangeCallbacks, new EntityEvent(entity, new EntityEventContext(EntityEventType.ActivityWindowLeftActivity)), gwMessageActivityLeft);
            });
            this.forwardAddedAndRemovedMessagesToEventHandler(gwMessagePeerCreated, undefined, function (msg) { return [
                new ActivityWindow(msg.created_id, undefined, undefined, undefined, undefined, undefined, _this.generateWindowGetter(msg.created_id), undefined)
            ]; }, this._activityWindowChangeCallbacks);
        };
        GW3Bridge.prototype.getAgmInstance = function (id) {
            return this._config.agm.servers().find(function (s) { return s.peerId === id || s.windowId === id; });
        };
        GW3Bridge.prototype.generateWindowGetter = function (peerId) {
            var _this = this;
            return function () {
                var server = _this.getAgmInstance(peerId);
                if (!server) {
                    return;
                }
                var windowId = server.windowId;
                return _this._config.windows.list().filter(function (w) { return w.id === windowId; })[0];
            };
        };
        GW3Bridge.prototype.isOverrideTypeDefinition = function (value) {
            if (typeof value === "undefined") {
                return false;
            }
            if (value.owner) {
                return true;
            }
            return false;
        };
        return GW3Bridge;
    }());

    var ActivityMy = (function () {
        function ActivityMy(manager, windows) {
            var _this = this;
            this._myAttached = [];
            this._myDetached = [];
            this._myAttachedTo = [];
            this._myDetachedFrom = [];
            this._myActivityFrameColorChanged = [];
            this._myActivityJoinedCallbacks = [];
            this._myActivityRemovedCallbacks = [];
            this._myContextUpdateCallbacks = [];
            this._logger = Logger$1.Get(this);
            this._m = manager;
            manager.ready()
                .then(function (am) {
                am.subscribeActivityContextChanged(_this._subscribeMyContextChanged.bind(_this));
                am.subscribeWindowEvents(_this._subscribeMyWindowEvent.bind(_this));
                am.subscribeActivitiesAttached(_this._subscribeActivitiesAttached.bind(_this));
                am.subscribeActivitiesDetached(_this._subscribeActivitiesDetached.bind(_this));
                if (windows) {
                    windows.onWindowFrameColorChanged(_this._subscribeWindowFrameColorChanged.bind(_this));
                }
            });
        }
        Object.defineProperty(ActivityMy.prototype, "window", {
            get: function () {
                if (isUndefinedOrNull(this._w)) {
                    var announcedWindows = this._m.announcedWindows;
                    if (announcedWindows.length > 0) {
                        this._w = announcedWindows[0];
                    }
                }
                return this._w;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityMy.prototype, "activity", {
            get: function () {
                var myWin = this.window;
                if (isUndefinedOrNull(myWin)) {
                    return undefined;
                }
                return myWin.activity;
            },
            enumerable: true,
            configurable: true
        });
        ActivityMy.prototype.createWindow = function (windowType) {
            return this._m.createWindow(this.activity, windowType);
        };
        ActivityMy.prototype.createStackedWindows = function (windowTypes, timeout) {
            return this._m.createStackedWindows(this.activity, windowTypes, timeout);
        };
        Object.defineProperty(ActivityMy.prototype, "context", {
            get: function () {
                var activity = this.activity;
                if (isUndefined(activity)) {
                    return {};
                }
                return activity.context;
            },
            enumerable: true,
            configurable: true
        });
        ActivityMy.prototype.updateContext = function (context, callback) {
            var activity = this.activity;
            if (isUndefined(activity)) {
                return new Promise(function (resolve, reject) {
                    reject("Not in activity");
                });
            }
            return activity.updateContext(context, callback);
        };
        ActivityMy.prototype.setContext = function (context, callback) {
            var activity = this.activity;
            if (isUndefined(activity)) {
                return new Promise(function (resolve, reject) {
                    reject("Not in activity");
                });
            }
            return activity.setContext(context, callback);
        };
        ActivityMy.prototype.onActivityJoined = function (callback) {
            this._myActivityJoinedCallbacks.push(callback);
            var myWin = this.window;
            if (!isUndefinedOrNull(myWin) && !isUndefinedOrNull(myWin.activity)) {
                callback(myWin.activity);
            }
        };
        ActivityMy.prototype.onActivityLeft = function (callback) {
            this._myActivityRemovedCallbacks.push(callback);
        };
        ActivityMy.prototype.onContextChanged = function (callback) {
            this._myContextUpdateCallbacks.push(callback);
            var myWin = this.window;
            if (isUndefinedOrNull(myWin)) {
                return;
            }
            var activity = myWin.activity;
            if (isUndefinedOrNull(activity)) {
                return;
            }
            callback(activity.context, activity.context, [], activity);
        };
        ActivityMy.prototype.clone = function (options, callback) {
            var act = this.activity;
            return this._m.clone(act, options, callback);
        };
        ActivityMy.prototype.attach = function (activity, tag) {
            var activityId;
            if (typeof activity === "string") {
                activityId = activity;
            }
            else {
                activityId = activity.id;
            }
            return this._m.attachActivities(activityId, this.activity.id, tag);
        };
        ActivityMy.prototype.onActivityAttached = function (callback) {
            this._myAttached.push(callback);
        };
        ActivityMy.prototype.onActivityDetached = function (callback) {
            this._myDetached.push(callback);
        };
        ActivityMy.prototype.onAttachedToActivity = function (callback) {
            this._myAttachedTo.push(callback);
        };
        ActivityMy.prototype.onDetachedFromActivity = function (callback) {
            this._myDetachedFrom.push(callback);
        };
        Object.defineProperty(ActivityMy.prototype, "attached", {
            get: function () {
                if (!this.activity) {
                    return [];
                }
                return this.activity.attached;
            },
            enumerable: true,
            configurable: true
        });
        ActivityMy.prototype.setFrameColor = function (color, callback) {
            if (this.activity) {
                return this.activity.setFrameColor(color, callback);
            }
            else {
                return Promise.resolve(null);
            }
        };
        ActivityMy.prototype.getFrameColor = function () {
            if (this.activity) {
                return this.activity.getFrameColor();
            }
            return "";
        };
        ActivityMy.prototype.onFrameColorChanged = function (callback) {
            this._myActivityFrameColorChanged.push(callback);
        };
        ActivityMy.prototype._subscribeMyContextChanged = function (activity, context, delta, removed) {
            var myWin = this.window;
            if (isUndefinedOrNull(myWin)) {
                return;
            }
            var myActivity = myWin.activity;
            if (isUndefinedOrNull(myActivity)) {
                return;
            }
            if (activity.id !== myActivity.id) {
                return;
            }
            this._notifyMyContextChanged(activity, context, delta, removed);
        };
        ActivityMy.prototype._subscribeMyWindowEvent = function (activity, window, event) {
            if (isUndefinedOrNull(this.window)) {
                return;
            }
            if (this.window.id !== window.id) {
                return;
            }
            if (event === EntityEventType.ActivityWindowJoinedActivity) {
                this._notifyMyWindowEvent(activity, this._myActivityJoinedCallbacks);
                this._notifyMyContextChanged(activity, activity.context, null, null);
            }
            else if (event === EntityEventType.ActivityWindowLeftActivity) {
                this._notifyMyWindowEvent(activity, this._myActivityRemovedCallbacks);
            }
        };
        ActivityMy.prototype._notifyMyWindowEvent = function (activity, callbackStore) {
            var _this = this;
            callbackStore.forEach(function (element) {
                try {
                    element(activity, event);
                }
                catch (e) {
                    _this._logger.warn("error in user callback " + e);
                }
            });
        };
        ActivityMy.prototype._notifyMyContextChanged = function (activity, context, delta, removed) {
            var _this = this;
            delta = delta || {};
            removed = removed || [];
            this._myContextUpdateCallbacks.forEach(function (element) {
                try {
                    element(context, delta, removed, activity);
                }
                catch (e) {
                    _this._logger.warn("error in user callback " + e);
                }
            });
        };
        ActivityMy.prototype._notifyAttached = function (state) {
            var _this = this;
            this._myAttached.forEach(function (cb) {
                try {
                    cb(state);
                }
                catch (e) {
                    _this._logger.warn("error in user callback " + e);
                }
            });
        };
        ActivityMy.prototype._notifyDetached = function (state) {
            var _this = this;
            this._myDetached.forEach(function (cb) {
                try {
                    cb(state);
                }
                catch (e) {
                    _this._logger.warn("error in user callback " + e);
                }
            });
        };
        ActivityMy.prototype._notifyAttachedTo = function (state) {
            var _this = this;
            this._myAttachedTo.forEach(function (cb) {
                try {
                    cb(_this.activity, state);
                }
                catch (e) {
                    _this._logger.warn("error in user callback " + e);
                }
            });
        };
        ActivityMy.prototype._notifyDetachedFrom = function (detached, existing, state) {
            var _this = this;
            this._myDetachedFrom.forEach(function (cb) {
                try {
                    cb(detached, existing, state);
                }
                catch (e) {
                    _this._logger.warn("error in user callback " + e);
                }
            });
        };
        ActivityMy.prototype._subscribeActivitiesAttached = function (newAct, state) {
            var myWin = this.window;
            if (isUndefinedOrNull(myWin)) {
                return;
            }
            var myActivity = myWin.activity;
            if (isUndefinedOrNull(myActivity)) {
                return;
            }
            if (newAct.id !== myActivity.id) {
                return;
            }
            if (state.windowIds.indexOf(myWin.id) >= 0) {
                this._notifyAttachedTo(state);
                return;
            }
            this._notifyAttached(state);
        };
        ActivityMy.prototype._subscribeActivitiesDetached = function (newAct, oldAct, state) {
            var myWin = this.window;
            if (isUndefinedOrNull(myWin)) {
                return;
            }
            var myActivity = myWin.activity;
            if (isUndefinedOrNull(myActivity)) {
                return;
            }
            if (oldAct.id === myActivity.id) {
                this._notifyDetached(state);
            }
            if (newAct.id === myActivity.id) {
                this._notifyDetachedFrom(newAct, oldAct, state);
            }
        };
        ActivityMy.prototype._subscribeWindowFrameColorChanged = function (window) {
            var act = this.activity;
            if (!act) {
                return;
            }
            if (!act.owner) {
                return;
            }
            if (act.owner.underlyingWindow.id === window.id) {
                this._myActivityFrameColorChanged.forEach(function (callback) {
                    callback(window.frameColor);
                });
            }
        };
        return ActivityMy;
    }());

    var ReadyMarker = (function () {
        function ReadyMarker(name, signalsToWait) {
            this._logger = Logger$1.Get("ReadyMarker [" + name + "]");
            this._logger.debug("Initializing ready marker for '" + name + "' with " + signalsToWait + " signals to wait");
            if (signalsToWait <= 0) {
                throw new Error("Invalid signal number. Should be > 0");
            }
            this._signals = signalsToWait;
            this._callbacks = [];
            this._name = name;
        }
        ReadyMarker.prototype.setCallback = function (callback) {
            if (this.isSet()) {
                callback(undefined);
                return;
            }
            else if (this.isError()) {
                callback(this._error);
                return;
            }
            this._callbacks.push(callback);
        };
        ReadyMarker.prototype.signal = function (message) {
            this._logger.debug("Signaled - " + message + " - signals left " + (this._signals - 1));
            this._signals--;
            if (this._signals < 0) {
                throw new Error("Error in ready marker '" + this._name + " - signals are " + this._signals);
            }
            if (this.isSet()) {
                this._callbacks.forEach(function (callback) {
                    callback(undefined);
                });
            }
        };
        ReadyMarker.prototype.error = function (error) {
            this._error = error;
            this._callbacks.forEach(function (errorCallback) {
                errorCallback(error);
            });
        };
        ReadyMarker.prototype.isSet = function () {
            if (this.isError()) {
                return false;
            }
            return this._signals === 0;
        };
        ReadyMarker.prototype.isError = function () {
            return !isUndefined(this._error);
        };
        ReadyMarker.prototype.getError = function () {
            return this._error;
        };
        return ReadyMarker;
    }());

    var EntityObservableCollection = (function () {
        function EntityObservableCollection(processNew) {
            this._items = {};
            this._listeners = [];
            this._processNew = processNew;
        }
        EntityObservableCollection.prototype.addOne = function (item) {
            this.add([item]);
        };
        EntityObservableCollection.prototype.add = function (items) {
            var _this = this;
            items.forEach(function (element) {
                _this.process(new EntityEvent(element, new EntityEventContext(EntityEventType.Added)));
            });
        };
        EntityObservableCollection.prototype.process = function (event) {
            var context = event.context;
            var type = context.type;
            var entity = event.entity;
            if (type === EntityEventType.StatusChange &&
                !context.oldStatus) {
                var act = this._items[entity.id];
                if (act) {
                    context.oldStatus = act.status;
                }
            }
            if (type === EntityEventType.StatusChange &&
                context.oldStatus &&
                context.newStatus &&
                context.oldStatus.state ===
                    context.newStatus.state) {
                context.type = EntityEventType.Updated;
            }
            if (typeof htmlContainer === "undefined") {
                if (type === EntityEventType.ActivityWindowJoinedActivity &&
                    this._items[entity.id] &&
                    this._items[entity.id].activity) {
                    context.type = EntityEventType.Updated;
                }
                if (type === EntityEventType.ActivityWindowLeftActivity &&
                    this._items[entity.id] &&
                    !this._items[entity.id].activity) {
                    context.type = EntityEventType.Updated;
                }
            }
            var internalEntity = this._updateInternalCollections(entity, type, context);
            this._notifyListeners(internalEntity, context);
            return internalEntity;
        };
        EntityObservableCollection.prototype.get = function () {
            var result = [];
            for (var key in this._items) {
                if (this._items.hasOwnProperty(key)) {
                    var element = this._items[key];
                    result.push(element);
                }
            }
            return result;
        };
        EntityObservableCollection.prototype.getByName = function (name) {
            for (var key in this._items) {
                if (key === name) {
                    return this._items[key];
                }
            }
            return undefined;
        };
        EntityObservableCollection.prototype.getOrWait = function (name) {
            var _this = this;
            return new Promise(function (resolve) {
                var entityAddedHandler = function (entity) {
                    if (entity.id !== name) {
                        return;
                    }
                    resolve(entity);
                    _this.unsubscribe(entityAddedHandler);
                };
                _this.subscribe(entityAddedHandler);
                var window = _this.getByName(name);
                if (window) {
                    _this.unsubscribe(entityAddedHandler);
                    resolve(window);
                    return;
                }
            });
        };
        EntityObservableCollection.prototype.subscribe = function (handler) {
            var _this = this;
            this._listeners.push(handler);
            Object.keys(this._items).forEach(function (key) {
                var element = _this._items[key];
                handler(element, new EntityEventContext(EntityEventType.Added.toString()));
            });
            return function () {
                _this.unsubscribe(handler);
            };
        };
        EntityObservableCollection.prototype.unsubscribe = function (handler) {
            var index = this._listeners.indexOf(handler);
            if (index !== -1) {
                this._listeners.splice(index, 1);
            }
        };
        EntityObservableCollection.prototype._notifyListeners = function (entity, context) {
            this._listeners.forEach(function (listener) {
                try {
                    listener(entity, context);
                }
                catch (e) {
                    return;
                }
            });
        };
        EntityObservableCollection.prototype._updateInternalCollections = function (entity, type, context) {
            var entityAsAny = entity;
            var isActivityDestroy = (type === EntityEventType.StatusChange &&
                entityAsAny.status &&
                entityAsAny.status.state === ActivityState.Destroyed) ||
                (type === EntityEventType.StatusChange &&
                    context &&
                    context.newStatus &&
                    context.newStatus.state === ActivityState.Destroyed);
            var isWindowClose = type === EntityEventType.Closed;
            var isTypeRemove = type === EntityEventType.Removed && typeof entityAsAny.isIndependent === "undefined";
            if (isTypeRemove || isWindowClose || isActivityDestroy) {
                var oldEntity = this._items[entity.id];
                delete this._items[entity.id];
                this._processNew(entity);
                if (oldEntity) {
                    entity._beforeDelete(oldEntity);
                }
                return entity;
            }
            else {
                var key = entity.id;
                if (!this._items.hasOwnProperty(key)) {
                    this._processNew(entity);
                    this._items[entity.id] = entity;
                }
                else {
                    this._items[entity.id]._update(entity);
                }
            }
            return this._items[entity.id];
        };
        return EntityObservableCollection;
    }());

    var ActivityManager = (function () {
        function ActivityManager(bridge, autoAnnounce, windows) {
            var _this = this;
            this._logger = Logger$1.Get("activityManager");
            this._announcedWindows = [];
            this._attachedCallbacks = [];
            this._detachedCallbacks = [];
            this._frameColorChangesCallbacks = [];
            this._windowHandlers = [];
            this._bridge = bridge;
            this._activityTypes = new EntityObservableCollection(function (e) { return _this._grabEntity(e); });
            this._windowTypes = new EntityObservableCollection(function (e) { return _this._grabEntity(e); });
            this._activities = new EntityObservableCollection(function (e) { return _this._grabEntity(e); });
            this._windows = new EntityObservableCollection(function (e) { return _this._grabEntity(e); });
            this._dataReadyMarker = new ReadyMarker("Activity Manager Data", ["GetActivityTypes", "GetWindowTypes", "GetActivities", "GetWindows"].length);
            this._descriptorsMarker = new ReadyMarker("Attached Activities Descriptors", ["GetDescriptors"].length);
            if (autoAnnounce) {
                this._readyMarker = new ReadyMarker("Activity Manager Announce", ["Announcement"].length);
                this._dataReadyMarker.setCallback(function (dataErr) {
                    if (dataErr) {
                        _this._readyMarker.error(dataErr);
                    }
                    _this._descriptorsMarker.setCallback(function (err) {
                        if (err) {
                            _this._readyMarker.error(err);
                        }
                        _this._logger.debug("Auto announcing window");
                        _this.announceWindow()
                            .then(function (w) {
                            _this._announcedWindows.push(w);
                            _this._readyMarker.signal("Successfully announced window with id '" + w.id + "'");
                        })
                            .catch(function (errCatch) {
                            _this._logger.debug("Will not announce window - " + errCatch);
                            _this._readyMarker.signal();
                        });
                    });
                    _this.refreshDescriptors();
                });
            }
            else {
                this._readyMarker = this._dataReadyMarker;
            }
            this._bridge.onActivitiesAttached(function (e) {
                _this._handleActivitiesAttached(e);
            });
            this._bridge.onActivitiesDetached(function (e) {
                _this._handleActivitiesDetached(e);
            });
            this._bridge.onActivityAttachedDescriptorsRefreshed(function (e) {
                _this._handleActivityDescriptorsRefreshed(e);
            });
            if (windows) {
                windows.onWindowFrameColorChanged(this._handleWindowFrameColorChanged.bind(this));
            }
            this._bridge.init();
            this._subscribeForData();
            this._bridge
                .initReady()
                .then(function (aw) {
                _this._getInitialData();
            })
                .catch(function (error) {
                console.log(error);
            });
        }
        Object.defineProperty(ActivityManager.prototype, "usingHc", {
            get: function () {
                return this._bridge.bridgeType === "HC";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityManager.prototype, "announcedWindows", {
            get: function () {
                return this._announcedWindows;
            },
            set: function (v) {
                throw new Error("not allowed");
            },
            enumerable: true,
            configurable: true
        });
        ActivityManager.prototype.ready = function (callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                _this._readyMarker.setCallback(function (err) {
                    if (!err) {
                        resolve(_this);
                    }
                    else {
                        reject(_this._readyMarker.getError());
                    }
                });
            });
            return nodeify(Promise.all([this._bridge.ready(), promise]).then(function () { return _this; }), callback);
        };
        ActivityManager.prototype.getActivityTypes = function () {
            return this._activityTypes.get();
        };
        ActivityManager.prototype.getActivityType = function (name) {
            return this._activityTypes.getByName(name);
        };
        ActivityManager.prototype.registerActivityType = function (activityTypeName, ownerWindowType, helperWindowTypes, config, description, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                if (isUndefinedOrNull(activityTypeName)) {
                    reject("activityTypeName argument can not be undefined");
                    return;
                }
                if (!isString(activityTypeName)) {
                    reject("activityTypeName should be string");
                    return;
                }
                var actType = _this.getActivityType(activityTypeName);
                if (!isUndefinedOrNull(actType)) {
                    reject("Activity type '" + activityTypeName + "' already exists");
                    return;
                }
                var ownerDefinition;
                if (isUndefined(ownerWindowType)) {
                    reject("Owner window type can not be undefined");
                    return;
                }
                if (isString(ownerWindowType)) {
                    ownerDefinition = { type: ownerWindowType, name: "", isIndependent: false, arguments: {} };
                }
                else {
                    ownerDefinition = ownerWindowType;
                }
                var helperDefinitions = [];
                if (!isUndefined(helperWindowTypes) && isArray(helperWindowTypes)) {
                    for (var index in helperWindowTypes) {
                        var item = helperWindowTypes[index];
                        if (isString(item)) {
                            var definition = {
                                type: item,
                                name: "",
                                isIndependent: false,
                                arguments: {},
                                relativeTo: "",
                                relativeDirection: "",
                                windowStyleAttributes: {}
                            };
                            helperDefinitions.push(definition);
                        }
                        else {
                            helperDefinitions.push(item);
                        }
                    }
                }
                _this._bridge
                    .registerActivityType(activityTypeName, ownerDefinition, helperDefinitions, config, description)
                    .then(function (activityType) {
                    _this._grabEntity(activityType);
                    resolve(activityType);
                })
                    .catch(function (error) {
                    reject(error);
                });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.unregisterActivityType = function (type, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                var actType = _this.getActivityType(type);
                if (isUndefined(actType)) {
                    reject("Activity type '" + type + "' does not exists");
                    return;
                }
                _this._bridge.unregisterActivityType(type).then(function () { return resolve(actType); }, reject);
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.initiate = function (activityType, context, callback, configuration) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                var actType = _this.getActivityType(activityType);
                if (isUndefined(actType)) {
                    reject("Activity type '" + activityType + "' does not exists");
                    return;
                }
                _this._bridge
                    .initiateActivity(activityType, context, configuration)
                    .then(function (actId) {
                    _this._activities
                        .getOrWait(actId)
                        .then(function (act) {
                        resolve(act);
                    })
                        .catch(function (err) { return reject(err); });
                })
                    .catch(function (err) {
                    reject(err);
                });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.subscribeActivityTypeEvents = function (handler) {
            this._activityTypes.subscribe(function (at, context) {
                handler(at, context.type);
            });
        };
        ActivityManager.prototype.getWindowTypes = function () {
            return this._windowTypes.get();
        };
        ActivityManager.prototype.getWindowType = function (name) {
            return this._windowTypes.getByName(name);
        };
        ActivityManager.prototype.registerWindowFactory = function (windowType, factoryMethod, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                if (isUndefinedOrNull(windowType)) {
                    reject("no windowType specified");
                    return;
                }
                if (isObject(windowType)) {
                    windowType = windowType.getName();
                }
                else if (!isString(windowType)) {
                    reject("windowType should be string or object that has getName method");
                    return;
                }
                _this._bridge
                    .registerWindowFactory(windowType, factoryMethod)
                    .then(function (v) {
                    resolve(v);
                })
                    .catch(function (err) {
                    reject(err);
                });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.unregisterWindowFactory = function (windowType, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                if (isUndefinedOrNull(windowType)) {
                    reject("no windowType specified");
                    return;
                }
                if (!isString(windowType)) {
                    reject("windowType should be a string");
                    return;
                }
                _this._bridge
                    .unregisterWindowFactory(windowType)
                    .then(function (v) {
                    resolve(v);
                })
                    .catch(function (err) {
                    reject(err);
                });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.getActivities = function (activityType) {
            var act = this._activities.get();
            act = act.filter(function (a) { return a._ownerId; });
            if (!activityType) {
                return act;
            }
            var types = activityType;
            if (isString(activityType)) {
                types = [activityType];
            }
            else if (activityType instanceof ActivityType) {
                types = [activityType.name];
            }
            else if (activityType instanceof Array) ;
            else {
                throw new Error("Invalid input argument 'activityType' = " + activityType);
            }
            return act.filter(function (at) {
                var type = at.type;
                return some(types, function (t) {
                    return type.id === t.id;
                });
            });
        };
        ActivityManager.prototype.getActivityById = function (id) {
            return this._activities.getByName(id);
        };
        ActivityManager.prototype.announceWindow = function (activityWindowId, windowType) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                var announcementInfo = _this._bridge.getAnnouncementInfo();
                if (isUndefined(activityWindowId)) {
                    activityWindowId = announcementInfo.activityWindowId;
                }
                if (isUndefined(windowType)) {
                    windowType = announcementInfo.activityWindowType;
                }
                if (isUndefinedOrNull(windowType)) {
                    throw new Error("Can not announce - unknown windowType");
                }
                var activityId = announcementInfo && announcementInfo.activityId;
                if (isUndefinedOrNull(activityWindowId)) {
                    _this._logger.debug("Registering window with type:'" + windowType + "', name:'" + announcementInfo.activityWindowName + "', ind.:'" + announcementInfo.activityWindowIndependent + "'");
                    _this._bridge.registerWindow(windowType, announcementInfo.activityWindowName, announcementInfo.activityWindowIndependent)
                        .then(_this._windows.getOrWait.bind(_this._windows))
                        .then(function (w) {
                        if (activityId) {
                            return _this._activities.getOrWait(activityId).then(function (_) { return w; });
                        }
                        else {
                            return w;
                        }
                    })
                        .then(function (w) {
                        resolve(w);
                    })
                        .catch(function (err) {
                        _this._logger.error(err);
                    });
                }
                else {
                    _this._logger.debug("Announcing window with id '" + activityWindowId + "' and type '" + windowType + "'");
                    var currentWindow = _this._windows.getByName(activityWindowId);
                    if (!isUndefinedOrNull(currentWindow)) {
                        _this._logger.debug("Window with id '" + activityWindowId + "' already announced - reusing the window");
                        resolve(currentWindow);
                        return;
                    }
                    var windowEventHandler_1 = function (a, w, e) {
                        if (activityWindowId === w.id) {
                            if (e === EntityEventType.ActivityWindowJoinedActivity) {
                                var activity = w.activity;
                                if (isUndefined(activity)) {
                                    reject("UNDEFINED ACTIVITY");
                                }
                                _this._logger.trace("Got joined event for id '" + activityWindowId + "'");
                                resolve(w);
                                _this.unsubscribeWindowEvents(windowEventHandler_1);
                            }
                        }
                    };
                    _this.subscribeWindowEvents(windowEventHandler_1);
                    _this._logger.trace("Waiting for joined event for id '" + activityWindowId + "'");
                    _this._bridge.announceWindow(windowType, activityWindowId);
                }
            });
            return promise;
        };
        ActivityManager.prototype.subscribeWindowTypeEvents = function (handler) {
            this._windowTypes.subscribe(function (wt, context) {
                handler(wt, context.type);
            });
        };
        ActivityManager.prototype.subscribeActivityEvents = function (handler) {
            var _this = this;
            return this._activities.subscribe(function (act, context) {
                if (context.type === EntityEventType.StatusChange) {
                    var p = context;
                    handler(act, p.newStatus, p.oldStatus);
                }
                if (context.type === EntityEventType.Removed ||
                    (context.type === EntityEventType.StatusChange &&
                        context.newStatus.getState() === ActivityState.Destroyed)) {
                    for (var _i = 0, _a = _this._windows.get(); _i < _a.length; _i++) {
                        var window_1 = _a[_i];
                        if (window_1.activity && window_1.activity.id === act.id) {
                            _this._windows.process(new EntityEvent(window_1, new EntityEventContext(EntityEventType.ActivityWindowLeftActivity)));
                        }
                    }
                }
            });
        };
        ActivityManager.prototype.subscribeWindowEvents = function (handler) {
            var wrappingHandler = function (window, context) {
                var eventType = context.type;
                if (eventType === EntityEventType.Added) {
                    eventType = "opened";
                }
                handler(window.activity, window, eventType);
            };
            this._windowHandlers.push([handler, wrappingHandler]);
            return this._windows.subscribe(wrappingHandler);
        };
        ActivityManager.prototype.unsubscribeWindowEvents = function (handler) {
            var found = this._windowHandlers.find(function (pair) { return pair[0] === handler; });
            if (found) {
                this._windowHandlers.splice(this._windowHandlers.indexOf(found), 1);
                this._windows.unsubscribe(found[1]);
            }
        };
        ActivityManager.prototype.createWindow = function (activity, windowTypeOrConfiguration, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                if (isUndefinedOrNull(windowTypeOrConfiguration)) {
                    reject("windowType is undefined");
                }
                var windowDefinition;
                if (isString(windowTypeOrConfiguration)) {
                    windowDefinition = { type: windowTypeOrConfiguration, name: "", isIndependent: false, arguments: {} };
                }
                else if (windowTypeOrConfiguration instanceof WindowType) {
                    windowDefinition = {
                        type: windowTypeOrConfiguration.type || windowTypeOrConfiguration.id,
                        name: windowTypeOrConfiguration.name || windowTypeOrConfiguration.type || windowTypeOrConfiguration.id,
                        isIndependent: false
                    };
                }
                else {
                    var invalidKeys_1 = ["url"];
                    var filteredWindowTypeOrConfiguration_1 = {};
                    Object.keys(windowTypeOrConfiguration).forEach(function (key) {
                        if (invalidKeys_1.indexOf(key) === -1) {
                            filteredWindowTypeOrConfiguration_1[key] = windowTypeOrConfiguration[key];
                        }
                    });
                    windowDefinition = filteredWindowTypeOrConfiguration_1;
                }
                var relativeToWindow;
                if (!isUndefinedOrNull(windowDefinition.relativeTo)) {
                    relativeToWindow = windowDefinition.relativeTo;
                    if (typeof relativeToWindow === "string") {
                        var windows = _this.getWindows({ type: relativeToWindow });
                        if (!isUndefinedOrNull(windows) && windows.length > 0) {
                            windowDefinition.relativeTo = windows[0].id;
                        }
                    }
                    else if (!isUndefinedOrNull(relativeToWindow.type)) {
                        var windows = _this.getWindows({ type: relativeToWindow.type });
                        if (!isUndefinedOrNull(windows) && windows.length > 0) {
                            windowDefinition.relativeTo = windows[0].id;
                        }
                    }
                    else if (!isUndefinedOrNull(relativeToWindow.windowId)) {
                        windowDefinition.relativeTo = relativeToWindow.windowId;
                    }
                }
                _this._bridge.createWindow(activity && activity.id, windowDefinition)
                    .then(function (wid) {
                    _this._logger.debug("Window created, waiting for window entity with id " + wid);
                    var handler = function (window, context) {
                        if (window.id === wid && (!activity || window.activity)) {
                            _this._logger.debug("Got entity window with id " + wid);
                            resolve(window);
                            _this._windows.unsubscribe(handler);
                        }
                    };
                    _this._windows.subscribe(handler);
                })
                    .catch(function (err) {
                    reject(err);
                });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.createStackedWindows = function (activity, relativeWindowTypes, timeout, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                if (isUndefinedOrNull(activity)) {
                    reject("activity is undefined");
                }
                if (isUndefinedOrNull(relativeWindowTypes)) {
                    reject("relativeWindowTypes is undefined");
                }
                if (!Array.isArray(relativeWindowTypes)) {
                    reject("relativeWindowTypes has to be an array");
                }
                if (isUndefinedOrNull(timeout)) {
                    timeout = 20000;
                }
                var windowDefinitions = [];
                relativeWindowTypes.forEach(function (element) {
                    var windowDefinition;
                    if (isString(element)) {
                        windowDefinition = { type: element, name: "", isIndependent: false, arguments: {} };
                    }
                    else {
                        windowDefinition = element;
                    }
                    windowDefinition.stackedWindow = true;
                    windowDefinition.timeout = timeout;
                    var relativeToWindow;
                    if (!isUndefinedOrNull(windowDefinition.relativeTo)) {
                        relativeToWindow = windowDefinition.relativeTo;
                        if (!isUndefinedOrNull(relativeToWindow.type)) {
                            windowDefinition.relativeTo = relativeToWindow.type;
                        }
                        else if (!isUndefinedOrNull(relativeToWindow.windowId)) {
                            var windows = _this.getWindows({ id: relativeToWindow.windowId });
                            if (!isUndefinedOrNull(windows) && windows.length > 0) {
                                windowDefinition.relativeTo = windows[0].type.name;
                            }
                        }
                    }
                    windowDefinitions.push(windowDefinition);
                });
                var tasks = [];
                windowDefinitions.forEach(function (wd) { return tasks.push(_this.createWindow(activity, wd)); });
                Promise.all(tasks).then(resolve).catch(reject);
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.addWindowToActivity = function (activity, window, callback) {
            var toReturn = this._bridge.joinActivity(activity.id, window.id)
                .then(function () { return window; });
            nodeify(toReturn, callback);
            return toReturn;
        };
        ActivityManager.prototype.leaveWindowFromActivity = function (activity, window, callback) {
            var toReturn = this._bridge.leaveActivity(activity.id, window.id)
                .then(function () { return window; });
            nodeify(toReturn, callback);
            return toReturn;
        };
        ActivityManager.prototype.setActivityContext = function (activity, context, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                if (isUndefinedOrNull(activity)) {
                    reject("activity can not be null");
                }
                _this._bridge
                    .updateActivityContext(activity, context, true)
                    .then(function (_) {
                    resolve(activity);
                })
                    .catch(function (err) {
                    reject(err);
                });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.updateActivityContext = function (activity, context, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                if (isUndefinedOrNull(activity)) {
                    reject("activity can not be null");
                }
                var removedKeys = [];
                for (var key in context) {
                    if (context.hasOwnProperty(key) && context[key] === null) {
                        removedKeys.push(key);
                    }
                }
                for (var _i = 0, removedKeys_1 = removedKeys; _i < removedKeys_1.length; _i++) {
                    var removedKey = removedKeys_1[_i];
                    delete context[removedKey];
                }
                _this._bridge
                    .updateActivityContext(activity, context, false, removedKeys)
                    .then(function (_) {
                    resolve(activity);
                })
                    .catch(function (err) {
                    reject(err);
                });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.subscribeActivityContextChanged = function (handler) {
            this._activities.subscribe(function (act, context) {
                if (context.type === EntityEventType.ActivityContextChange) {
                    var updateContext = context;
                    handler(act, updateContext.context, updateContext.updated, updateContext.removed);
                }
            });
        };
        ActivityManager.prototype.stopActivity = function (activity, callback) {
            var promise = this._bridge.stopActivity(activity);
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.getWindows = function (filter) {
            if (isUndefined(filter)) {
                return this._windows.get();
            }
            if (!isUndefined(filter.id)) {
                return [this._windows.getByName(filter.id)];
            }
            var allWindows = this._windows.get();
            return allWindows.filter(function (w) {
                if (!isUndefined(filter.type) && w.type.id !== filter.type) {
                    return false;
                }
                if (!isUndefined(filter.name) && w.name !== filter.name) {
                    return false;
                }
                if (!isUndefined(filter.activityId)) {
                    if (isUndefinedOrNull(w.activity)) {
                        return false;
                    }
                    if (w.activity.id !== filter.activityId) {
                        return false;
                    }
                }
                return true;
            });
        };
        ActivityManager.prototype.getWindowBounds = function (id) {
            return this._bridge.getWindowBounds(id);
        };
        ActivityManager.prototype.setWindowBounds = function (id, bounds, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                _this._bridge.setWindowBounds(id, bounds)
                    .then(function () { return resolve(); })
                    .catch(function (err) { return reject(err); });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.closeWindow = function (id) {
            return this._bridge.closeWindow(id);
        };
        ActivityManager.prototype.activateWindow = function (id, focus) {
            return this._bridge.activateWindow(id, focus);
        };
        ActivityManager.prototype.setWindowVisibility = function (id, visible) {
            return this._bridge.setWindowVisibility(id, visible);
        };
        ActivityManager.prototype.clone = function (activity, cloneOptions, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                if (!activity) {
                    reject("activity can not be null");
                }
                _this._bridge.cloneActivity(activity.id, cloneOptions)
                    .then(function (activityId) {
                    _this._activities
                        .getOrWait(activityId)
                        .then(function (act) {
                        resolve(act);
                    })
                        .catch(function (err) { return reject(err); });
                })
                    .catch(function (err) { return reject(err); });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.attachActivities = function (from, to, tag, callback) {
            var _this = this;
            tag = tag || {};
            var promise = new Promise(function (resolve, reject) {
                var fromActivity = _this._activities.getByName(from);
                if (!fromActivity) {
                    reject("can not find activity with id " + from);
                    return;
                }
                var toActivity = _this._activities.getByName(to);
                if (!toActivity) {
                    reject("can not find activity with id " + to);
                    return;
                }
                return _this._bridge.attachActivities(from, to, tag)
                    .then(function (data) {
                    var newActId = data.to;
                    var state = data.descriptor;
                    var allStates = data.descriptors;
                    _this._activities.getOrWait(newActId).then(function (act) {
                        act._updateDescriptors(allStates);
                        var stateWrapped = act.attached.filter(function (u) { return u.ownerId === state.ownerId; })[0];
                        resolve(stateWrapped);
                    });
                })
                    .catch(function (err) {
                    reject(err);
                });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.detachActivities = function (activityId, descriptor, callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                return _this._bridge.detachActivities(activityId, descriptor)
                    .then(function () {
                    var oldActId = undefined;
                    var newActId = undefined;
                    var descriptors = undefined;
                    _this._activities
                        .getOrWait(oldActId)
                        .then(function (oldAct) {
                        oldAct._updateDescriptors(descriptors);
                        _this._activities
                            .getOrWait(newActId)
                            .then(function (newAct) {
                            resolve(newAct);
                        });
                    })
                        .catch(function (err) { return reject(err); });
                })
                    .catch(function (err) {
                    reject(err);
                });
            });
            return nodeify(promise, callback);
        };
        ActivityManager.prototype.subscribeActivitiesAttached = function (callback) {
            this._attachedCallbacks.push(callback);
        };
        ActivityManager.prototype.subscribeActivitiesDetached = function (callback) {
            this._detachedCallbacks.push(callback);
        };
        ActivityManager.prototype.subscribeActivityFrameColorChanged = function (callback) {
            this._frameColorChangesCallbacks.push(callback);
        };
        ActivityManager.prototype._grabEntity = function (entity) {
            entity._manager = this;
        };
        ActivityManager.prototype._getInitialData = function () {
            var _this = this;
            this._logger.debug("Request initial data...");
            this._bridge.getActivityTypes()
                .then(function (at) {
                _this._activityTypes.add(at);
                _this._dataReadyMarker.signal("Got act types");
            })
                .catch(function (error) {
                _this._logger.error(error);
                _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity types -" + error);
            });
            this._bridge.getWindowTypes()
                .then(function (wt) {
                _this._windowTypes.add(wt);
                _this._dataReadyMarker.signal("Got window types");
            })
                .catch(function (error) {
                _this._logger.error(error);
                _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting window types  " + error);
            });
            this._bridge.getActivities()
                .then(function (ac) {
                _this._activities.add(ac);
                _this._dataReadyMarker.signal("Got activities");
            })
                .catch(function (error) {
                _this._logger.error(error);
                _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity instances -" + error);
            });
            this._bridge.getActivityWindows()
                .then(function (aw) {
                _this._windows.add(aw);
                _this._dataReadyMarker.signal("Got windows");
            })
                .catch(function (error) {
                _this._logger.error(error);
                _this._dataReadyMarker.error("Can not initialize ActivityManager - error getting activity windows -" + error);
            });
        };
        ActivityManager.prototype._subscribeForData = function () {
            var _this = this;
            this._logger.debug("Subscribe for data...");
            this._bridge.onActivityTypeStatusChange(function (event) {
                _this._activityTypes.process(event);
            });
            this._bridge.onWindowTypeStatusChange(function (event) {
                _this._windowTypes.process(event);
            });
            this._bridge.onActivityWindowChange(function (event) {
                _this._windows.process(event);
            });
            this._bridge.onActivityStatusChange(function (event) {
                _this._activities.process(event);
            });
        };
        ActivityManager.prototype._handleActivitiesAttached = function (data) {
            var _this = this;
            var newActId = data.to;
            var descriptor = data.descriptor;
            var descriptors = data.descriptors;
            this._activities.getOrWait(newActId).then(function (act) {
                act._updateDescriptors(descriptors);
                var descriptorAsObjectFromAPI = act.attached.filter(function (u) { return u.ownerId === descriptor.ownerId; })[0];
                _this._attachedCallbacks.forEach(function (callback) {
                    try {
                        callback(act, descriptorAsObjectFromAPI);
                    }
                    catch (err) {
                        return;
                    }
                });
            });
        };
        ActivityManager.prototype._handleActivitiesDetached = function (data) {
            var _this = this;
            var oldActId = data.oldActivityId;
            var newActId = data.newActivityId;
            var descriptors = data.descriptors;
            var descriptor = data.descriptor;
            this._activities.getOrWait(oldActId).then(function (oldAct) {
                oldAct._updateDescriptors(descriptors);
                _this._activities.getOrWait(newActId).then(function (newAct) {
                    _this._detachedCallbacks.forEach(function (callback) {
                        try {
                            callback(newAct, oldAct, descriptor);
                        }
                        catch (err) {
                            return;
                        }
                    });
                });
            });
        };
        ActivityManager.prototype._handleActivityDescriptorsRefreshed = function (data) {
            var id = data.id;
            var descriptors = data.descriptors;
            var act = this._activities.getByName(id);
            if (act) {
                act._updateDescriptors(descriptors);
            }
        };
        ActivityManager.prototype.refreshDescriptors = function () {
            var _this = this;
            this._bridge.getAttachedDescriptors()
                .then(function (map) {
                if (map) {
                    Object.keys(map).forEach(function (key) {
                        var actId = key;
                        var descriptors = map[key];
                        var act = _this._activities.getByName(actId);
                        if (act) {
                            act._updateDescriptors(descriptors);
                        }
                    });
                }
                _this._descriptorsMarker.signal("Successfully got descriptors");
            })
                .catch(function (err) {
                _this._descriptorsMarker.error("failed to get descriptors - " + err);
            });
        };
        ActivityManager.prototype._handleWindowFrameColorChanged = function (win) {
            if (!win.activityId) {
                return;
            }
            var act = this._activities.getByName(win.activityId);
            if (!act) {
                return;
            }
            if (!act.owner) {
                return;
            }
            if (act.owner.underlyingWindow.id !== win.id) {
                return;
            }
            this._frameColorChangesCallbacks.forEach(function (callback) {
                try {
                    callback(act, win.frameColor);
                }
                catch (e) {
                    return;
                }
            });
        };
        return ActivityManager;
    }());

    var ActivityManagementAPI = (function () {
        function ActivityManagementAPI(manager, my) {
            this._m = manager;
            this._my = my;
            this.activityTypes = {
                get: this._getActivityTypesWrapper.bind(this),
                register: this._m.registerActivityType.bind(this._m),
                unregister: this._m.unregisterActivityType.bind(this._m),
                subscribe: this._m.subscribeActivityTypeEvents.bind(this._m),
                unsubscribe: undefined,
                initiate: this._m.initiate.bind(this._m)
            };
            this.windowTypes = {
                get: this._getWindowTypesWrapper.bind(this),
                registerFactory: this._m.registerWindowFactory.bind(this._m),
                unregisterFactory: this._m.unregisterWindowFactory.bind(this._m),
                subscribe: this._m.subscribeWindowTypeEvents.bind(this._m),
                unsubscribe: undefined
            };
            this.windows = {
                get: this._m.getWindows.bind(this._m),
                subscribe: this._m.subscribeWindowEvents.bind(this._m),
                announce: this._m.announceWindow.bind(this._m),
                unsubscribe: undefined,
                create: this._m.createWindow.bind(this._m)
            };
            this.instances = {
                get: this._m.getActivities.bind(this._m),
                subscribe: this._m.subscribeActivityEvents.bind(this._m),
                unsubscribe: undefined
            };
        }
        ActivityManagementAPI.prototype.onAttached = function (callback) {
            this._m.subscribeActivitiesAttached(callback);
        };
        ActivityManagementAPI.prototype.onDetached = function (callback) {
            this._m.subscribeActivitiesDetached(callback);
        };
        ActivityManagementAPI.prototype.onActivityFrameColorChanged = function (callback) {
            this._m.subscribeActivityFrameColorChanged(callback);
        };
        ActivityManagementAPI.prototype._getActivityTypesWrapper = function (name) {
            if (isUndefined(name)) {
                return this._m.getActivityTypes();
            }
            return this._m.getActivityType(name);
        };
        ActivityManagementAPI.prototype._getWindowTypesWrapper = function (name) {
            if (isUndefined(name)) {
                return this._m.getWindowTypes();
            }
            return this._m.getWindowType(name);
        };
        return ActivityManagementAPI;
    }());

    var ActivityAPI = (function () {
        function ActivityAPI(manager, my) {
            this._mgr = manager;
            this._my = my;
            this.all = new ActivityManagementAPI(manager, my);
        }
        ActivityAPI.prototype.ready = function (callback) {
            var _this = this;
            var promise = new Promise(function (resolve, reject) {
                _this._mgr.ready()
                    .then(function () {
                    resolve(_this);
                })
                    .catch(function (err) {
                    reject(err);
                });
            });
            return nodeify(promise, callback);
        };
        Object.defineProperty(ActivityAPI.prototype, "my", {
            get: function () {
                return this._my;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityAPI.prototype, "aware", {
            get: function () {
                return this._my.window !== undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityAPI.prototype, "inActivity", {
            get: function () {
                return this.aware && this._my.activity !== undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityAPI.prototype, "agm", {
            get: function () {
                if (!this.aware) {
                    return undefined;
                }
                if (!this.inActivity) {
                    return new ActivityAGM(null);
                }
                return this._my.activity.agm;
            },
            enumerable: true,
            configurable: true
        });
        ActivityAPI.prototype.getAvailableFrameColors = function () {
            return [];
        };
        return ActivityAPI;
    }());

    var ActivityModule = (function () {
        function ActivityModule(config) {
            var _this = this;
            if (!config) {
                throw new Error("config can not be null");
            }
            if (!isUndefined(config.logLevel)) {
                Logger$1.Level = config.logLevel;
            }
            if (!isUndefinedOrNull(config.logger)) {
                Logger$1.GlueLogger = config.logger;
            }
            var bridge;
            this._isUsingHCImplementation = config.gdMajorVersion === 2;
            this._isUsingGW3Implementation = ActivityModule.checkIsUsingGW3Implementation(config.connection);
            if (this._isUsingHCImplementation) {
                throw new Error("GD2 not supported");
            }
            else if (this._isUsingGW3Implementation) {
                bridge = new GW3Bridge$1(config);
            }
            else {
                throw new Error("Unable to instantiate activity bridge implementation");
            }
            if (!bridge) {
                throw new Error("A bridge to native activity is needed to create activity lib.");
            }
            ActivityAGM.AGM = config.agm;
            var activityManager = new ActivityManager(bridge, !config.disableAutoAnnounce, config.windows);
            var my = new ActivityMy(activityManager, config.windows);
            this._api = new ActivityAPI(activityManager, my);
            this._readyPromise = activityManager.ready().then(function (_) { return _this; });
        }
        ActivityModule.checkIsUsingGW3Implementation = function (connection) {
            return connection.protocolVersion === 3;
        };
        Object.defineProperty(ActivityModule.prototype, "api", {
            get: function () {
                return this._api;
            },
            set: function (value) {
                this._api = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityModule.prototype, "isUsingHCImplementation", {
            get: function () {
                return this._isUsingHCImplementation;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActivityModule.prototype, "isUsingGW3Implementation", {
            get: function () {
                return this._isUsingGW3Implementation;
            },
            enumerable: true,
            configurable: true
        });
        ActivityModule.prototype.ready = function (callback) {
            return nodeify(this._readyPromise, callback);
        };
        return ActivityModule;
    }());

    var ShutdownMethodName = "T42.ACS.Shutdown";
    var OnGDShutdownMethodName = "T42.ACS.OnGDShutdown";
    var RestartMethodName = "T42.ACS.Restart";
    var GetConfigurationRegionMethodName = "T42.ACS.GetConfigurationRegion";
    var SetConfigurationRegionMethodName = "T42.ACS.SetConfigurationRegion";
    var GetUserMethodName = "T42.ACS.GetUser";
    var GetBranchesMethodName = "T42.ACS.GetBranches";
    var GetCurrentBranchMethodName = "T42.ACS.GetCurrentBranch";
    var SetCurrentBranchMethodName = "T42.ACS.SetCurrentBranch";
    var GetFunctionalEntitlementMethodName = "T42.ACS.GetFunctionalEntitlement";
    var CanIMethodName = "T42.ACS.CanI";
    var StartApplicationMethodName = "T42.ACS.StartApplication";
    var StopApplicationMethodName = "T42.ACS.StopApplication";
    var ActivateApplicationMethodName = "T42.ACS.ActivateApplication";
    var OnEventMethodName = "T42.ACS.OnEvent";
    var GetApplicationsMethodName = "T42.ACS.GetApplications";

    function createRegistry$1(options) {
        if (options && options.errorHandling
            && typeof options.errorHandling !== "function"
            && options.errorHandling !== "log"
            && options.errorHandling !== "silent"
            && options.errorHandling !== "throw") {
            throw new Error("Invalid options passed to createRegistry. Prop errorHandling should be [\"log\" | \"silent\" | \"throw\" | (err) => void], but " + typeof options.errorHandling + " was passed");
        }
        var _userErrorHandler = options && typeof options.errorHandling === "function" && options.errorHandling;
        var callbacks = {};
        function add(key, callback, replayArgumentsArr) {
            var callbacksForKey = callbacks[key];
            if (!callbacksForKey) {
                callbacksForKey = [];
                callbacks[key] = callbacksForKey;
            }
            callbacksForKey.push(callback);
            if (replayArgumentsArr) {
                setTimeout(function () {
                    replayArgumentsArr.forEach(function (replayArgument) {
                        var _a;
                        if ((_a = callbacks[key]) === null || _a === void 0 ? void 0 : _a.includes(callback)) {
                            try {
                                if (Array.isArray(replayArgument)) {
                                    callback.apply(undefined, replayArgument);
                                }
                                else {
                                    callback.apply(undefined, [replayArgument]);
                                }
                            }
                            catch (err) {
                                _handleError(err, key);
                            }
                        }
                    });
                }, 0);
            }
            return function () {
                var allForKey = callbacks[key];
                if (!allForKey) {
                    return;
                }
                allForKey = allForKey.reduce(function (acc, element, index) {
                    if (!(element === callback && acc.length === index)) {
                        acc.push(element);
                    }
                    return acc;
                }, []);
                if (allForKey.length === 0) {
                    delete callbacks[key];
                }
                else {
                    callbacks[key] = allForKey;
                }
            };
        }
        function execute(key) {
            var argumentsArr = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                argumentsArr[_i - 1] = arguments[_i];
            }
            var callbacksForKey = callbacks[key];
            if (!callbacksForKey || callbacksForKey.length === 0) {
                return [];
            }
            var results = [];
            callbacksForKey.forEach(function (callback) {
                try {
                    var result = callback.apply(undefined, argumentsArr);
                    results.push(result);
                }
                catch (err) {
                    results.push(undefined);
                    _handleError(err, key);
                }
            });
            return results;
        }
        function _handleError(exceptionArtifact, key) {
            var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);
            if (_userErrorHandler) {
                _userErrorHandler(errParam);
                return;
            }
            var msg = "[ERROR] callback-registry: User callback for key \"" + key + "\" failed: " + errParam.stack;
            if (options) {
                switch (options.errorHandling) {
                    case "log":
                        return console.error(msg);
                    case "silent":
                        return;
                    case "throw":
                        throw new Error(msg);
                }
            }
            console.error(msg);
        }
        function clear() {
            callbacks = {};
        }
        function clearKey(key) {
            var callbacksForKey = callbacks[key];
            if (!callbacksForKey) {
                return;
            }
            delete callbacks[key];
        }
        return {
            add: add,
            execute: execute,
            clear: clear,
            clearKey: clearKey
        };
    }
    createRegistry$1.default = createRegistry$1;
    var lib$2 = createRegistry$1;

    function objectValues(source) {
        if (!source) {
            return [];
        }
        return Object.keys(source).map(function (key) { return source[key]; });
    }
    function objectClone(obj) {
        var result;
        try {
            result = JSON.parse(JSON.stringify(obj || {}));
        }
        catch (error) {
            result = {};
        }
        return result;
    }

    var ApplicationImpl = (function () {
        function ApplicationImpl(_appManager, _name, _agm) {
            var _this = this;
            this._appManager = _appManager;
            this._name = _name;
            this._agm = _agm;
            this._registry = lib$2();
            _appManager.onInstanceStarted(function (instance) {
                if (instance.application && instance.application.name !== _this._name) {
                    return;
                }
                _this._registry.execute("instanceStarted", instance);
            });
            _appManager.onInstanceStopped(function (instance) {
                if (instance.application && instance.application.name !== _this._name) {
                    return;
                }
                _this._registry.execute("instanceStopped", instance);
            });
            _appManager.onAppRemoved(function (app) {
                if (app.name !== _this._name) {
                    return;
                }
                _this._registry.execute("appRemoved", app);
            });
            _appManager.onAppChanged(function (app) {
                if (app.name !== _this._name) {
                    return;
                }
                _this._registry.execute("appChanged", app);
            });
            _appManager.onAppAvailable(function (app) {
                if (app.name !== _this._name) {
                    return;
                }
                _this._registry.execute("appAvailable", app);
            });
            _appManager.onAppUnavailable(function (app) {
                if (app.name !== _this._name) {
                    return;
                }
                _this._registry.execute("appUnavailable", app);
            });
        }
        Object.defineProperty(ApplicationImpl.prototype, "name", {
            get: function () { return this._name; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "title", {
            get: function () { return this._props.Title; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "version", {
            get: function () { return this._props.Version; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "autoStart", {
            get: function () { return this._props.AutoStart; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "isShell", {
            get: function () { return this._props.IsShell; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "caption", {
            get: function () { return this._props.Caption; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "hidden", {
            get: function () { return this._props.IsHidden; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "container", {
            get: function () { return this._props.ApplicationName; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "activityType", {
            get: function () { return this._props.ActivityType; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "activityWindowType", {
            get: function () { return this._props.ActivityWindowType; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "windowSettings", {
            get: function () {
                if (!this._props.Arguments) {
                    return {};
                }
                return objectClone(this._props.Arguments);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "allowMultiple", {
            get: function () { return this._props.AllowMultiple; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "available", {
            get: function () { return this._props.IsReady || true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "icon", {
            get: function () { return this._props.Icon; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "iconURL", {
            get: function () { return this._props.IconUrl; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "sortOrder", {
            get: function () { return this._props.SortOrder; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "userProperties", {
            get: function () {
                if (!this._props.UserProperties) {
                    return {};
                }
                return objectClone(this._props.UserProperties);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "isActivity", {
            get: function () {
                return this._props.ActivityType !== undefined && this._props.ActivityType !== "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "configuration", {
            get: function () {
                return {
                    autoStart: this._props.AutoStart,
                    caption: this._props.Caption,
                    hidden: this._props.IsHidden,
                    container: this._props.ApplicationName,
                    activityType: this._props.ActivityType,
                    allowMultiple: this._props.AllowMultiple
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "instances", {
            get: function () {
                var _this = this;
                return this._appManager.instances().filter(function (instance) { return instance.application.name === _this._name; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "type", {
            get: function () {
                return this._props.Type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationImpl.prototype, "mode", {
            get: function () {
                if (!this._props) {
                    return "unknown";
                }
                if (this._props.Mode && typeof this._props.Mode === "string") {
                    return this._props.Mode.toLowerCase();
                }
                if (this.isActivity) {
                    return "unknown";
                }
                if (this._props.Arguments && this._props.Arguments.mode && typeof this._props.Arguments.mode === "string") {
                    return this._props.Arguments.mode.toLowerCase();
                }
                var styleAttributes = this._props.WindowStyleAttributes;
                if (styleAttributes) {
                    styleAttributes = styleAttributes.split(" ").join("");
                    var searchFor = "mode:\"";
                    var modeIndex = styleAttributes.indexOf(searchFor);
                    if (modeIndex !== -1) {
                        var startModeIndex = modeIndex + searchFor.length;
                        var stopModeIndex = styleAttributes.indexOf("\"", startModeIndex);
                        var style = styleAttributes.substr(startModeIndex, stopModeIndex - startModeIndex);
                        if (style && typeof style === "string") {
                            return style.toLowerCase();
                        }
                    }
                }
                return "flat";
            },
            enumerable: true,
            configurable: true
        });
        ApplicationImpl.prototype.updateFromProps = function (props) {
            var _this = this;
            if (!this._props) {
                this._props = { Name: props.Name };
            }
            Object.keys(props).forEach(function (key) {
                _this._props[key] = props[key];
            });
        };
        ApplicationImpl.prototype.start = function (context, options) {
            var _this = this;
            var name = this._name;
            var startTimeout = 10000;
            return new Promise(function (resolve, reject) {
                var _a;
                options = options || {};
                context = context || {};
                var waitForAGMInstance = (_a = options.waitForAGMReady, (_a !== null && _a !== void 0 ? _a : true));
                var waitForApplicationInstance = function (id) {
                    var check = function () {
                        var filtered = _this._appManager.instances().filter(function (i) { return i.id === id; });
                        var result;
                        if (filtered.length === 2) {
                            result = filtered[0].isActivityInstance ? filtered[0] : filtered[1];
                        }
                        else {
                            result = filtered[0];
                        }
                        if (result && waitForAGMInstance) {
                            if (result.agm) {
                                return result;
                            }
                            else {
                                return undefined;
                            }
                        }
                        return result;
                    };
                    var unsub;
                    var timeout = setTimeout(function () {
                        if (unsub) {
                            unsub();
                        }
                        reject("timeout");
                    }, startTimeout);
                    var waitFunc = function (i) {
                        if (i.id !== id) {
                            return;
                        }
                        if (unsub) {
                            unsub();
                            unsub = undefined;
                        }
                        clearTimeout(timeout);
                        setTimeout(function () {
                            resolve(check());
                        }, 1);
                    };
                    if (waitForAGMInstance) {
                        unsub = _this._appManager.onInstanceAgmServerReady(waitFunc);
                    }
                    else {
                        unsub = _this._appManager.onInstanceStarted(waitFunc);
                    }
                    var instances = check();
                    if (instances) {
                        if (unsub) {
                            unsub();
                            unsub = undefined;
                        }
                        clearTimeout(timeout);
                        resolve(instances);
                    }
                };
                _this._agm.invoke(StartApplicationMethodName, {
                    Name: name,
                    Context: context,
                    Options: options
                }, "best", {
                    methodResponseTimeoutMs: startTimeout
                }, function (result) {
                    var acsResult = result.returned && result.returned.Instance_0
                        ? result.returned.Instance_0
                        : result.returned;
                    if (acsResult && acsResult.Id) {
                        if (_this._appManager.mode === "startOnly") {
                            var instance = _this._appManager.handleInstanceStarted(acsResult);
                            resolve(instance);
                        }
                        else {
                            waitForApplicationInstance(acsResult.Id);
                        }
                    }
                    else {
                        resolve(undefined);
                    }
                }, function (err) {
                    reject(err);
                });
            });
        };
        ApplicationImpl.prototype.onInstanceStarted = function (callback) {
            this._registry.add("instanceStarted", callback);
        };
        ApplicationImpl.prototype.onInstanceStopped = function (callback) {
            this._registry.add("instanceStopped", callback);
        };
        ApplicationImpl.prototype.onAvailable = function (callback) {
            this._registry.add("appAvailable", callback);
        };
        ApplicationImpl.prototype.onUnavailable = function (callback) {
            this._registry.add("appUnavailable", callback);
        };
        ApplicationImpl.prototype.onChanged = function (callback) {
            this._registry.add("appChanged", callback);
        };
        ApplicationImpl.prototype.onRemoved = function (callback) {
            this._registry.add("appRemoved", callback);
        };
        return ApplicationImpl;
    }());

    var InstanceImpl = (function () {
        function InstanceImpl(_id, _appName, _appManager, _agm, _activities, _windows, startFailed) {
            var _this = this;
            this._id = _id;
            this._appName = _appName;
            this._appManager = _appManager;
            this._agm = _agm;
            this._activities = _activities;
            this._windows = _windows;
            this.onAgmReady = this._addToRegistry("agmReady");
            this.onStopped = this._addToRegistry("stopped");
            this._registry = lib$2();
            if (startFailed) {
                return;
            }
            this._unsubscribeInstanceStopped = this._appManager.onInstanceStopped(function (instance) {
                if (instance.id !== _this._id) {
                    return;
                }
                _this._registry.execute("stopped", instance);
            });
            this._unsubscribeInstanceAgmServerReady = this._appManager.onInstanceAgmServerReady(function (instance) {
                if (instance.id !== _this._id) {
                    return;
                }
                _this._registry.execute("agmReady", instance);
            });
        }
        Object.defineProperty(InstanceImpl.prototype, "id", {
            get: function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "application", {
            get: function () { return this._appManager.application(this._appName); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "activity", {
            get: function () {
                var _this = this;
                if (!this._activities) {
                    throw new Error("This method requires glue.activities library to be enabled.");
                }
                return this._activities.all.instances.get()
                    .filter(function (activityInstance) { return activityInstance.id === _this._activityId; })[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "isActivityOwner", {
            get: function () { return this._isActivityOwner; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "activityInstances", {
            get: function () {
                var _this = this;
                return this._appManager.instances().filter(function (i) {
                    return i.application.type !== "activity" &&
                        i.activityId &&
                        i.activityId === _this._activityId;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "activityOwnerInstance", {
            get: function () {
                if (!this._activityId) {
                    return undefined;
                }
                return this.activityInstances.filter(function (inst) { var _a; return (_a = inst) === null || _a === void 0 ? void 0 : _a.isActivityOwner; })[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "window", {
            get: function () {
                var _this = this;
                if (!this._windows) {
                    throw new Error("This method requires glue.windows library to be enabled.");
                }
                var win = this._windows.list().filter(function (w) { return w.id === _this._id; })[0];
                if (!win && this.activity && this.activityOwnerInstance) {
                    win = this.activityOwnerInstance.window;
                }
                return win;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "context", {
            get: function () {
                var _a, _b, _c;
                return _c = (_a = this._startUpContext, (_a !== null && _a !== void 0 ? _a : (_b = this.window) === null || _b === void 0 ? void 0 : _b.context)), (_c !== null && _c !== void 0 ? _c : {});
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "title", {
            get: function () { return this._title; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "isActivityInstance", {
            get: function () { return this._isActivityInstance; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "activityId", {
            get: function () { return this._activityId; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "inActivity", {
            get: function () { return this._inActivity; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "isSingleWindowApp", {
            get: function () { return !this._inActivity; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceImpl.prototype, "agm", {
            get: function () {
                return this._agmInstance;
            },
            enumerable: true,
            configurable: true
        });
        InstanceImpl.prototype.updateFromProps = function (props) {
            this._startUpContext = props.Context;
            this._title = props.Title;
            this._isActivityInstance = false;
            if (props.ActivityId && props.ActivityId !== "") {
                this._activityId = props.ActivityId;
                this._isActivityInstance = true;
            }
            this._isActivityOwner = props.IsActivityOwner;
            if (!this._activityId && this._startUpContext && this._startUpContext.activityId) {
                this._activityId = this._startUpContext.activityId;
            }
            this._inActivity = Boolean(this._activityId);
            this.updateAgmInstanceFromProps(props);
        };
        InstanceImpl.prototype.updateAgmInstanceFromProps = function (props) {
            if (!props.AgmServers) {
                return;
            }
            if (props.GD3) {
                var agmInstances = props.AgmServers;
                if (agmInstances) {
                    this._agmInstance = agmInstances[0];
                }
            }
            else {
                var gdAgmServers = props.AgmServers;
                var propsAgmServer = Object.keys(gdAgmServers)[0];
                if (!propsAgmServer) {
                    return;
                }
                var propsAgm = gdAgmServers[propsAgmServer];
                this._agmInstance = {
                    machine: propsAgm.machineName,
                    user: propsAgm.userName,
                    environment: propsAgm.environment,
                    application: propsAgm.applicationName,
                };
            }
        };
        InstanceImpl.prototype.stop = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var unsubscribe = _this._appManager.onInstanceStopped(function (instance) {
                    if (instance.id === _this._id) {
                        unsubscribe();
                        resolve();
                    }
                });
                _this._agm.invoke(StopApplicationMethodName, {
                    Name: _this._appName,
                    Id: _this._id
                })
                    .then(function () {
                    if (_this._appManager.mode === "startOnly") {
                        _this._appManager.handleInstanceStopped({
                            Name: _this._appName,
                            Id: _this.id,
                            Context: undefined,
                            Title: undefined,
                            ActivityId: undefined,
                            IsActivityOwner: undefined,
                            AgmServers: undefined
                        });
                        resolve();
                    }
                })
                    .catch(function (err) { return reject(err); });
            });
        };
        InstanceImpl.prototype.activate = function () {
            return this._agm.invoke(ActivateApplicationMethodName, { Name: this._appName, Id: this._id });
        };
        InstanceImpl.prototype.done = function () {
            this._registry.clear();
            this._unsubscribeInstanceAgmServerReady();
            this._unsubscribeInstanceStopped();
        };
        InstanceImpl.prototype.getContext = function () {
            return Promise.resolve(this.context);
        };
        InstanceImpl.prototype._addToRegistry = function (key) {
            var _this = this;
            return function (callback) {
                _this._registry.add(key, callback);
            };
        };
        return InstanceImpl;
    }());

    var AppManagerImpl = (function () {
        function AppManagerImpl(mode, _agm, _activities, _windows, _logger, _gdMajorVersion) {
            var _this = this;
            this.mode = mode;
            this._agm = _agm;
            this._activities = _activities;
            this._windows = _windows;
            this._logger = _logger;
            this._gdMajorVersion = _gdMajorVersion;
            this._apps = {};
            this._instances = [];
            this._registry = lib$2();
            this.application = function (name) {
                return _this._apps[name];
            };
            this.applications = function () {
                return Object.keys(_this._apps).map(function (k) { return _this._apps[k]; });
            };
            this.instances = function () {
                return _this._instances;
            };
            this.getMyInstance = function () {
                if (_this._gdMajorVersion >= 3) {
                    var instanceId_1 = window.glue42gd.appInstanceId;
                    return _this._instances.filter(function (i) { return i.id === instanceId_1; })[0];
                }
                return undefined;
            };
            this.handleAppAdded = function (props) {
                var id = _this._getAppId(props);
                _this._logger.trace("adding app " + id);
                _this._apps[id] = new ApplicationImpl(_this, id, _this._agm);
                var app = _this._updateAppFromProps(props);
                _this._registry.execute("appAdded", app);
            };
            this.handleAppUpdated = function (props) {
                var app = _this._updateAppFromProps(props);
                _this._registry.execute("appChanged", app);
            };
            this.handleAppRemoved = function (props) {
                var id = _this._getAppId(props);
                _this._logger.trace("removing app " + id);
                var app = _this.application(id);
                _this._instances = _this._instances.filter(function (i) { return i.application.name !== app.name; });
                delete _this._apps[id];
                _this._registry.execute("appRemoved", app);
            };
            this.handleAppReady = function (props) {
                var id = _this._getAppId(props);
                var app = _this._getAppOrThrow(id);
                app.updateFromProps(props);
                if (app.available) {
                    _this._registry.execute("appAvailable", app);
                }
                else {
                    _this._registry.execute("appUnavailable", app);
                }
            };
            this.handleInstanceStarted = function (props) {
                _this._logger.trace("started app " + props.Name + " " + props.Id);
                var id = _this._getInstanceId(props);
                var appName = _this._getInstanceAppName(props);
                var instance = new InstanceImpl(id, appName, _this, _this._agm, _this._activities, _this._windows);
                _this._updateInstanceFromProps(instance, props);
                _this._instances.push(instance);
                _this._registry.execute("instanceStarted", instance);
                return instance;
            };
            this.handleInstanceStopped = function (props) {
                _this._logger.trace("failed to start app " + props.Name + " " + props.Id);
                var id = _this._getInstanceId(props);
                var appName = _this._getInstanceAppName(props);
                var instance = _this._getInstanceOrThrow(id, appName);
                _this._instances = _this._instances.filter(function (i) { return !_this._matchInstance(i, id, appName); });
                _this._registry.execute("instanceStopped", instance);
                instance.done();
            };
            this.handleInstanceAgmServerReady = function (props) {
                var id = _this._getInstanceId(props);
                var appName = _this._getInstanceAppName(props);
                var instance = _this._getInstanceOrThrow(id, appName);
                instance.updateAgmInstanceFromProps(props);
                _this._registry.execute("instanceAgmServerReady", instance);
            };
            this.handleInstanceStartFailed = function (props) {
                var id = _this._getInstanceId(props);
                var appName = _this._getInstanceAppName(props);
                var startFailed = true;
                var instance = new InstanceImpl(id, appName, undefined, undefined, undefined, undefined, startFailed);
                _this._updateInstanceFromProps(instance, props);
                _this._registry.execute("instanceStartFailed", instance);
            };
            this.handleInstanceUpdated = function (props) {
                var id = _this._getInstanceId(props);
                var app = _this._getInstanceAppName(props);
                var instance = _this._getInstanceOrThrow(id, app);
                _this._updateInstanceFromProps(instance, props);
            };
            this.onInstanceStarted = function (callback) {
                return _this._registry.add("instanceStarted", callback, _this._instances);
            };
            this.onInstanceStartFailed = function (callback) {
                return _this._registry.add("instanceStartFailed", callback);
            };
            this.onInstanceStopped = function (callback) {
                return _this._registry.add("instanceStopped", callback);
            };
            this.onInstanceUpdated = function (callback) {
                return _this._registry.add("instanceChanged", callback);
            };
            this.onInstanceAgmServerReady = function (callback) {
                return _this._registry.add("instanceAgmServerReady", callback);
            };
            this.onAppAdded = function (callback) {
                return _this._registry.add("appAdded", callback, Object.values(_this._apps));
            };
            this.onAppRemoved = function (callback) {
                return _this._registry.add("appRemoved", callback);
            };
            this.onAppAvailable = function (callback) {
                return _this._registry.add("appAvailable", callback);
            };
            this.onAppUnavailable = function (callback) {
                return _this._registry.add("appUnavailable", callback);
            };
            this.onAppChanged = function (callback) {
                return _this._registry.add("appChanged", callback);
            };
        }
        AppManagerImpl.prototype._getAppOrThrow = function (id) {
            var result = this.application(id);
            if (!result) {
                throw Error("app with id " + id + " not found");
            }
            return result;
        };
        AppManagerImpl.prototype._getAppId = function (props) {
            return props.Name;
        };
        AppManagerImpl.prototype._matchInstance = function (instance, id, appName) {
            return instance.id === id && instance.application.name === appName;
        };
        AppManagerImpl.prototype._getInstanceByIdAndName = function (id, appName) {
            var _this = this;
            return this._instances.filter(function (i) { return _this._matchInstance(i, id, appName); })[0];
        };
        AppManagerImpl.prototype._getInstanceOrThrow = function (id, appName) {
            var result = this._getInstanceByIdAndName(id, appName);
            if (!result) {
                throw Error("instance with id " + id + " not found");
            }
            return result;
        };
        AppManagerImpl.prototype._getInstanceId = function (props) {
            return props.Id;
        };
        AppManagerImpl.prototype._getInstanceAppName = function (props) {
            return props.Name;
        };
        AppManagerImpl.prototype._updateAppFromProps = function (props) {
            var id = this._getAppId(props);
            this._logger.trace("updating app with  + " + id + ", " + props);
            var app = this._getAppOrThrow(id);
            app.updateFromProps(props);
            return app;
        };
        AppManagerImpl.prototype._updateInstanceFromProps = function (instance, props) {
            this._logger.trace("updating instance with " + this._getInstanceId(props) + " for app " + this._getInstanceAppName(props));
            instance.updateFromProps(props);
        };
        return AppManagerImpl;
    }());

    function promisify$2(promise, successCallback, errorCallback) {
        var isFunction = function (arg) {
            return !!(arg && arg.constructor && arg.call && arg.apply);
        };
        if (!isFunction(successCallback) && !isFunction(errorCallback)) {
            return promise;
        }
        if (!isFunction(successCallback)) {
            successCallback = function () {
            };
        }
        else if (!isFunction(errorCallback)) {
            errorCallback = function () {
            };
        }
        promise.then(successCallback, errorCallback);
    }
    var EntitlementsImpl = (function () {
        function EntitlementsImpl(_agm) {
            var _this = this;
            this._agm = _agm;
            this._registry = lib$2();
            this._isMethodRegistered = false;
            this.handleBranchModified = function (branch) {
                _this._registry.execute("branchChanged", branch);
            };
            this.handleBranchesModified = function (branches) {
                _this._registry.execute("branchesChanged", branches);
            };
            this.getRegion = function (success, error) {
                return promisify$2(_this._agmInvoke(GetConfigurationRegionMethodName, function (e) { return e.returned.Region; }), success, error);
            };
            this.getBranches = function (success, error) {
                var promise = _this._agmInvoke(GetBranchesMethodName, function (e) {
                    var obj = e.returned.Branches;
                    return Object.keys(obj).map(function (key) { return obj[key]; });
                });
                return promisify$2(promise, success, error);
            };
            this.getCurrentBranch = function (success, error) {
                var promise = _this._agmInvoke(GetCurrentBranchMethodName, function (e) { return e.returned.Branch; }, undefined);
                return promisify$2(promise, success, error);
            };
            this.setRegion = function (region, success, error) {
                var promise = _this._agmInvoke(SetConfigurationRegionMethodName, function (e) { return e.returned.ResultMessage; }, { Region: region });
                return promisify$2(promise, success, error);
            };
            this.setCurrentBranch = function (branch, success, error) {
                var promise = _this._agmInvoke(SetCurrentBranchMethodName, function (e) { return e.returned.ResultMessage; }, { Branch: branch });
                return promisify$2(promise, success, error);
            };
            this.currentUser = function (success, error) {
                var promise = _this._agmInvoke(GetUserMethodName);
                return promisify$2(promise, success, error);
            };
            this.getFunctionalEntitlement = function (funct, success, error) {
                var promise = _this._agmInvoke(GetFunctionalEntitlementMethodName, function (e) { return e.returned.Entitlement; }, { Function: funct });
                return promisify$2(promise, success, error);
            };
            this.getFunctionalEntitlementBranch = function (funct, branch, success, error) {
                var promise = _this._agmInvoke(GetFunctionalEntitlementMethodName, function (e) { return e.returned.Entitlement; }, { Function: funct, Branch: branch });
                return promisify$2(promise, success, error);
            };
            this.canI = function (func, success, error) {
                var promise = _this._agmInvoke(CanIMethodName, function (e) { return e.returned.Result; }, { Function: func });
                return promisify$2(promise, success, error);
            };
            this.canIBranch = function (func, branch, success, error) {
                var promise = _this._agmInvoke(CanIMethodName, function (e) { return e.returned.Result; }, { Function: func, Branch: branch });
                return promisify$2(promise, success, error);
            };
            this.onBranchesChanged = function (callback) {
                return _this._registry.add("branchesChanged", callback);
            };
            this.onBranchChanged = function (callback) {
                return _this._registry.add("branchChanged", callback);
            };
            this.exit = function (options) {
                return _this._agmInvoke(ShutdownMethodName, null, options);
            };
            this.onShuttingDown = function (callback) {
                _this.registerMethod();
                return _this._registry.add("onShuttingDown", callback);
            };
            this.restart = function (options) {
                return _this._agmInvoke(RestartMethodName, null, options);
            };
            this._agmInvoke = function (method, transformFunction, args) {
                args = args || {};
                return new Promise(function (resolve, reject) {
                    var errHandler = function (error) { return reject(error); };
                    _this._agm.invoke(method, args)
                        .then(function (result) {
                        if (!transformFunction) {
                            transformFunction = function (d) { return d.returned; };
                        }
                        resolve(transformFunction(result));
                    })
                        .catch(errHandler);
                });
            };
        }
        EntitlementsImpl.prototype.registerMethod = function () {
            var _this = this;
            if (!this._isMethodRegistered) {
                this._agm.register(OnGDShutdownMethodName, function (args) { return __awaiter(_this, void 0, void 0, function () {
                    var error_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4, Promise.all(this._registry.execute("onShuttingDown", args))];
                            case 1:
                                _a.sent();
                                return [3, 3];
                            case 2:
                                error_1 = _a.sent();
                                return [3, 3];
                            case 3: return [2];
                        }
                    });
                }); });
                this._isMethodRegistered = true;
            }
        };
        return EntitlementsImpl;
    }());

    function snapshot(agm, appManager) {
        return new Promise(function (resolve, reject) {
            agm.invoke(GetApplicationsMethodName, { skipIcon: true })
                .then(function (response) {
                var data = response.returned;
                if (!data) {
                    resolve();
                }
                var applications = data.applications;
                if (!applications) {
                    resolve();
                }
                objectValues(applications).map(function (item) { return appManager.handleAppAdded(item); });
                resolve();
            })
                .catch(function (err) { return reject("Error getting application snapshot: " + err.message); });
        });
    }

    var OnBranchChangedEvent = "OnBranchChanged";
    var OnBranchesModifiedEvent = "OnBranchesModified";
    var OnApplicationAddedEvent = "OnApplicationAdded";
    var OnApplicationRemovedEvent = "OnApplicationRemoved";
    var OnApplicationChangedEvent = "OnApplicationChanged";
    var OnApplicationReadyEvent = "OnApplicationReady";
    var OnApplicationStartedEvent = "OnApplicationStarted";
    var OnApplicationAgmServerReadyEvent = "OnApplicationAgmServerReady";
    var OnApplicationUpdatedEvent = "OnApplicationUpdated";
    var OnApplicationStoppedEvent = "OnApplicationStopped";
    var OnApplicationStartFailedEvent = "OnApplicationStartFailed";

    function createDataSubscription(agm, applications, entitlements, skipIcons) {
        var subscription;
        var start = function () {
            var resolveFunc;
            var rejectFunc;
            var resultPromise = new Promise(function (resolve, reject) {
                resolveFunc = resolve;
                rejectFunc = reject;
            });
            agm.subscribe(OnEventMethodName, { arguments: { skipIcon: skipIcons }, waitTimeoutMs: 10000 })
                .then(function (s) {
                subscription = s;
                subscription.onData(function (streamData) {
                    var events = streamData.data;
                    objectValues(events[OnApplicationAddedEvent])
                        .map(function (item) { return applications.handleAppAdded(item); });
                    objectValues(events[OnApplicationChangedEvent])
                        .map(function (item) { return applications.handleAppUpdated(item); });
                    objectValues(events[OnApplicationRemovedEvent])
                        .map(function (item) { return applications.handleAppRemoved(item); });
                    objectValues(events[OnApplicationReadyEvent])
                        .map(function (item) { return applications.handleAppReady(item); });
                    objectValues(events[OnApplicationStartedEvent])
                        .map(function (item) { return applications.handleInstanceStarted(item); });
                    objectValues(events[OnApplicationStartFailedEvent])
                        .map(function (item) { return applications.handleInstanceStartFailed(item); });
                    objectValues(events[OnApplicationStoppedEvent])
                        .map(function (item) { return applications.handleInstanceStopped(item); });
                    objectValues(events[OnApplicationUpdatedEvent])
                        .map(function (item) { return applications.handleInstanceUpdated(item); });
                    objectValues(events[OnApplicationAgmServerReadyEvent])
                        .map(function (item) { return applications.handleInstanceAgmServerReady(item); });
                    objectValues(events[OnBranchChangedEvent])
                        .map(function (item) { return entitlements.handleBranchModified(item); });
                    objectValues(events[OnBranchesModifiedEvent])
                        .map(function (item) { return entitlements.handleBranchesModified(item); });
                    resolveFunc();
                });
                subscription.onFailed(function (err) { return rejectFunc(err); });
            })
                .catch(function (err) { return rejectFunc("Error subscribing for " + OnEventMethodName + " stream. Err: " + err); });
            return resultPromise;
        };
        var stop = function () {
            if (subscription) {
                subscription.close();
            }
        };
        return {
            start: start,
            stop: stop
        };
    }

    var InMemoryStoreCommandMethodName = "T42.ACS.InMemoryStoreCommand";
    var InMemoryStore = (function () {
        function InMemoryStore(interop) {
            this.interop = interop;
        }
        InMemoryStore.prototype.import = function (apps, mode) {
            if (!apps || !Array.isArray(apps)) {
                return Promise.reject("invalid apps argument - should be an array of application definitions");
            }
            if (mode && mode !== "replace" && mode !== "merge") {
                return Promise.reject("invalid mode argument - should be 'replace' or 'merge'");
            }
            mode = (mode !== null && mode !== void 0 ? mode : "replace");
            var command = {
                command: "import",
                args: {
                    apps: apps,
                    mode: mode
                }
            };
            return this.interop.invoke(InMemoryStoreCommandMethodName, command)
                .then(function (r) { return r.returned; });
        };
        InMemoryStore.prototype.export = function () {
            return this.interop.invoke(InMemoryStoreCommandMethodName, { command: "export" })
                .then(function (r) { return r.returned.apps; });
        };
        InMemoryStore.prototype.remove = function (app) {
            if (!app || typeof app !== "string") {
                return Promise.reject("invalid app name, should be a string value");
            }
            var command = {
                command: "remove",
                args: {
                    apps: [app]
                }
            };
            return this.interop.invoke(InMemoryStoreCommandMethodName, command).then(function (r) { return r.returned; });
        };
        InMemoryStore.prototype.clear = function () {
            var command = {
                command: "clear"
            };
            return this.interop.invoke(InMemoryStoreCommandMethodName, command).then(function (r) { return r.returned; });
        };
        InMemoryStore.prototype.createAppDef = function (name, url) {
            if (!url) {
                url = "https://google.com";
            }
            return {
                name: name,
                type: "window",
                title: name,
                details: {
                    url: url
                }
            };
        };
        return InMemoryStore;
    }());

    var AppManagerFactory = (function (config) {
        if (!config) {
            throw Error("config not set");
        }
        if (!config.agm) {
            throw Error("config.agm is missing");
        }
        var START_ONLY = "startOnly";
        var SKIP_ICONS = "skipIcons";
        var FULL = "full";
        var mode = config.mode || START_ONLY;
        if (mode !== START_ONLY && mode !== SKIP_ICONS && mode !== FULL) {
            throw new Error("Invalid mode for appManager lib - " + mode + " is not supported");
        }
        var activities = config.activities;
        var agm = config.agm;
        var logger = config.logger;
        var windows = config.windows;
        var appManager = new AppManagerImpl(mode, agm, activities, windows, logger.subLogger("applications"), config.gdMajorVersion);
        var entitlements = new EntitlementsImpl(agm);
        var readyPromise;
        if (mode === START_ONLY) {
            readyPromise = snapshot(agm, appManager);
        }
        else {
            var subscription = createDataSubscription(agm, appManager, entitlements, mode === SKIP_ICONS);
            readyPromise = subscription.start();
        }
        var api = {
            ready: function () { return readyPromise; },
            applications: appManager.applications,
            application: appManager.application,
            onAppAdded: appManager.onAppAdded,
            onAppRemoved: appManager.onAppRemoved,
            onAppChanged: appManager.onAppChanged,
            onAppAvailable: appManager.onAppAvailable,
            onAppUnavailable: appManager.onAppUnavailable,
            instances: appManager.instances,
            get myInstance() {
                return appManager.getMyInstance();
            },
            onInstanceStarted: appManager.onInstanceStarted,
            onInstanceStopped: appManager.onInstanceStopped,
            onInstanceUpdated: appManager.onInstanceUpdated,
            onInstanceStartFailed: appManager.onInstanceStartFailed,
            getRegion: entitlements.getRegion,
            getBranches: entitlements.getBranches,
            getCurrentBranch: entitlements.getCurrentBranch,
            getFunctionalEntitlement: entitlements.getFunctionalEntitlement,
            getFunctionalEntitlementBranch: entitlements.getFunctionalEntitlementBranch,
            setCurrentBranch: entitlements.setCurrentBranch,
            setRegion: entitlements.setRegion,
            currentUser: entitlements.currentUser,
            canI: entitlements.canI,
            canIBranch: entitlements.canIBranch,
            onBranchesChanged: entitlements.onBranchesChanged,
            exit: entitlements.exit,
            restart: entitlements.restart,
            onShuttingDown: entitlements.onShuttingDown,
            inMemory: new InMemoryStore(agm)
        };
        return api;
    });

    var WindowStore = (function () {
        function WindowStore() {
            this.waitForTimeoutInMilliseconds = 60000;
            this._windows = {};
            this._pendingWindows = {};
            this._pendingWindowsStates = {};
            this._registry = lib$2();
        }
        WindowStore.prototype.init = function (logger) {
            this._logger = logger;
        };
        WindowStore.prototype.get = function (id) {
            return this._windows[id] || this._pendingWindows[id];
        };
        WindowStore.prototype.getIfReady = function (id) {
            return this._windows[id];
        };
        Object.defineProperty(WindowStore.prototype, "list", {
            get: function () {
                return this._windows;
            },
            enumerable: true,
            configurable: true
        });
        WindowStore.prototype.add = function (window) {
            var isExist = this._pendingWindows[window.API.id] ? true : false;
            if (isExist) {
                this._logger.error("trying to add window with id " + window.API.id + " from windowStore, which already exists");
                return;
            }
            var remote = window.API.windowType === "remote";
            this._pendingWindows[window.API.id] = window;
            this._pendingWindowsStates[window.API.id] = {
                ready: false,
                urlChanged: remote,
            };
            this._registry.execute("on-added", window);
        };
        WindowStore.prototype.remove = function (window) {
            delete this._windows[window.API.id];
            delete this._pendingWindows[window.API.id];
            delete this._pendingWindowsStates[window.API.id];
            this._registry.execute("on-removed", window);
        };
        WindowStore.prototype.setReadyState = function (windowId) {
            var targetWindowState = this._pendingWindowsStates[windowId];
            if (typeof targetWindowState === "undefined") {
                return;
            }
            targetWindowState.ready = true;
            if (targetWindowState.urlChanged) {
                this.markReadyToShow(windowId);
            }
        };
        WindowStore.prototype.setUrlChangedState = function (windowId) {
            var targetWindowState = this._pendingWindowsStates[windowId];
            if (typeof targetWindowState === "undefined") {
                return;
            }
            targetWindowState.urlChanged = true;
            if (targetWindowState.ready) {
                this.markReadyToShow(windowId);
            }
        };
        WindowStore.prototype.waitFor = function (id) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var un;
                var timeout = setTimeout(function () {
                    un();
                    reject("waitFor timed out.");
                }, _this.waitForTimeoutInMilliseconds);
                var win = _this._windows[id];
                if (win) {
                    clearTimeout(timeout);
                    resolve(win);
                }
                else {
                    un = _this.onReadyWindow(function (w) {
                        if (w.API.id !== id) {
                            return;
                        }
                        clearTimeout(timeout);
                        un();
                        resolve(w);
                    });
                }
            });
        };
        WindowStore.prototype.onReadyWindow = function (callback) {
            return this._registry.add("on-ready", callback);
        };
        WindowStore.prototype.onAdded = function (callback) {
            return this._registry.add("on-added", callback);
        };
        WindowStore.prototype.onRemoved = function (callback) {
            return this._registry.add("on-removed", callback);
        };
        WindowStore.prototype.markReadyToShow = function (windowId) {
            if (this._pendingWindows[windowId]) {
                this._windows[windowId] = this._pendingWindows[windowId];
                delete this._pendingWindows[windowId];
                delete this._pendingWindowsStates[windowId];
            }
            this._registry.execute("on-ready", this._windows[windowId]);
        };
        return WindowStore;
    }());
    var windowStore = new WindowStore();

    var Utils$1 = (function () {
        function Utils() {
        }
        Utils.getGDMajorVersion = function () {
            if (typeof window === "undefined") {
                return -1;
            }
            if (!window.glueDesktop) {
                return -1;
            }
            if (!window.glueDesktop.version) {
                return -1;
            }
            var ver = Number(window.glueDesktop.version.substr(0, 1));
            return isNaN(ver) ? -1 : ver;
        };
        Utils.callbackifyPromise = function (action, successCallback, errorCallback) {
            var fail = function (error) {
                var msg = error;
                if (error instanceof Error) {
                    msg = error.message;
                }
                if (typeof errorCallback === "function") {
                    errorCallback(msg);
                    return;
                }
                return Promise.reject(msg);
            };
            try {
                return action()
                    .then(function (result) {
                    if (typeof successCallback === "function") {
                        successCallback(result);
                    }
                    return result;
                })
                    .catch(function (error) {
                    return fail(error);
                });
            }
            catch (err) {
                return fail(err);
            }
        };
        Utils.getMonitor = function (bounds, displays) {
            var _this = this;
            var monitorsSortedByOverlap = displays.map(function (m) {
                var left = m.left, top = m.top, width = m.workingAreaWidth, height = m.workingAreaHeight;
                var overlap = _this.calculateTotalOverlap({ left: left, top: top, width: width, height: height }, bounds);
                return {
                    monitor: m,
                    totalOverlap: overlap
                };
            }).sort(function (a, b) { return b.totalOverlap - a.totalOverlap; });
            return monitorsSortedByOverlap[0].monitor;
        };
        Utils.getDisplayCenterOfScreen = function (a, display) {
            var left = Math.floor(Math.max(display.left, (display.left + (display.workingAreaWidth - a.width) / 2)));
            var top = Math.floor(Math.max(display.top, (display.top + (display.workingAreaHeight - a.height) / 2)));
            return {
                top: top,
                left: left
            };
        };
        Utils.calculateTotalOverlap = function (r1, r2) {
            var r1x = r1.left;
            var r1y = r1.top;
            var r1xMax = r1x + r1.width;
            var r1yMax = r1y + r1.height;
            var r2x = r2.left;
            var r2y = r2.top;
            var r2xMax = r2x + r2.width;
            var r2yMax = r2y + r2.height;
            var xOverlap = Math.max(0, Math.min(r1xMax, r2xMax) - Math.max(r1x, r2x));
            var yOverlap = Math.max(0, Math.min(r1yMax, r2yMax) - Math.max(r1y, r2y));
            return xOverlap * yOverlap;
        };
        return Utils;
    }());

    var windowFactory = (function (id, options, executor, logger, appManagerGetter, displayAPIGetter, agm, registry) {
        var _registry = (registry !== null && registry !== void 0 ? registry : lib$2());
        var _logger = logger.subLogger("window " + id);
        var _name = options.name;
        var _mode = options.mode;
        var _url = options.url;
        var _title = options.title;
        var _context = options.context || {};
        var _bounds = options.bounds;
        var _frameColor = options.frameColor;
        var _focus = options.focus;
        var _neighbours = options.neighbours || {};
        var _groupId = options.groupId;
        var _isGroupHeaderVisible = options.isGroupHeaderVisible;
        var _isTabHeaderVisible = options.isTabHeaderVisible;
        var _isTabSelected = options.isTabSelected;
        var _settings = options.settings;
        var _isVisible = options.isVisible;
        var _isSticky = options.isSticky;
        var isCollapsed = options.isCollapsed;
        var _windowState = options.state;
        var _tabGroupId = options.tabGroupId;
        var _isLocked = options.isLocked;
        var _group;
        var resultWindow;
        var _frameButtons = [];
        var _zoomFactor = options.zoomFactor;
        var _placementSettings = options.placementSettings;
        function close(success, error) {
            return new Promise(function (resolve, reject) {
                if (!id) {
                    var e = new Error("The window is already closed.");
                    if (typeof error === "function") {
                        error(e.message);
                    }
                    reject(e);
                    return;
                }
                var un = onClose(function () {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.close(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function navigate(newUrl, success, error) {
            return new Promise(function (resolve, reject) {
                var un = onUrlChanged(function (url, win) {
                    if (url === win.url) {
                        un();
                        if (typeof success === "function") {
                            success(resultWindow);
                        }
                        resolve(resultWindow);
                    }
                });
                executor.navigate(resultWindow, newUrl)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function setStyle(style, success, error) {
            if (!style || Object.keys(style).length === 0 || Object.keys(style).every(function (key) { return !key; })) {
                var errMessage = "Invalid style arguments: " + JSON.stringify(style);
                if (typeof error === "function") {
                    error(errMessage);
                    return;
                }
                return Promise.reject(new Error(errMessage));
            }
            if (style && style.focus !== undefined) {
                if (typeof style.focus !== "boolean") {
                    var errMessage = "Focus must be boolean. Currently only focus true is supported ! " + JSON.stringify(style);
                    if (typeof error === "function") {
                        error(errMessage);
                        return;
                    }
                    return Promise.reject(new Error(errMessage));
                }
                else if (style.focus === false) {
                    _logger.warn("Focus false is not supported!");
                }
            }
            if (style && style.hidden !== undefined && typeof style.hidden !== "boolean") {
                var errMessage = "hidden should be boolean";
                if (typeof error === "function") {
                    error(errMessage);
                    return;
                }
                return Promise.reject(new Error(errMessage));
            }
            for (var _i = 0, _a = ["minHeight", "maxHeight", "minWidth", "maxWidth"]; _i < _a.length; _i++) {
                var prop = _a[_i];
                var styleAsAny = style;
                if (prop in style && !isNumber(styleAsAny[prop])) {
                    var errMessage = prop + " should be number";
                    if (typeof error === "function") {
                        error(errMessage);
                        return;
                    }
                    return Promise.reject(new Error(errMessage));
                }
            }
            return Utils$1.callbackifyPromise(function () { return executor.setStyle(resultWindow, style); }, success, error);
        }
        function resetButtons(buttons, success, error) {
            return Utils$1.callbackifyPromise(function () { return executor.resetButtons(resultWindow, buttons); }, success, error);
        }
        function setOnTop(onTop, success, error) {
            if (this.onTop === onTop) {
                var errMessage = "OnTop setting is already set to '" + onTop + "'";
                error(errMessage);
                return Promise.reject(new Error(errMessage));
            }
            return Utils$1.callbackifyPromise(function () { return executor.setOnTop(resultWindow, onTop); }, success, error);
        }
        function setSizeConstraints(constraints, success, error) {
            if (!constraints || Object.keys(constraints).every(function (value) { return value === undefined; })) {
                var errMessage = "Invalid Constraints: " + JSON.stringify(constraints);
                error(errMessage);
                return Promise.reject(new Error(errMessage));
            }
            return Utils$1.callbackifyPromise(function () { return executor.setSizeConstraints(resultWindow, constraints); }, success, error);
        }
        function setTitle(newTitle, success, error) {
            return new Promise(function (resolve, reject) {
                if (newTitle === _title) {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                    return;
                }
                var un = onTitleChanged(function (title) {
                    if (title === newTitle) {
                        un();
                        if (typeof success === "function") {
                            success(resultWindow);
                        }
                        resolve(resultWindow);
                    }
                });
                executor.setTitle(resultWindow, newTitle)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function setSticky(isSticky, success, error) {
            return new Promise(function (resolve, reject) {
                executor.setSticky(resultWindow, isSticky)
                    .then(function () {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function moveResize(dimensions, success, error) {
            return new Promise(function (resolve, reject) {
                var resolveImmediately = areBoundsEqual(dimensions, _bounds);
                var isDone = false;
                var done = function () {
                    if (isDone) {
                        return;
                    }
                    isDone = true;
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                    if (unsubscribeBoundsChanged) {
                        unsubscribeBoundsChanged();
                        unsubscribeBoundsChanged = undefined;
                    }
                    if (resolveTimeout) {
                        clearTimeout(resolveTimeout);
                        resolveTimeout = undefined;
                    }
                };
                var resolveTimeout;
                var unsubscribeBoundsChanged;
                if (!resolveImmediately) {
                    unsubscribeBoundsChanged = onBoundsChanged(function (win) {
                        if (!areBoundsEqual(dimensions, win.bounds)) {
                            return;
                        }
                        done();
                    });
                }
                executor.moveResize(resultWindow, dimensions)
                    .then(function () {
                    if (resolveImmediately) {
                        done();
                        return;
                    }
                    resolveTimeout = setTimeout(function () {
                        done();
                    }, 1000);
                })
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function addFrameButton(buttonInfo, success, error) {
            return new Promise(function (resolve, reject) {
                if (typeof buttonInfo === "undefined") {
                    if (typeof error === "function") {
                        error("No button info");
                        return;
                    }
                    reject("No button info");
                    return;
                }
                if (buttonInfo.buttonId === undefined) {
                    if (typeof error === "function") {
                        error("No buttonId");
                        return;
                    }
                    reject("No buttonId");
                    return;
                }
                if (buttonInfo.imageBase64 === undefined) {
                    if (typeof error === "function") {
                        error("No imageBase64");
                        return;
                    }
                    reject("No imageBase64");
                    return;
                }
                var un = onFrameButtonAdded(function () {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.addFrameButton(resultWindow, buttonInfo)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function removeFrameButton(buttonId, success, error) {
            return new Promise(function (resolve, reject) {
                if (buttonId === undefined || buttonId === "") {
                    if (typeof error === "function") {
                        error("No buttonId");
                        return;
                    }
                    reject("No buttonId");
                    return;
                }
                var un = onFrameButtonRemoved(function () {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.removeFrameButton(resultWindow, buttonId)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function activate(success, error) {
            return new Promise(function (resolve, reject) {
                if (_focus) {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                    return;
                }
                var un = onFocusChanged(function (win) {
                    if (id === win.id && win.isFocused) {
                        un();
                        if (typeof success === "function") {
                            success(resultWindow);
                        }
                        resolve(resultWindow);
                        return;
                    }
                });
                executor.activate(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function focus(success, error) {
            return new Promise(function (resolve, reject) {
                if (_focus) {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                    return;
                }
                var un = onFocusChanged(function (win) {
                    if (id === win.id && win.isFocused) {
                        un();
                        if (typeof success === "function") {
                            success(resultWindow);
                        }
                        return resolve(resultWindow);
                    }
                });
                executor.focus(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function maximizeRestore(success, error) {
            return new Promise(function (resolve, reject) {
                var currEvent = _windowState === "normal" ? onMaximized : onNormal;
                var un = currEvent(function () {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.maximizeRestore(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function maximize(success, error) {
            return new Promise(function (resolve, reject) {
                if (_windowState === "maximized") {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    return resolve(resultWindow);
                }
                var un = onMaximized(function (win) {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    un();
                    resolve(resultWindow);
                });
                executor.maximize(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function restore(success, error) {
            return new Promise(function (resolve, reject) {
                if (_windowState === "normal") {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    return resolve(resultWindow);
                }
                var un = onNormal(function (win) {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.restore(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function minimize(success, error) {
            return new Promise(function (resolve, reject) {
                if (_windowState === "minimized") {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    return resolve(resultWindow);
                }
                var un = onMinimized(function (win) {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    return resolve(resultWindow);
                });
                executor.minimize(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function collapse(success, error) {
            return new Promise(function (resolve, reject) {
                if (isCollapsed) {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    return resolve(resultWindow);
                }
                var un = onCollapsed(function (win) {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.collapse(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function expand(success, error) {
            return new Promise(function (resolve, reject) {
                if (!isCollapsed) {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    return resolve(resultWindow);
                }
                var un = onExpanded(function () {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.expand(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function toggleCollapse(success, error) {
            return new Promise(function (resolve, reject) {
                var currEvent = isCollapsed ? onExpanded : onCollapsed;
                var un = currEvent(function () {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.toggleCollapse(resultWindow)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function snap(target, direction, success, error) {
            return __awaiter(this, void 0, void 0, function () {
                var targetWindowGroup, e, targetWindow, e;
                return __generator(this, function (_a) {
                    if (!target) {
                        e = new Error("Please specify a target window - " + target);
                        if (typeof error === "function") {
                            error(e.message);
                            return [2];
                        }
                        throw e;
                    }
                    if (typeof target === "string") {
                        targetWindow = windowStore.get(target);
                        if (!targetWindow) {
                            e = new Error("Invalid target parameter or no such window. Invoked with:  " + target);
                            if (typeof error === "function") {
                                error(e.message);
                                return [2];
                            }
                            throw e;
                        }
                        targetWindowGroup = targetWindow.API.group;
                    }
                    else {
                        targetWindowGroup = target.group;
                    }
                    return [2, Promise.all([
                            waitForMyWindowToJoinTargetGroup(targetWindowGroup),
                            executor.snap(resultWindow, target, direction)
                        ])
                            .then(function () {
                            if (typeof success === "function") {
                                success(resultWindow);
                            }
                            return resultWindow;
                        })
                            .catch(function (e) {
                            if (typeof error === "function") {
                                error(e);
                            }
                            return e;
                        })];
                });
            });
        }
        function waitForMyWindowToJoinTargetGroup(targetGroup) {
            return new Promise(function (resolve, reject) {
                var unsub = targetGroup.onWindowAdded(function (_, window) {
                    if (resultWindow.id === window.id) {
                        unsub();
                        resolve();
                    }
                });
            });
        }
        function attachTab(tab, index, success, error) {
            return new Promise(function (resolve, reject) {
                var sourceWindowId;
                var targetWindowId = resultWindow.id;
                var errorMessage = "Invalid tab parameter - should be an object with property id or a string. Invoked for source window id:" + resultWindow.id;
                if (!tab) {
                    reject(errorMessage);
                    return;
                }
                if (typeof tab === "string") {
                    sourceWindowId = tab;
                }
                else if (typeof tab.id !== "undefined") {
                    sourceWindowId = tab.id;
                }
                else {
                    reject(errorMessage);
                    return;
                }
                var argsForSend = {
                    sourceWindowId: sourceWindowId,
                    targetWindowId: targetWindowId,
                };
                if (index) {
                    argsForSend.index = index;
                }
                var sourceWin = windowStore.get(argsForSend.sourceWindowId).API;
                var un = sourceWin.onAttached(function (win) {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.attachTab(resultWindow, argsForSend)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    un();
                    reject(e);
                });
            });
        }
        function detachTab(opt, success, error) {
            return new Promise(function (resolve, reject) {
                var argsForSend = { windowId: resultWindow.id };
                var _options = opt || {};
                if (typeof _options.relativeTo !== "undefined") {
                    if (typeof _options.relativeTo === "string") {
                        argsForSend.relativeTo = _options.relativeTo;
                    }
                    else if (typeof _options.relativeTo.id !== "undefined") {
                        argsForSend.relativeTo = _options.relativeTo.id;
                    }
                    if (typeof _options.relativeDirection !== "undefined") {
                        argsForSend.relativeDirection = _options.relativeDirection;
                    }
                    if (typeof _options.width !== "undefined") {
                        argsForSend.width = _options.width;
                    }
                    if (typeof _options.height !== "undefined") {
                        argsForSend.height = _options.height;
                    }
                }
                if (typeof _options.bounds !== "undefined") {
                    argsForSend.bounds = _options.bounds;
                }
                if (typeof _options.hideTabHeader !== "undefined") {
                    argsForSend.hideTabHeader = _options.hideTabHeader;
                }
                var visibilityChangeHeard = false;
                var detachedHeard = false;
                var unVisibility = _registry.add("frame-attached", (function (win) {
                    var isVisibilityCorrect = _options.hideTabHeader === undefined || _options.hideTabHeader !== win.isTabHeaderVisible;
                    if (id === win.id && isVisibilityCorrect) {
                        visibilityChangeHeard = true;
                        unVisibility();
                        if (detachedHeard) {
                            if (typeof success === "function") {
                                success(resultWindow);
                            }
                            resolve(resultWindow);
                            if (typeof unDetached === "function") {
                                unDetached();
                            }
                        }
                    }
                }));
                var unDetached = onDetached(function (win) {
                    if (id === win.id) {
                        detachedHeard = true;
                        unDetached();
                        if (visibilityChangeHeard) {
                            if (typeof success === "function") {
                                success(resultWindow);
                            }
                            resolve(resultWindow);
                            if (typeof unVisibility === "function") {
                                unVisibility();
                            }
                        }
                    }
                });
                executor.detachTab(resultWindow, argsForSend)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    unDetached();
                    unVisibility();
                    reject(e);
                });
            });
        }
        function setVisible(toBeVisible, success, error) {
            return new Promise(function (resolve, reject) {
                if (toBeVisible === _isVisible) {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    return resolve(resultWindow);
                }
                var un = onVisibilityChanged(function (win) {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    un();
                    resolve(resultWindow);
                });
                executor.setVisible(resultWindow, toBeVisible)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function showLoader(loader) {
            return new Promise(function (resolve, reject) {
                executor.showLoader(resultWindow, loader)
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        }
        function hideLoader() {
            return new Promise(function (resolve, reject) {
                executor.hideLoader(resultWindow)
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        }
        function updateContext(context, success, error) {
            return new Promise(function (resolve, reject) {
                var un = onContextUpdated(function () {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.updateContext(resultWindow, context)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function lock(success, error) {
            if (resultWindow.isLocked) {
                if (typeof success === "function") {
                    success(resultWindow);
                }
                return Promise.resolve(resultWindow);
            }
            return new Promise(function (resolve, reject) {
                executor.lock(resultWindow)
                    .then(function () { return waitForLockingChanged(); })
                    .then(function () {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function unlock(success, error) {
            if (!resultWindow.isLocked) {
                if (typeof success === "function") {
                    success(resultWindow);
                }
                return Promise.resolve(resultWindow);
            }
            return new Promise(function (resolve, reject) {
                executor.unlock(resultWindow)
                    .then(function () { return waitForLockingChanged(); })
                    .then(function () {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function waitForLockingChanged() {
            return new Promise(function (resolve) {
                var un = onLockingChanged(function (window) {
                    if (window.id === resultWindow.id) {
                        un();
                        resolve();
                    }
                });
            });
        }
        function getIcon(success, error) {
            return new Promise(function (resolve, reject) {
                executor.getIcon(resultWindow)
                    .then(function (icon) {
                    if (typeof success === "function") {
                        success(icon);
                    }
                    resolve(icon);
                })
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function setIcon(base64Image, success, error) {
            return new Promise(function (resolve, reject) {
                executor.setIcon(resultWindow, base64Image)
                    .then(function () {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function setFrameColor(frameColor, success, error) {
            return new Promise(function (resolve, reject) {
                var un = onFrameColorChanged(function () {
                    un();
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    resolve(resultWindow);
                });
                executor.setFrameColor(resultWindow, frameColor)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function setTabHeaderVisible(toBeTabHeaderVisible, success, error) {
            return new Promise(function (resolve, reject) {
                if (_isTabHeaderVisible === toBeTabHeaderVisible) {
                    if (typeof success === "function") {
                        success(resultWindow);
                    }
                    return resolve(resultWindow);
                }
                var un = onTabHeaderVisibilityChanged(function (win) {
                    if (win.id === id && win.isTabHeaderVisible === toBeTabHeaderVisible) {
                        if (typeof success === "function") {
                            success(resultWindow);
                        }
                        un();
                        resolve(resultWindow);
                    }
                });
                executor.setTabHeaderVisible(resultWindow, toBeTabHeaderVisible)
                    .catch(function (e) {
                    if (typeof error === "function") {
                        error(e);
                    }
                    reject(e);
                });
            });
        }
        function setTabTooltip(tooltip) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (!tooltip) {
                        throw new Error(tooltip + " is null or undefined");
                    }
                    return [2, executor.setTabTooltip(resultWindow, tooltip)];
                });
            });
        }
        function showPopup(config) {
            return executor.showPopup(resultWindow, config);
        }
        function createFlydown(config) {
            return executor.createFlydown(resultWindow.id, config);
        }
        function setModalState(isModal) {
            return executor.setModalState(resultWindow.id, isModal || false);
        }
        function zoomIn(success, error) {
            return Utils$1.callbackifyPromise(function () {
                return executor.zoomIn(resultWindow);
            }, success, error);
        }
        function zoomOut(success, error) {
            return Utils$1.callbackifyPromise(function () {
                return executor.zoomOut(resultWindow);
            }, success, error);
        }
        function setZoomFactor(zoomFactor, success, error) {
            return Utils$1.callbackifyPromise(function () {
                if (isNaN(zoomFactor)) {
                    throw new Error("zoomFactor is not a number");
                }
                return executor.setZoomFactor(resultWindow, zoomFactor);
            }, success, error);
        }
        function showDevTools() {
            return executor.showDevTools(resultWindow);
        }
        function capture(captureOptions) {
            return executor.capture(resultWindow, captureOptions);
        }
        function flash(suppliedOptions, mode) {
            var flashOptions = {
                shouldFlash: true,
                mode: "auto"
            };
            if (typeof suppliedOptions === "boolean") {
                flashOptions.shouldFlash = suppliedOptions;
            }
            if (typeof mode !== "undefined") {
                flashOptions.mode = mode;
            }
            return executor.flash(resultWindow, flashOptions);
        }
        function print(printOptions) {
            return executor.print(resultWindow, printOptions);
        }
        function printToPDF(printToPDFOptions) {
            return executor.printToPDF(resultWindow, printToPDFOptions);
        }
        function ungroup(ungroupOptions) {
            return new Promise(function (resolve, reject) {
                var unGroupChanged = onGroupChanged(function (win, newGroup, oldGroup) {
                    if (id === win.id) {
                        unGroupChanged();
                        resolve(resultWindow);
                    }
                });
                executor.ungroup(resultWindow, ungroupOptions)
                    .catch(function (e) {
                    unGroupChanged();
                    reject(e);
                });
            });
        }
        function place(placementSettings) {
            return executor.place(resultWindow, placementSettings);
        }
        function onTitleChanged(callback) {
            callback(resultWindow.title, resultWindow);
            return _registry.add("onTitleChanged", callback);
        }
        function onClose(callback) {
            return _registry.add("onClose", callback);
        }
        function onUrlChanged(callback) {
            return _registry.add("onUrlChanged", callback);
        }
        function onFrameButtonAdded(callback) {
            return _registry.add("onFrameButtonAdded", callback);
        }
        function onFrameButtonRemoved(callback) {
            return _registry.add("onFrameButtonRemoved", callback);
        }
        function onFrameButtonClicked(callback) {
            return _registry.add("onFrameButtonClicked", callback);
        }
        function onCollapsed(callback) {
            if (isCollapsed) {
                callback(resultWindow);
            }
            return _registry.add("collapsed", callback);
        }
        function onExpanded(callback) {
            if (!isCollapsed) {
                callback(resultWindow);
            }
            return _registry.add("expanded", callback);
        }
        function onMaximized(callback) {
            if (_windowState === "maximized") {
                callback(resultWindow);
            }
            return _registry.add("maximized", callback);
        }
        function onMinimized(callback) {
            if (_windowState === "minimized") {
                callback(resultWindow);
            }
            return _registry.add("minimized", callback);
        }
        function onNormal(callback) {
            if (_windowState === "normal") {
                callback(resultWindow);
            }
            return _registry.add("normal", callback);
        }
        function onAttached(callback) {
            return _registry.add("attached", callback);
        }
        function onDetached(callback) {
            return _registry.add("detached", callback);
        }
        function onVisibilityChanged(callback) {
            return _registry.add("visibility-changed", callback);
        }
        function onContextUpdated(callback) {
            return _registry.add("context-updated", callback);
        }
        function onLockingChanged(callback) {
            return _registry.add("lock-changed", callback);
        }
        function onBoundsChanged(callback) {
            return _registry.add("bounds-changed", callback);
        }
        function onFocusChanged(callback) {
            return _registry.add("focus-changed", callback);
        }
        function onStickyChanged(callback) {
            return _registry.add("sticky-changed", callback);
        }
        function onFrameColorChanged(callback) {
            return _registry.add("frame-color-changed", callback);
        }
        function onTabHeaderVisibilityChanged(callback) {
            return _registry.add("tab-header-visibility-changed", callback);
        }
        function onWindowAttached(callback) {
            return _registry.add("window-attached", callback);
        }
        function onWindowDetached(callback) {
            return _registry.add("window-detached", callback);
        }
        function onGroupChanged(callback) {
            return _registry.add("group-changed", callback);
        }
        function onTabSelectionChanged(callback) {
            return _registry.add("tab-selection-changed", callback);
        }
        function onClosing(callback) {
            if (!isFunction(callback)) {
                throw new Error("callback should be a function");
            }
            var callbackWrap = function (success, error) {
                var promise = callback();
                if (promise && promise.then) {
                    promise.then(success).catch(error);
                }
                else {
                    success();
                }
            };
            return executor.onClosing(callbackWrap, id);
        }
        function onRefreshing(callback) {
            if (!isFunction(callback)) {
                throw new Error("callback should be a function");
            }
            var callbackWrap = function (success, error, prevent) {
                var promise = callback(prevent);
                if (promise && promise.then) {
                    promise.then(success).catch(error);
                }
                else {
                    success();
                }
            };
            return executor.onRefreshing(callbackWrap, id);
        }
        function onZoomFactorChanged(callback) {
            if (!isFunction(callback)) {
                throw new Error("callback should be a function");
            }
            return _registry.add("zoom-factor-changed", callback);
        }
        function onPlacementSettingsChanged(callback) {
            if (!isFunction(callback)) {
                throw new Error("callback should be a function");
            }
            return _registry.add("placementSettingsChanged", callback);
        }
        function onNeighboursChanged(callback) {
            if (!isFunction(callback)) {
                throw new Error("callback should be a function");
            }
            return _registry.add("neighbours-changed", callback);
        }
        function handleTitleChanged(newTitle) {
            _title = newTitle;
            _registry.execute("onTitleChanged", newTitle, resultWindow);
        }
        function handleUrlChanged(newUrl) {
            _url = newUrl;
            _registry.execute("onUrlChanged", newUrl, resultWindow);
        }
        function handleVisibilityChanged(isVisible) {
            if (isVisible === _isVisible) {
                return;
            }
            _isVisible = isVisible;
            _registry.execute("visibility-changed", resultWindow);
        }
        function handleWindowSettingsChanged(settings) {
            _settings = settings;
            _registry.execute("settings-changed", resultWindow);
        }
        function handleContextUpdated(context) {
            _context = context;
            _registry.execute("context-updated", _context, resultWindow);
        }
        function handleWindowClose() {
            if (resultWindow.id === undefined) {
                return;
            }
            _registry.execute("onClose", resultWindow);
            resultWindow.id = undefined;
        }
        function handleFrameButtonAdded(frameButton) {
            var buttonObj = ["buttonId", "imageBase64", "order", "tooltip"].reduce(function (memo, k) {
                memo[k] = frameButton[k];
                return memo;
            }, {});
            var frameButtonsIds = _frameButtons.map(function (btn) {
                return btn.buttonId;
            });
            if (frameButtonsIds.indexOf(frameButton.buttonId) === -1) {
                _frameButtons.push(buttonObj);
            }
            _registry.execute("onFrameButtonAdded", buttonObj, resultWindow);
        }
        function handleFrameButtonRemoved(frameButtonId) {
            var button;
            _frameButtons = _frameButtons.reduce(function (memo, btn) {
                if (btn.buttonId === frameButtonId) {
                    button = btn;
                }
                else {
                    memo.push(btn);
                }
                return memo;
            }, []);
            if (button !== undefined) {
                _registry.execute("onFrameButtonRemoved", button, resultWindow);
            }
        }
        function handleFrameButtonClicked(frameButton) {
            var button = _frameButtons.filter(function (btn) {
                return btn.buttonId === frameButton.buttonId;
            });
            if (button.length > 0) {
                _registry.execute("onFrameButtonClicked", button[0], resultWindow);
            }
        }
        function handleWindowChangeState(state) {
            if (state === "collapsed") {
                isCollapsed = true;
            }
            else if (state === "expanded") {
                isCollapsed = false;
            }
            else {
                _windowState = state;
            }
            _registry.execute(state, resultWindow);
        }
        function handleFrameIsLockedChanged(isLocked) {
            _isLocked = isLocked;
            _registry.execute("lock-changed", resultWindow);
        }
        function handleBoundsChanged(bounds) {
            if (_bounds.top === bounds.top && _bounds.left === bounds.left && _bounds.width === bounds.width && _bounds.height === bounds.height) {
                return;
            }
            _bounds.top = bounds.top;
            _bounds.left = bounds.left;
            _bounds.width = bounds.width;
            _bounds.height = bounds.height;
            _registry.execute("bounds-changed", resultWindow);
        }
        function handleFocusChanged(isFocused) {
            _focus = isFocused;
            _registry.execute("focus-changed", resultWindow);
        }
        function handleIsStickyChanged(isSticky) {
            _isSticky = isSticky;
            _registry.execute("sticky-changed", isSticky, resultWindow);
        }
        function handleFrameColorChanged(frameColor) {
            _frameColor = frameColor;
            _registry.execute("frame-color-changed", resultWindow);
        }
        function handleFrameAttached(tabGroupId, isTabHeaderVisible) {
            _tabGroupId = tabGroupId;
            _isTabHeaderVisible = isTabHeaderVisible;
            _registry.execute("frame-attached", resultWindow);
        }
        function handleCompositionChanged(neighbours, groupId) {
            _neighbours = neighbours || {};
            _registry.execute("neighbours-changed", neighbours, resultWindow);
            _groupId = groupId;
            if (resultWindow.groupId !== groupId) {
                _registry.execute("group-changed", resultWindow);
            }
        }
        function handleGroupHeaderVisibilityChanged(isGroupHeaderVisible) {
            _isGroupHeaderVisible = isGroupHeaderVisible;
        }
        function handleTabHeaderVisibilityChanged(isTabHeaderVisible) {
            if (_isTabHeaderVisible !== isTabHeaderVisible) {
                _isTabHeaderVisible = isTabHeaderVisible;
                _registry.execute("tab-header-visibility-changed", resultWindow);
            }
        }
        function handleFrameSelectionChanged(newWindow, prevWindow) {
            var selectedWindow;
            if (typeof newWindow !== "undefined" && newWindow === id) {
                _isTabSelected = true;
                selectedWindow = resultWindow;
            }
            else {
                _isTabSelected = false;
                selectedWindow = windowStore.get(newWindow) ? windowStore.get(newWindow).API : undefined;
            }
            var previousWindow = windowStore.get(prevWindow) ? windowStore.get(prevWindow).API : undefined;
            if (_isTabSelected && previousWindow) {
                var un_1 = previousWindow.onTabSelectionChanged(function (newWin, prevWin) {
                    if ((prevWin && prevWin.id) === previousWindow.id) {
                        un_1();
                        _registry.execute("tab-selection-changed", selectedWindow, previousWindow, resultWindow);
                    }
                });
            }
            else {
                _registry.execute("tab-selection-changed", selectedWindow, previousWindow, resultWindow);
            }
        }
        function handleAttached(newTabGroupId, tabHeaderVisible) {
            _tabGroupId = newTabGroupId;
            _isTabHeaderVisible = tabHeaderVisible;
            _registry.execute("attached", resultWindow);
        }
        function handleWindowAttached(win) {
            _registry.execute("window-attached", win);
        }
        function handleDetached(tabGroupId) {
            _tabGroupId = tabGroupId;
            var un = _registry.add("frame-attached", function (win) {
                if (win.id === id) {
                    un();
                    _registry.execute("detached", resultWindow);
                }
            });
        }
        function handleWindowDetached(win) {
            _registry.execute("window-detached", win);
        }
        function handleZoomFactorChanged(zoomFactor) {
            _zoomFactor = zoomFactor;
            _registry.execute("zoom-factor-changed", resultWindow);
        }
        function handlePlacementSettingsChanged(placementSettings) {
            var promise;
            var copy = placementSettings;
            if (!copy.display) {
                promise = Promise.resolve(undefined);
            }
            else {
                var displayAPI_1 = displayAPIGetter();
                if (!displayAPI_1) {
                    promise = Promise.resolve(undefined);
                }
                else {
                    var index_1 = copy.display - 1;
                    promise = new Promise(function (resolve, reject) {
                        displayAPI_1.all().then(function (displays) {
                            var display = displays.find(function (d) { return d.index === index_1; });
                            resolve(display);
                        }).catch(reject);
                    });
                }
            }
            promise.then(function (d) {
                copy.display = d;
                _placementSettings = copy;
                _registry.execute("placementSettingsChanged", resultWindow);
            });
        }
        function handleGroupChanged(newGroup, oldGroup) {
            _logger.trace("handle group changed to win: " + id + " with group id: " + newGroup.id);
            _group = newGroup;
            _groupId = newGroup.id;
            _registry.execute("group-changed", resultWindow, newGroup, oldGroup);
        }
        function handleGroupAssociation(group) {
            if (group) {
                _logger.trace("setting group to win: " + id + " with group id: " + group.id);
            }
            _group = group;
        }
        function getAllTabs() {
            var allWindows = windowStore.list;
            if (_mode.toLowerCase() !== "tab") {
                return [];
            }
            return Object.keys(allWindows).reduce(function (memo, win) {
                var window = allWindows[win];
                if (window
                    && window.API.tabGroupId
                    && typeof window.API.tabGroupId !== "undefined"
                    && typeof resultWindow.tabGroupId !== "undefined"
                    && window.API.tabGroupId === resultWindow.tabGroupId) {
                    memo.push(window.API);
                }
                return memo;
            }, []);
        }
        function mapWindowIdsToWindowObjects(windowIdArr) {
            return windowIdArr.reduce(function (memo, winId) {
                var window = windowStore.get(winId);
                if (window) {
                    memo.push(window.API);
                }
                return memo;
            }, []);
        }
        function getNeighboursByDirection(direction) {
            var windowIds = _neighbours[direction];
            if (typeof windowIds !== "undefined") {
                return mapWindowIdsToWindowObjects(windowIds);
            }
        }
        function getApplicationName() {
            if (_context._APPLICATION_NAME) {
                return _context._APPLICATION_NAME;
            }
            if (_context && _context._t42 && _context._t42.application) {
                return _context._t42.application;
            }
            var info = getWindowInfo();
            if (!info) {
                return undefined;
            }
            return info.applicationName;
        }
        function getWindowInfo() {
            if (typeof window !== "undefined" && window.glue42gd && window.glue42gd.getWindowInfo) {
                var info = window.glue42gd.getWindowInfo(id);
                if (!info) {
                    return undefined;
                }
                else {
                    return info;
                }
            }
        }
        function areBoundsEqual(requested, current) {
            var height = requested.height;
            var width = requested.width;
            if (requested.height < _settings.minHeight) {
                height = _settings.minHeight;
            }
            if (requested.height > _settings.maxHeight) {
                height = _settings.maxHeight;
            }
            if (requested.width < _settings.minWidth) {
                width = _settings.minWidth;
            }
            if (requested.width > _settings.maxWidth) {
                width = _settings.maxWidth;
            }
            var areHeightsEqual = height ? current.height === height : true;
            var areWidthsEqual = width ? current.width === width : true;
            var areLeftsEqual = requested.left ? current.left === requested.left : true;
            var areTopsEqual = requested.top ? current.top === requested.top : true;
            return areHeightsEqual && areWidthsEqual && areLeftsEqual && areTopsEqual;
        }
        resultWindow = {
            get name() {
                return _name;
            },
            get application() {
                var appManager = appManagerGetter();
                return appManager ? appManager.application(getApplicationName()) : undefined;
            },
            get hostInstance() {
                return executor.hostInstance;
            },
            get agmInstance() {
                var _this = this;
                if (typeof window !== "undefined" && window.glue42gd) {
                    return agm.servers().find(function (s) { return s.windowId === _this.id; });
                }
                var appName = getApplicationName();
                return appName ? { application: appName } : undefined;
            },
            get url() {
                return _url;
            },
            id: id,
            get title() {
                return _title;
            },
            get windowStyleAttributes() {
                return _settings;
            },
            get settings() {
                return _settings;
            },
            get tabGroupId() {
                return _mode.toLowerCase() === "tab" ? _tabGroupId : undefined;
            },
            get frameButtons() {
                return _frameButtons;
            },
            get mode() {
                return _mode;
            },
            get state() {
                return _windowState;
            },
            get isCollapsed() {
                return isCollapsed;
            },
            get isVisible() {
                return _isVisible;
            },
            get isLocked() {
                return _isLocked;
            },
            get context() {
                return _context;
            },
            get bounds() {
                return _bounds;
            },
            get minHeight() {
                return _settings.minHeight;
            },
            get maxHeight() {
                return _settings.maxHeight;
            },
            get minWidth() {
                return _settings.minWidth;
            },
            get maxWidth() {
                return _settings.maxWidth;
            },
            get isFocused() {
                return _focus;
            },
            get frameColor() {
                return _frameColor;
            },
            get opened() {
                return resultWindow.id !== undefined;
            },
            get group() {
                return _group;
            },
            get groupId() {
                return _groupId;
            },
            get isSticky() {
                return _isSticky;
            },
            get topNeighbours() {
                return getNeighboursByDirection("top");
            },
            get leftNeighbours() {
                return getNeighboursByDirection("left");
            },
            get rightNeighbours() {
                return getNeighboursByDirection("right");
            },
            get bottomNeighbours() {
                return getNeighboursByDirection("bottom");
            },
            get isGroupHeaderVisible() {
                return _isGroupHeaderVisible;
            },
            get activityId() {
                if (_context._t42) {
                    return _context._t42.activityId;
                }
                var info = getWindowInfo();
                if (!info) {
                    return undefined;
                }
                return info.activityId;
            },
            get activityWindowId() {
                if (_context._t42) {
                    return _context._t42.activityWindowId;
                }
                var info = getWindowInfo();
                if (!info) {
                    return undefined;
                }
                return info.activityWindowId;
            },
            get windowType() {
                return options.windowType || "electron";
            },
            get zoomFactor() {
                return _zoomFactor;
            },
            get screen() {
                if (typeof window !== "undefined" && window.glue42gd) {
                    return Utils$1.getMonitor(resultWindow.bounds, window.glue42gd.monitors);
                }
                return undefined;
            },
            get placementSettings() {
                return Object.assign({}, _placementSettings);
            },
            maximize: maximize,
            restore: restore,
            minimize: minimize,
            maximizeRestore: maximizeRestore,
            collapse: collapse,
            expand: expand,
            toggleCollapse: toggleCollapse,
            focus: focus,
            activate: activate,
            moveResize: moveResize,
            setTitle: setTitle,
            setStyle: setStyle,
            setOnTop: setOnTop,
            resetButtons: resetButtons,
            setSizeConstraints: setSizeConstraints,
            navigate: navigate,
            addFrameButton: addFrameButton,
            removeFrameButton: removeFrameButton,
            setVisible: setVisible,
            show: function () { return setVisible(true); },
            hide: function () { return setVisible(false); },
            center: function (screen) { return moveResize(Utils$1.getDisplayCenterOfScreen(resultWindow.bounds, screen || resultWindow.screen)); },
            close: close,
            snap: snap,
            showLoader: showLoader,
            hideLoader: hideLoader,
            updateContext: updateContext,
            lock: lock,
            unlock: unlock,
            getIcon: getIcon,
            setIcon: setIcon,
            setFrameColor: setFrameColor,
            setTabTooltip: setTabTooltip,
            attachTab: attachTab,
            detachTab: detachTab,
            setTabHeaderVisible: setTabHeaderVisible,
            showPopup: showPopup,
            createFlydown: createFlydown,
            setModalState: setModalState,
            setZoomFactor: setZoomFactor,
            zoomIn: zoomIn,
            zoomOut: zoomOut,
            showDevTools: showDevTools,
            capture: capture,
            flash: flash,
            setSticky: setSticky,
            print: print,
            printToPDF: printToPDF,
            place: place,
            ungroup: ungroup,
            onClose: onClose,
            onUrlChanged: onUrlChanged,
            onTitleChanged: onTitleChanged,
            onFrameButtonAdded: onFrameButtonAdded,
            onFrameButtonRemoved: onFrameButtonRemoved,
            onFrameButtonClicked: onFrameButtonClicked,
            onCollapsed: onCollapsed,
            onExpanded: onExpanded,
            onMinimized: onMinimized,
            onMaximized: onMaximized,
            onNormal: onNormal,
            onAttached: onAttached,
            onDetached: onDetached,
            onVisibilityChanged: onVisibilityChanged,
            onContextUpdated: onContextUpdated,
            onLockingChanged: onLockingChanged,
            onBoundsChanged: onBoundsChanged,
            onFrameColorChanged: onFrameColorChanged,
            onFocusChanged: onFocusChanged,
            onStickyChanged: onStickyChanged,
            onGroupChanged: onGroupChanged,
            onWindowAttached: onWindowAttached,
            onWindowDetached: onWindowDetached,
            onTabSelectionChanged: onTabSelectionChanged,
            onTabHeaderVisibilityChanged: onTabHeaderVisibilityChanged,
            onClosing: onClosing,
            onRefreshing: onRefreshing,
            onZoomFactorChanged: onZoomFactorChanged,
            onPlacementSettingsChanged: onPlacementSettingsChanged,
            onNeighboursChanged: onNeighboursChanged,
            get tabs() {
                return getAllTabs();
            },
            get isTabHeaderVisible() {
                return _isTabHeaderVisible;
            },
            get isTabSelected() {
                return _isTabSelected;
            },
            getURL: function () {
                return Promise.resolve(_url);
            },
            getTitle: function () {
                return Promise.resolve(_title);
            },
            getBounds: function () {
                return Promise.resolve(_bounds);
            },
            getContext: function () {
                return Promise.resolve(_context);
            },
            setContext: function (context) {
                return updateContext(context);
            },
            resizeTo: function (width, height) {
                return moveResize({ width: width, height: height });
            },
            moveTo: function (top, left) {
                return moveResize({ top: top, left: left });
            },
            getParentWindow: function () {
                var _a;
                return __awaiter(this, void 0, void 0, function () {
                    var myParentId;
                    return __generator(this, function (_b) {
                        myParentId = _settings.parentInstanceId;
                        if (!myParentId) {
                            return [2, undefined];
                        }
                        return [2, (_a = windowStore.list[myParentId]) === null || _a === void 0 ? void 0 : _a.API];
                    });
                });
            },
            getChildWindows: function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2, Object.keys(windowStore.list)
                                .map(function (key) { return windowStore.list[key].API; })
                                .filter(function (w) {
                                var parentId = w.settings.parentInstanceId;
                                return parentId === id;
                            })];
                    });
                });
            }
        };
        var events = {
            handleWindowClose: handleWindowClose,
            handleWindowChangeState: handleWindowChangeState,
            handleTitleChanged: handleTitleChanged,
            handleVisibilityChanged: handleVisibilityChanged,
            handleUrlChanged: handleUrlChanged,
            handleWindowSettingsChanged: handleWindowSettingsChanged,
            handleContextUpdated: handleContextUpdated,
            handleFrameIsLockedChanged: handleFrameIsLockedChanged,
            handleBoundsChanged: handleBoundsChanged,
            handleFocusChanged: handleFocusChanged,
            handleFrameButtonAdded: handleFrameButtonAdded,
            handleFrameButtonRemoved: handleFrameButtonRemoved,
            handleFrameButtonClicked: handleFrameButtonClicked,
            handleFrameColorChanged: handleFrameColorChanged,
            handleFrameAttached: handleFrameAttached,
            handleFrameSelectionChanged: handleFrameSelectionChanged,
            handleCompositionChanged: handleCompositionChanged,
            handleGroupHeaderVisibilityChanged: handleGroupHeaderVisibilityChanged,
            handleTabHeaderVisibilityChanged: handleTabHeaderVisibilityChanged,
            handleGroupChanged: handleGroupChanged,
            handleGroupAssociation: handleGroupAssociation,
            handleAttached: handleAttached,
            handleDetached: handleDetached,
            handleWindowAttached: handleWindowAttached,
            handleWindowDetached: handleWindowDetached,
            handleZoomFactorChanged: handleZoomFactorChanged,
            handleIsStickyChanged: handleIsStickyChanged,
            handlePlacementSettingsChanged: handlePlacementSettingsChanged,
        };
        return {
            API: resultWindow,
            Events: events,
            Registry: _registry
        };
    });

    var GDExecutor = (function () {
        function GDExecutor() {
            this._registry = lib$2();
        }
        Object.defineProperty(GDExecutor.prototype, "hostInstance", {
            get: function () {
                return this.agmTarget;
            },
            enumerable: true,
            configurable: true
        });
        GDExecutor.prototype.init = function (agm, instance) {
            this.agm = agm;
            this.agmTarget = instance;
        };
        GDExecutor.prototype.close = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("close", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.navigate = function (resultWindow, newUrl) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("navigate", {
                    windowId: resultWindow.id,
                    options: {
                        url: newUrl
                    }
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.setStyle = function (resultWindow, style) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var stylePromises, wait, toBeVisible, toolTip, maxWidth, maxHeight, minWidth, minHeight, allowClose, allowCollapse, allowLockUnlock, allowMaximize, allowMinimize;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            stylePromises = [];
                            wait = function (promise) { return stylePromises.push(promise); };
                            if (style.focus !== undefined && !resultWindow.isFocused) {
                                wait(resultWindow.focus());
                            }
                            if (style.hidden !== undefined) {
                                toBeVisible = !style.hidden;
                                wait(resultWindow.setVisible(toBeVisible));
                            }
                            if (style.onTop !== undefined) {
                                wait(resultWindow.setOnTop(style.onTop));
                            }
                            if (style.tabTooltip !== undefined || style.tabToolTip !== undefined) {
                                toolTip = (_a = style.tabTooltip, (_a !== null && _a !== void 0 ? _a : style.tabToolTip));
                                wait(resultWindow.setTabTooltip(toolTip));
                            }
                            maxWidth = style.maxWidth, maxHeight = style.maxHeight, minWidth = style.minWidth, minHeight = style.minHeight, allowClose = style.allowClose, allowCollapse = style.allowCollapse, allowLockUnlock = style.allowLockUnlock, allowMaximize = style.allowMaximize, allowMinimize = style.allowMinimize;
                            wait(resultWindow.setSizeConstraints({ maxWidth: maxWidth, maxHeight: maxHeight, minWidth: minWidth, minHeight: minHeight }));
                            wait(resultWindow.resetButtons({ allowClose: allowClose, allowCollapse: allowCollapse, allowLockUnlock: allowLockUnlock, allowMaximize: allowMaximize, allowMinimize: allowMinimize }));
                            return [4, Promise.all(stylePromises)];
                        case 1:
                            _b.sent();
                            return [2, resultWindow];
                    }
                });
            });
        };
        GDExecutor.prototype.setSizeConstraints = function (resultWindow, constraints) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("setSizeConstraints", {
                    windowId: resultWindow.id,
                    options: constraints
                }).then(function () {
                    resolve(resultWindow);
                }).catch(reject);
            });
        };
        GDExecutor.prototype.setTabTooltip = function (w, tabToolTip) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("setTabTooltip", { windowId: w.id, options: { tabToolTip: tabToolTip } })];
                        case 1:
                            _a.sent();
                            return [2, w];
                    }
                });
            });
        };
        GDExecutor.prototype.resetButtons = function (resultWindow, buttonsConfig) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("resetButtons", {
                    windowId: resultWindow.id,
                    options: buttonsConfig
                }).then(function () {
                    resolve(resultWindow);
                }).catch(reject);
            });
        };
        GDExecutor.prototype.setOnTop = function (resultWindow, onTop) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("setOnTop", {
                    windowId: resultWindow.id,
                    options: { onTop: onTop }
                }).then(function () {
                    resolve(resultWindow);
                }).catch(reject);
            });
        };
        GDExecutor.prototype.setTitle = function (resultWindow, newTitle) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var options = {
                    windowId: resultWindow.id,
                    options: {
                        title: newTitle
                    }
                };
                _this.execute("setTitle", options)
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.setSticky = function (resultWindow, isSticky) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var options = {
                    windowId: resultWindow.id,
                    options: {
                        isSticky: isSticky
                    }
                };
                _this.execute("setSticky", options)
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.moveResize = function (resultWindow, dimensions) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("moveResize", {
                    windowId: resultWindow.id,
                    options: {
                        bounds: dimensions
                    }
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.addFrameButton = function (resultWindow, buttonInfo) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("addButton", {
                    windowId: resultWindow.id,
                    options: buttonInfo
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.removeFrameButton = function (resultWindow, buttonId) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("removeButton", {
                    windowId: resultWindow.id,
                    options: buttonId
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.activate = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("activate", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.focus = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("focus", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.maximizeRestore = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("maximizeRestore", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.maximize = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("maximize", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.restore = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("restore", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.minimize = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("minimize", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.collapse = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("collapse", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.expand = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("expand", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.toggleCollapse = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("toggleCollapse", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.snap = function (resultWindow, target, direction) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var sourceWindowId = resultWindow.id;
                var targetWindowId;
                var errorMessage = "Invalid target parameter - should be an object with property id or a string. Invoked for source window id:" +
                    resultWindow.id;
                if (!target) {
                    reject(errorMessage);
                    return;
                }
                if (typeof target === "string") {
                    targetWindowId = target;
                }
                else if (typeof target.id !== "undefined") {
                    targetWindowId = target.id;
                }
                else {
                    reject(errorMessage);
                    return;
                }
                var args = {
                    targetWindowId: targetWindowId
                };
                if (direction) {
                    args.snappingEdge = direction;
                }
                _this.execute("snap", {
                    windowId: resultWindow.id,
                    options: args
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.attachTab = function (resultWindow, options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("attachTab", {
                    windowId: resultWindow.id,
                    options: options
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.detachTab = function (resultWindow, options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("detachTab", {
                    windowId: resultWindow.id,
                    options: options
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.setVisible = function (resultWindow, toBeVisible) {
            var _this = this;
            if (toBeVisible === void 0) { toBeVisible = true; }
            return new Promise(function (resolve, reject) {
                var command;
                if (toBeVisible) {
                    command = "show";
                }
                else {
                    command = "hide";
                }
                _this.execute(command, { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.showLoader = function (resultWindow, loader) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("showLoadingAnimation", { windowId: resultWindow.id, options: loader })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.hideLoader = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("hideLoadingAnimation", { windowId: resultWindow.id })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.updateContext = function (resultWindow, context) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("updateContext", {
                    windowId: resultWindow.id,
                    context: context,
                    replace: Object.keys(resultWindow.context).length > 0 ? false : true
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.lock = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("lockUnlock", {
                    windowId: resultWindow.id,
                    options: {
                        lock: true
                    }
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.unlock = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("lockUnlock", {
                    windowId: resultWindow.id,
                    options: {
                        lock: false
                    }
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.getIcon = function (resultWindow) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("getIcon", {
                    windowId: resultWindow.id,
                    options: {}
                })
                    .then(function (result) {
                    resolve(result.icon);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.setIcon = function (resultWindow, base64Image) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("setIcon", {
                    windowId: resultWindow.id,
                    options: {
                        dataURL: base64Image
                    }
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.setFrameColor = function (resultWindow, frameColor) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("setFrameColor", {
                    windowId: resultWindow.id,
                    options: {
                        frameColor: frameColor
                    }
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.setTabHeaderVisible = function (resultWindow, toBeTabHeaderVisible) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.execute("setTabHeaderVisible", {
                    windowId: resultWindow.id,
                    options: {
                        toShow: toBeTabHeaderVisible
                    }
                })
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.showPopup = function (targetWindow, options) {
            return __awaiter(this, void 0, void 0, function () {
                var optionsCopy, reformatedOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!options) {
                                return [2, Promise.reject("The options object is not valid!")];
                            }
                            optionsCopy = __assign({}, options);
                            if (!optionsCopy.targetLocation) {
                                optionsCopy.targetLocation = "bottom";
                            }
                            reformatedOptions = __assign(__assign({}, optionsCopy), { popupBounds: optionsCopy.size, targetId: targetWindow.id, popupId: optionsCopy.windowId });
                            return [4, this.execute("showPopupWindow", {
                                    windowId: targetWindow.id,
                                    options: reformatedOptions
                                })];
                        case 1:
                            _a.sent();
                            return [2, targetWindow];
                    }
                });
            });
        };
        GDExecutor.prototype.createFlydown = function (windowId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var optionsCopy, fullOptions;
                var _this = this;
                return __generator(this, function (_a) {
                    if (!options) {
                        return [2, Promise.reject("The options object is not valid!")];
                    }
                    optionsCopy = __assign({}, options);
                    if (!optionsCopy.horizontalOffset) {
                        optionsCopy.horizontalOffset = 0;
                    }
                    if (!optionsCopy.verticalOffset) {
                        optionsCopy.verticalOffset = 0;
                    }
                    fullOptions = this.reformatFlydownOptions(windowId, optionsCopy);
                    return [2, this.execute("setFlydownArea", { windowId: windowId, options: fullOptions }).then(function () {
                            var zoneIds = fullOptions.zones.map(function (z) { return z.id; });
                            fullOptions.zones.forEach(function (z) {
                                var callback = typeof (z.flydownSize) === "function" ?
                                    z.flydownSize : function () { return z.flydownSize; };
                                if (options.size instanceof Function && z.flydownSize) {
                                    callback = function (data, cancel) { return __awaiter(_this, void 0, void 0, function () {
                                        var result;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    if (!(options.size instanceof Function)) return [3, 2];
                                                    return [4, options.size(data, cancel)];
                                                case 1:
                                                    result = _a.sent();
                                                    _a.label = 2;
                                                case 2:
                                                    if (!(z.flydownSize instanceof Function && z.flydownSize !== options.size)) return [3, 4];
                                                    return [4, z.flydownSize(data, cancel)];
                                                case 3: return [2, (_a.sent()) || result];
                                                case 4: return [2, result || z.flydownSize];
                                            }
                                        });
                                    }); };
                                }
                                _this._registry.clearKey(fullOptions.targetId + "_" + z.id);
                                _this._registry.add(fullOptions.targetId + "_" + z.id, callback);
                            });
                            return {
                                destroy: function () { return _this.clearFlydownArea(fullOptions.targetId, zoneIds); },
                                options: optionsCopy
                            };
                        })];
                });
            });
        };
        GDExecutor.prototype.setModalState = function (windowId, isModal) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2, this.execute("setModalState", { windowId: windowId, options: { isModal: isModal } })];
                });
            });
        };
        GDExecutor.prototype.handleFlydownBoundsRequested = function (targetId, data) {
            return __awaiter(this, void 0, void 0, function () {
                var cancelCallback, callbackData, responses, defaultResponse, response, responseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            cancelCallback = function () { return data.cancel = true; };
                            callbackData = {
                                zoneId: data.flydownId,
                                flydownWindowBounds: data.flydownWindowBounds,
                                flydownWindowId: data.flydownWindowId,
                            };
                            return [4, Promise.all(this._registry.execute(targetId + "_" + data.flydownId, callbackData, cancelCallback))];
                        case 1:
                            responses = _a.sent();
                            if (responses.length === 1) {
                                defaultResponse = { height: 0, width: 0, top: 0, left: 0 };
                                response = typeof (responses[0]) === "object" && !Array.isArray(responses[0]) ? responses[0] : defaultResponse;
                                responseOptions = __assign(__assign({}, data), { flydownWindowBounds: response });
                                return [2, responseOptions];
                            }
                            return [2];
                    }
                });
            });
        };
        GDExecutor.prototype.zoomIn = function (window) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("zoomIn", {
                                windowId: window.id,
                            })];
                        case 1:
                            _a.sent();
                            return [2, window];
                    }
                });
            });
        };
        GDExecutor.prototype.zoomOut = function (window) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("zoomOut", {
                                windowId: window.id,
                            })];
                        case 1:
                            _a.sent();
                            return [2, window];
                    }
                });
            });
        };
        GDExecutor.prototype.setZoomFactor = function (window, zoomFactor) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("setZoomFactor", {
                                windowId: window.id,
                                options: {
                                    zoomFactor: zoomFactor
                                }
                            })];
                        case 1:
                            _a.sent();
                            return [2, window];
                    }
                });
            });
        };
        GDExecutor.prototype.showDevTools = function (window) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("showDevTools", {
                                windowId: window.id,
                            })];
                        case 1:
                            _a.sent();
                            return [2, window];
                    }
                });
            });
        };
        GDExecutor.prototype.capture = function (window, options) {
            return __awaiter(this, void 0, void 0, function () {
                var base64screenshot;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("captureScreenshot", { windowId: window.id, options: __assign({}, options) })];
                        case 1:
                            base64screenshot = (_a.sent()).data;
                            return [2, base64screenshot];
                    }
                });
            });
        };
        GDExecutor.prototype.captureGroup = function (windowIds, options) {
            return __awaiter(this, void 0, void 0, function () {
                var base64screenshot;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("captureGroupScreenshot", { windowId: windowIds[0], options: __assign({ groupWindowIds: windowIds }, options) })];
                        case 1:
                            base64screenshot = (_a.sent()).data;
                            return [2, base64screenshot];
                    }
                });
            });
        };
        GDExecutor.prototype.flash = function (resultWindow, options) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("flash", { windowId: resultWindow.id, options: __assign({}, options) })];
                        case 1:
                            _a.sent();
                            return [2, resultWindow];
                    }
                });
            });
        };
        GDExecutor.prototype.configure = function (windowId, options) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2, this.execute("configure", { windowId: windowId, options: __assign({}, options) })];
                });
            });
        };
        GDExecutor.prototype.print = function (resultWindow, options) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("print", { windowId: resultWindow.id, options: __assign({}, options) })];
                        case 1:
                            _a.sent();
                            return [2, resultWindow];
                    }
                });
            });
        };
        GDExecutor.prototype.printToPDF = function (resultWindow, options) {
            return __awaiter(this, void 0, void 0, function () {
                var filePath;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.execute("printToPDF", { windowId: resultWindow.id, options: __assign({}, options) })];
                        case 1:
                            filePath = (_a.sent()).filePath;
                            return [2, filePath];
                    }
                });
            });
        };
        GDExecutor.prototype.place = function (window, options) {
            return __awaiter(this, void 0, void 0, function () {
                var copy;
                return __generator(this, function (_a) {
                    copy = __assign({}, options);
                    if (copy.display) {
                        copy.display = copy.display.index + 1;
                    }
                    return [2, this.execute("place", { windowId: window.id, options: __assign({}, copy) })];
                });
            });
        };
        GDExecutor.prototype.execute = function (command, options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var args = __assign(__assign({}, options), { command: command });
                _this.agm
                    .invoke("T42.Wnd.Execute", args, _this.agmTarget)
                    .then(function (i) {
                    if (i.returned && i.returned.errorMsg) {
                        reject(i);
                    }
                    else {
                        resolve(i.returned);
                    }
                })
                    .catch(function (i) {
                    reject(i);
                });
            });
        };
        GDExecutor.prototype.setGroupHeaderVisible = function (windowId, toShow) {
            return this.execute("setGroupHeaderVisibility", {
                windowId: windowId,
                options: {
                    toShow: toShow
                }
            });
        };
        GDExecutor.prototype.getGroupTitle = function (windowId) {
            return this.execute("getGroupTitle", {
                windowId: windowId,
                options: {}
            }).then(function (r) { return r.title; });
        };
        GDExecutor.prototype.setGroupTitle = function (windowId, title) {
            return this.execute("setGroupTitle", {
                windowId: windowId,
                options: {
                    title: title
                }
            });
        };
        GDExecutor.prototype.onClosing = function (callback, id) {
            var glue42gd = typeof window !== "undefined" && window.glue42gd;
            if (glue42gd) {
                return glue42gd.addCloseHandler(callback, id);
            }
        };
        GDExecutor.prototype.onRefreshing = function (callback, id) {
            var glue42gd = typeof window !== "undefined" && window.glue42gd;
            if (glue42gd) {
                return glue42gd.addRefreshHandler(callback, id);
            }
        };
        GDExecutor.prototype.ungroup = function (resultWindow, options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var args = {
                    windowId: resultWindow.id,
                    options: options
                };
                _this.execute("ungroup", args)
                    .then(function () {
                    resolve(resultWindow);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        };
        GDExecutor.prototype.reformatFlydownOptions = function (windowId, options) {
            var assignGeneralIfUnassigned = function (zone, prop) {
                if (options[prop] && (zone[prop] === undefined || zone[prop] === null)) {
                    var valueFromOptions = options[prop];
                    zone[prop] = valueFromOptions;
                }
            };
            var zones = options.zones.map(function (z) {
                assignGeneralIfUnassigned(z, "windowId");
                assignGeneralIfUnassigned(z, "targetLocation");
                if (options.size && (z.flydownSize === undefined || z.flydownSize === null)) {
                    z.flydownSize = options.size;
                }
                z.flydownBounds = z.flydownSize;
                z.flydownId = z.windowId;
                if (!z.targetLocation) {
                    z.targetLocation = "bottom";
                }
                return z;
            });
            return __assign(__assign({}, options), { zones: zones, targetId: windowId, flydownBounds: options.size, flydownActiveArea: options.activeArea });
        };
        GDExecutor.prototype.clearFlydownArea = function (windowId, areaIds) {
            var _this = this;
            return this.execute("clearFlydownWindowArea", {
                windowId: windowId,
                options: {}
            }).then(function () {
                areaIds.forEach(function (id) {
                    _this._registry.clearKey(windowId + "_" + id);
                });
            });
        };
        return GDExecutor;
    }());
    var executor = new GDExecutor();

    function getWindowsByTabGroupId(windowId, tabGroupId) {
        var windows = windowStore.list;
        return Object.keys(windows).reduce(function (memo, id) {
            var win = windows[id];
            if (win.API.tabGroupId === tabGroupId && win.API.id !== windowId) {
                memo[id] = win;
            }
            return memo;
        }, {});
    }

    var GDEnvironment = (function () {
        function GDEnvironment(agm, logger, appManagerGetter, displayAPIGetter, instance, wndId) {
            this._registry = lib$2();
            this._waitTimeout = 10000;
            this._agm = agm;
            this._logger = logger.subLogger("gd-env");
            this._agmInstance = this.normalizeInstance(instance);
            this._windowId = wndId;
            this._appManagerGetter = appManagerGetter;
            this._displayAPIGetter = displayAPIGetter;
        }
        GDEnvironment.prototype.init = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (typeof _this._agmInstance === "undefined") {
                    _this._agmInstance = "best";
                }
                _this._agm.registerAsync("T42.Wnd.OnEventWithResponse", function (args, caller, success, err) {
                    _this.respondToEvent(args).then(success).catch(err);
                });
                var streamPromise = new Promise(function (streamResolve, streamReject) {
                    _this._agm.subscribe("T42.Wnd.OnEvent", {
                        waitTimeoutMs: _this._waitTimeout,
                        target: _this._agmInstance,
                        onData: function (streamData) {
                            _this.updateWindow(streamData.data, resolve);
                        },
                        onConnected: function (instance) {
                            _this._agmInstance = _this.normalizeInstance(instance);
                            executor.init(_this._agm, _this._agmInstance);
                        }
                    }).catch(function (err) {
                        reject("Can not subscribe for stream T42.Wnd.OnEvent. Err: " + err);
                    });
                });
            });
        };
        Object.defineProperty(GDEnvironment.prototype, "executor", {
            get: function () {
                return executor;
            },
            enumerable: true,
            configurable: true
        });
        GDEnvironment.prototype.open = function (name, url, options, success, error) {
            options = options || {};
            var copyOptions = __assign({}, options);
            if (name === undefined) {
                error({ message: "The name is undefined" });
                return;
            }
            if (copyOptions.relativeTo !== undefined && typeof copyOptions.relativeTo !== "string") {
                copyOptions.relativeTo = copyOptions.relativeTo.id || "";
            }
            copyOptions.name = name;
            copyOptions.url = url;
            copyOptions.windowState = options.windowState || options.state;
            delete copyOptions.state;
            this._agm.invoke("T42.Wnd.Create", copyOptions, this._agmInstance)
                .then(function (message) {
                if (message.returned !== undefined) {
                    var id = message.returned.id;
                    success(id);
                }
                else {
                    error({ message: "failed to execute T42.Wnd.Create - unknown reason" });
                }
            })
                .catch(error);
        };
        GDEnvironment.prototype.createFlydown = function (windowId, options) {
            return this.executor.createFlydown(windowId, options);
        };
        GDEnvironment.prototype.showPopup = function (windowId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var window;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            window = windowStore.get(windowId);
                            return [4, this.executor.showPopup(window.API, options)];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        GDEnvironment.prototype.tabAttached = function (callback) {
            return this._registry.add("tab-attached", callback);
        };
        GDEnvironment.prototype.tabDetached = function (callback) {
            return this._registry.add("tab-detached", callback);
        };
        GDEnvironment.prototype.onWindowFrameColorChanged = function (callback) {
            return this._registry.add("frame-color-changed", callback);
        };
        GDEnvironment.prototype.onEvent = function (callback) {
            return this._registry.add("window-event", callback);
        };
        GDEnvironment.prototype.my = function () {
            return this._windowId;
        };
        GDEnvironment.prototype.execute = function (command, windowId, options) {
            return this._agm.invoke("T42.Wnd.Execute", {
                command: command,
                options: options,
                windowId: windowId,
            });
        };
        GDEnvironment.prototype.setGroupHeaderVisible = function (windowId, toShow) {
            return this._agm.invoke("T42.Wnd.SetGroupHeaderVisible", {
                windowId: windowId,
                toShow: toShow,
            }, this._agmInstance);
        };
        GDEnvironment.prototype.onCompositionChanged = function (callback) {
            return this._registry.add("composition-changed", callback);
        };
        GDEnvironment.prototype.onGroupHeaderVisibilityChanged = function (callback) {
            return this._registry.add("group-header-changed", callback);
        };
        GDEnvironment.prototype.onWindowGotFocus = function (callback) {
            return this._registry.add("got-focus", callback);
        };
        GDEnvironment.prototype.onWindowLostFocus = function (callback) {
            return this._registry.add("lost-focus", callback);
        };
        GDEnvironment.prototype.normalizeInstance = function (instance) {
            if (!instance) {
                return undefined;
            }
            return {
                application: instance.application,
                machine: instance.machine,
                user: instance.user,
            };
        };
        GDEnvironment.prototype.respondToEvent = function (args) {
            if (args.type === "ShowFlydownBoundsRequested") {
                return this.executor.handleFlydownBoundsRequested(args.data.windowId, args.data);
            }
            return Promise.reject("There isn't a handler for " + args.type);
        };
        GDEnvironment.prototype.updateWindow = function (windowInfo, readyResolve) {
            var _this = this;
            var extendedStreamEvent = this.getExtendedStreamEvent(windowInfo);
            if (windowInfo.type === "Snapshot") {
                var windowInfoFullInfoEvent = windowInfo;
                windowInfoFullInfoEvent.windows.forEach(function (w) {
                    var win = _this.createWindow(w.id, w);
                    windowStore.markReadyToShow(win.API.id);
                    _this._registry.execute("window-event", extendedStreamEvent);
                });
                readyResolve(this);
                return;
            }
            if (windowInfo.type === "Created") {
                var windowInfoCreatedEvent = windowInfo;
                var win = this.createWindow(windowInfoCreatedEvent.windowId, windowInfoCreatedEvent.data || {});
                windowStore.setReadyState(win.API.id);
                this._registry.execute("window-event", extendedStreamEvent);
                return;
            }
            var windowObjectAndEvents = windowStore.get(windowInfo.windowId);
            if (!windowObjectAndEvents) {
                this._logger.error("received update for unknown window. Stream:', " + JSON.stringify(windowInfo, null, 4));
                return;
            }
            var theWindow = windowObjectAndEvents.API;
            var theWindowEvents = windowObjectAndEvents.Events;
            if (windowInfo.type === "BoundsChanged") {
                var windowInfoBoundsChangedEvent = windowInfo;
                theWindowEvents.handleBoundsChanged(windowInfoBoundsChangedEvent.data);
            }
            if (windowInfo.type === "UrlChanged") {
                var windowInfoUrlChangedEvent = windowInfo;
                windowStore.setUrlChangedState(windowInfoUrlChangedEvent.windowId);
                theWindowEvents.handleUrlChanged(windowInfoUrlChangedEvent.data);
            }
            if (windowInfo.type === "TitleChanged") {
                var windowInfoTitleChanged = windowInfo;
                theWindowEvents.handleTitleChanged(windowInfoTitleChanged.data);
            }
            if (windowInfo.type === "IsStickyChanged") {
                var windowInfoIsStickyChangedChanged = windowInfo;
                theWindowEvents.handleIsStickyChanged(windowInfoIsStickyChangedChanged.data);
            }
            if (windowInfo.type === "VisibilityChanged") {
                theWindowEvents.handleVisibilityChanged(windowInfo.data);
            }
            if (windowInfo.type === "ContextChanged") {
                theWindowEvents.handleContextUpdated(windowInfo.data);
            }
            if (windowInfo.type === "StateChanged") {
                theWindowEvents.handleWindowChangeState(windowInfo.data);
            }
            if (windowInfo.type === "FrameColorChanged") {
                theWindowEvents.handleFrameColorChanged(windowInfo.data);
                this._registry.execute("frame-color-changed", theWindow);
            }
            if (windowInfo.type === "CompositionChanged") {
                var windowInfoCompositionChanged = windowInfo;
                theWindowEvents.handleCompositionChanged(windowInfoCompositionChanged.data.neighbors, windowInfoCompositionChanged.data.groupId);
                this._registry.execute("composition-changed", windowInfoCompositionChanged.data);
            }
            if (windowInfo.type === "GroupHeaderVisibilityChanged") {
                var info = windowInfo;
                theWindowEvents.handleGroupHeaderVisibilityChanged(info.data.groupHeaderVisible);
                this._registry.execute("group-header-changed", info.data);
            }
            if (windowInfo.type === "FocusChanged") {
                var windowInfoFocusChanged = windowInfo;
                this.focusChanged(theWindowEvents, theWindow, windowInfoFocusChanged.data);
            }
            if (windowInfo.type === "WindowFrameChanged") {
                theWindowEvents.handleFrameAttached(windowInfo.data.frameId, windowInfo.data.isTabHeaderVisible);
                this._registry.execute("frame-changed");
            }
            if (windowInfo.type === "WindowFrameAdded") {
                theWindowEvents.handleAttached(windowInfo.data.frameId, windowInfo.data.isTabHeaderVisible);
                var winsToBeNotified_1 = getWindowsByTabGroupId(theWindow.id, windowInfo.data.frameId);
                Object.keys(winsToBeNotified_1).forEach(function (id) {
                    var win = winsToBeNotified_1[id];
                    win.Events.handleWindowAttached(theWindow);
                });
                this._registry.execute("tab-attached", theWindow, windowInfo.data.frameId, windowInfo.data.isTabHeaderVisible);
            }
            if (windowInfo.type === "WindowFrameRemoved") {
                var oldTabGroupId = theWindow.tabGroupId;
                theWindowEvents.handleDetached(windowInfo.data.frameId);
                var winsToBeNotified_2 = getWindowsByTabGroupId(theWindow.id, oldTabGroupId);
                Object.keys(winsToBeNotified_2).forEach(function (id) {
                    var win = winsToBeNotified_2[id];
                    win.Events.handleWindowDetached(theWindow);
                });
                var un_1 = this._registry.add("frame-changed", function () {
                    un_1();
                    _this._registry.execute("tab-detached", theWindow, windowInfo.data.frameId, theWindow.tabGroupId);
                });
            }
            if (windowInfo.type === "TabHeaderVisibilityChanged") {
                theWindowEvents.handleTabHeaderVisibilityChanged(windowInfo.data.isTabHeaderVisible);
            }
            if (windowInfo.type === "FrameSelectionChanged") {
                theWindowEvents.handleFrameSelectionChanged(windowInfo.data.newWindowId, windowInfo.data.prevWindowId);
            }
            if (windowInfo.type === "ButtonClicked") {
                theWindowEvents.handleFrameButtonClicked(windowInfo.data);
            }
            if (windowInfo.type === "ButtonAdded") {
                theWindowEvents.handleFrameButtonAdded(windowInfo.data);
            }
            if (windowInfo.type === "ButtonRemoved") {
                theWindowEvents.handleFrameButtonRemoved(windowInfo.data);
            }
            if (windowInfo.type === "WindowZoomFactorChanged") {
                theWindowEvents.handleZoomFactorChanged(windowInfo.data);
            }
            if (windowInfo.type === "Closed") {
                windowStore.remove(windowObjectAndEvents);
                theWindowEvents.handleWindowClose();
            }
            if (windowInfo.type === "FrameIsLockedChanged") {
                theWindowEvents.handleFrameIsLockedChanged(windowInfo.data);
            }
            if (windowInfo.type === "PlacementSettingsChanged") {
                theWindowEvents.handlePlacementSettingsChanged(windowInfo.data);
            }
            this._registry.execute("window-event", extendedStreamEvent);
        };
        GDEnvironment.prototype.createWindow = function (windowId, options) {
            var _a;
            var wrapper = windowStore.get(windowId);
            var windowObjAndEvents = windowFactory(windowId, this.mapToWindowConstructorOptions(options), executor, this._logger, this._appManagerGetter, this._displayAPIGetter, this._agm, (_a = wrapper) === null || _a === void 0 ? void 0 : _a.Registry);
            windowStore.add(windowObjAndEvents);
            return windowObjAndEvents;
        };
        GDEnvironment.prototype.focusChanged = function (theWindowEvents, theWindow, focus) {
            theWindowEvents.handleFocusChanged(focus);
            if (focus) {
                this._registry.execute("got-focus", theWindow);
            }
            else {
                this._registry.execute("lost-focus", theWindow);
            }
        };
        GDEnvironment.prototype.mapToWindowConstructorOptions = function (args) {
            return {
                name: args.name,
                context: args.context,
                bounds: args.bounds,
                url: args.url,
                title: args.title,
                isVisible: args.isVisible,
                focus: args.isFocused,
                state: args.state,
                frameColor: args.frameColor,
                groupId: args.groupId,
                neighbours: args.neighbors,
                isFocused: args.isFocused,
                isGroupHeaderVisible: args.groupHeaderVisible,
                isCollapsed: args.isCollapsed,
                tabGroupId: args.frameId,
                mode: args.mode,
                isTabHeaderVisible: args.isTabHeaderVisible,
                isTabSelected: args.isActiveTab,
                settings: args.settings,
                windowType: args.windowType,
                zoomFactor: args.zoomFactor,
                isLocked: args.isLocked,
                placementSettings: args.placementSettings,
                isSticky: args.isSticky
            };
        };
        GDEnvironment.prototype.getExtendedStreamEvent = function (streamEvent) {
            try {
                var result = __assign({ state: streamEvent.type, windowName: windowStore.get(streamEvent.windowId).API.name }, streamEvent);
                if (result.state === "WindowFrameAdded") {
                    result.state = "TabAttached";
                }
                if (result.state === "StateChanged") {
                    result.state = result.data.charAt(0).toUpperCase() + result.data.slice(1);
                }
                if (result.state === "ButtonAdded") {
                    result.state = "FrameButtonAdded";
                }
                if (result.state === "ButtonRemoved") {
                    result.state = "FrameButtonRemoved";
                }
                return result;
            }
            catch (error) {
                return streamEvent;
            }
        };
        return GDEnvironment;
    }());

    var envDetector = (function (agm, logger, appManagerGetter, displayAPIGetter, gdMajorVersion) {
        var _logger = logger;
        return new Promise(function (resolve, reject) {
            if (gdMajorVersion === 2) {
                _logger.trace("running in HC");
                throw new Error("GD2 not supported");
            }
            else if (gdMajorVersion >= 3) {
                _logger.trace("running in GD 3");
                var gd = new GDEnvironment(agm, _logger, appManagerGetter, displayAPIGetter, undefined, window.glue42gd.windowId);
                gd.init()
                    .then(resolve)
                    .catch(reject);
            }
            else {
                var gdPromise = new GDEnvironment(agm, _logger, appManagerGetter, displayAPIGetter).init();
                var wait = function (ms) { return new Promise(function (res, rej) { return setTimeout(function () { rej("timeout waiting for streams"); }, ms); }); };
                Promise.race([gdPromise, wait(10000)])
                    .then(resolve)
                    .catch(reject);
            }
        });
    });

    var groupFactory = (function (id, executor) {
        var _registry = lib$2();
        var _windowsId = [];
        function addWindow(winId) {
            if (_windowsId.indexOf(winId) === -1) {
                _windowsId.push(winId);
                var window_1 = windowStore.get(winId);
                window_1.Events.handleGroupAssociation(groupObject);
                _registry.execute("window-added", groupObject, window_1.API);
            }
        }
        function removeWindow(winId) {
            var index = _windowsId.indexOf(winId);
            if (index !== -1) {
                _windowsId.splice(index, 1);
                var window_2 = _mapToWindowObject(winId);
                _registry.execute("window-removed", groupObject, window_2);
            }
        }
        function find(window, success) {
            if (isUndefinedOrNull(window)) {
                return;
            }
            var winId;
            if (typeof window === "string") {
                winId = window;
            }
            else {
                winId = window.id;
            }
            var index = _windowsId.indexOf(winId);
            if (index !== -1) {
                var mappedWindow = _mapToWindowObject(_windowsId[index]);
                if (typeof success === "function") {
                    success(mappedWindow);
                }
                return mappedWindow;
            }
        }
        function windows(success) {
            var mappedWindows = _mapToWindowObjects();
            if (typeof success === "function") {
                success(mappedWindows);
            }
            return mappedWindows;
        }
        function showHeader(success, error) {
            return new Promise(function (resolve, reject) {
                Promise.all([
                    executor.setGroupHeaderVisible(_windowsId[0], true),
                    waitForHeaderVisibilityChanged()
                ])
                    .then(function () {
                    if (typeof success === "function") {
                        success(groupObject);
                    }
                    resolve(groupObject);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        }
        function hideHeader(success, error) {
            return new Promise(function (resolve, reject) {
                Promise.all([
                    executor.setGroupHeaderVisible(_windowsId[0], false),
                    waitForHeaderVisibilityChanged()
                ])
                    .then(function () {
                    if (typeof success === "function") {
                        success(groupObject);
                    }
                    resolve(groupObject);
                })
                    .catch(function (e) {
                    return;
                });
            });
        }
        function getTitle() {
            return executor.getGroupTitle(_windowsId[0]);
        }
        function setTitle(title) {
            return executor.setGroupTitle(_windowsId[0], title);
        }
        function capture(captureOptions) {
            return executor.captureGroup(_windowsId, captureOptions);
        }
        function waitForHeaderVisibilityChanged() {
            return new Promise(function (resolve, reject) {
                var unsub = onHeaderVisibilityChanged(function (group) {
                    unsub();
                    resolve();
                });
            });
        }
        function execute(command, options, success, error) {
            return new Promise(function (resolve, reject) {
                executor.execute(command, options)
                    .then(function (w) {
                    if (typeof success === "function") {
                        success(groupObject);
                    }
                    resolve(groupObject);
                })
                    .catch(function (e) {
                    reject(e);
                });
            });
        }
        function handleGroupHeaderVisibilityChanged(windowInfo) {
            _registry.execute("header-visibility-changed", groupObject);
        }
        function _mapToWindowObjects() {
            var winObjects = [];
            _windowsId.forEach(function (winId) {
                var windowObject = _mapToWindowObject(winId);
                if (typeof windowObject !== "undefined") {
                    winObjects.push(windowObject);
                }
            });
            return winObjects;
        }
        function _mapToWindowObject(windowId) {
            return windowStore.get(windowId) ? windowStore.get(windowId).API : undefined;
        }
        function _getGroupHeaderVisibility() {
            var windowWithHiddenHeader = _mapToWindowObjects().find(function (w) { return !w.isGroupHeaderVisible; });
            var _isGroupHeaderVisible = windowWithHiddenHeader === undefined;
            return _isGroupHeaderVisible;
        }
        function onHeaderVisibilityChanged(callback) {
            return _registry.add("header-visibility-changed", callback);
        }
        function onWindowAdded(callback) {
            return _registry.add("window-added", callback);
        }
        function onWindowRemoved(callback) {
            return _registry.add("window-removed", callback);
        }
        var groupObject = {
            id: id,
            get windows() {
                return windows();
            },
            find: find,
            get isHeaderVisible() {
                return _getGroupHeaderVisibility();
            },
            showHeader: showHeader,
            hideHeader: hideHeader,
            getTitle: getTitle,
            setTitle: setTitle,
            capture: capture,
            maximize: function (success, error) {
                return execute("maximizeGroup", { windowId: _windowsId[0] }, success);
            },
            restore: function (success, error) {
                return execute("restoreGroup", { windowId: _windowsId[0] }, success);
            },
            onHeaderVisibilityChanged: onHeaderVisibilityChanged,
            onWindowAdded: onWindowAdded,
            onWindowRemoved: onWindowRemoved,
        };
        var internal = {
            addWindow: addWindow,
            removeWindow: removeWindow,
            handleGroupHeaderVisibilityChanged: handleGroupHeaderVisibilityChanged,
        };
        return {
            groupAPI: groupObject,
            groupInternal: internal,
        };
    });

    var groupsFactory = (function (environment, logger) {
        var _logger = logger.subLogger("groups");
        var _registry = lib$2();
        var _groups = {};
        var heardForWindowsCounter = -1;
        var windows = windowStore.list;
        Object.keys(windows).forEach(function (k) {
            addNewWindow(windows[k]);
        });
        environment.onCompositionChanged(function (windowInfo) {
            handleCompositionChanged(windowInfo);
        });
        environment.onGroupHeaderVisibilityChanged(function (windowInfo) {
            var windowId = windowInfo.windowId;
            var group = findGroupByWindow(windowId);
            if (typeof group !== "undefined") {
                var groupEvents = _groups[group.id];
                if (heardForWindowsCounter === -1) {
                    heardForWindowsCounter = group.windows.length;
                }
                heardForWindowsCounter--;
                if (heardForWindowsCounter === 0) {
                    heardForWindowsCounter = -1;
                    groupEvents.groupInternal.handleGroupHeaderVisibilityChanged(windowInfo);
                }
            }
        });
        windowStore.onAdded(function (win) {
            addNewWindow(win);
        });
        windowStore.onRemoved(function (win) {
            removeWindow(win);
        });
        function my() {
            return findGroupByWindow(environment.my());
        }
        function list(success) {
            var result = Object.keys(_groups).map(function (groupId) {
                if (_groups[groupId]) {
                    return _groups[groupId].groupAPI;
                }
            });
            if (typeof success === "function") {
                success(result);
            }
            return result;
        }
        function findGroupByWindow(winId, success) {
            var windowId;
            if (typeof winId === "undefined") {
                logger.debug("trying to find a group by a window, but winId is undefined");
                return;
            }
            if (typeof winId === "string") {
                windowId = winId;
            }
            else {
                windowId = winId.id;
            }
            var groupFound;
            Object.keys(_groups).forEach(function (groupId) {
                var group = _groups[groupId].groupAPI;
                if (group.find(windowId) !== undefined) {
                    groupFound = group;
                    return;
                }
            });
            if (typeof success === "function") {
                success(groupFound);
            }
            return groupFound;
        }
        function onWindowMoved(callback) {
            return _registry.add("window-moved", callback);
        }
        function createOrGetGroup(groupId) {
            if (!_groups.hasOwnProperty(groupId)) {
                var createdGroup = groupFactory(groupId, environment.executor);
                _groups[groupId] = createdGroup;
                return createdGroup;
            }
            else {
                return _groups[groupId];
            }
        }
        function deleteGroup(groupId) {
            if (_groups.hasOwnProperty(groupId) && typeof _groups[groupId] !== "undefined") {
                if (_groups[groupId].groupAPI.windows.length === 0) {
                    delete _groups[groupId];
                }
            }
        }
        function addNewWindow(win) {
            _logger.trace("Adding new window " + win.API.id + " to win.API.groupId " + win.API.groupId);
            var group = addWindow(win);
            if (group) {
                _logger.trace("handleGroupAssociation " + win.API.id + " to group.groupAPI.id " + group.groupAPI.id);
                win.Events.handleGroupAssociation(group.groupAPI);
            }
        }
        function addWindow(win, groupId) {
            var windowGroupId = groupId || win.API.groupId;
            var windowId = win.API.id;
            if (typeof windowGroupId === "undefined" || typeof windowId === "undefined") {
                _logger.debug("trying to add a window without group - winId: " + windowId);
                return;
            }
            var group = createOrGetGroup(windowGroupId);
            group.groupInternal.addWindow(windowId);
            return group;
        }
        function removeWindow(win, groupId) {
            var windowId = win.API.id;
            var windowGroupId = groupId || win.API.groupId;
            if (typeof windowGroupId !== "undefined") {
                var group = _groups[windowGroupId];
                group.groupInternal.removeWindow(windowId);
                win.Events.handleGroupAssociation(undefined);
                deleteGroup(windowGroupId);
            }
        }
        function handleCompositionChanged(windowInfo) {
            var newGroupId = windowInfo.groupId;
            var windowId = windowInfo.windowId;
            var oldGroup = findGroupByWindow(windowId);
            var oldGroupId = oldGroup ? oldGroup.id : undefined;
            _logger.trace("handleCompositionChanged newGroupId: " + newGroupId + " windowId: " + windowId + " oldGroup: " + oldGroupId);
            if (oldGroupId === newGroupId) {
                _logger.trace("handleCompositionChanged newGroupId: " + newGroupId + " windowId: " + windowId + " oldGroup: " + oldGroupId + " are the same - returning...");
                return;
            }
            var win = windowStore.get(windowId) || windowStore.get(windowId);
            var newGroup = addWindow(win, newGroupId);
            if (oldGroup) {
                removeWindow(win, oldGroupId);
                _registry.execute("window-moved", windowId, oldGroup, newGroupId);
            }
            win.Events.handleGroupChanged(newGroup.groupAPI, oldGroup);
        }
        var groups = {
            get my() {
                return my();
            },
            list: list,
            findGroupByWindow: findGroupByWindow,
        };
        var events = { onWindowMoved: onWindowMoved };
        return {
            groupsAPI: groups,
            groupsEvents: events,
        };
    });

    var WindowsFactory = (function (agm, logger, appManagerGetter, displayAPIGetter, gdMajorVersion) {
        var _registry = lib$2();
        var _logger = logger;
        var groups;
        var environment;
        windowStore.init(_logger);
        var isReady = new Promise(function (resolve, reject) {
            envDetector(agm, _logger, appManagerGetter, displayAPIGetter, gdMajorVersion)
                .then(function (env) {
                environment = env;
                groups = groupsFactory(env, _logger);
                resolve();
            })
                .catch(function (e) {
                var err = "Environment detector fails with: " + e;
                _logger.error(err);
                reject(err);
            });
        });
        function ready() {
            return isReady;
        }
        function my() {
            var myWindow = windowStore.getIfReady(environment.my());
            return myWindow ? myWindow.API : undefined;
        }
        function open(name, url, options, success, error) {
            return new Promise(function (resolve, reject) {
                var errorHandler = function (errorResponse) {
                    if (typeof error === "function") {
                        error(errorResponse);
                    }
                    reject(errorResponse);
                };
                var successHandler = function (id) {
                    windowStore.waitFor(id)
                        .then(function (win) {
                        if (typeof success === "function") {
                            success(win.API);
                        }
                        resolve(win.API);
                        if (win.API.windowType === "electron") {
                            win.Events.handleUrlChanged(win.API.url);
                        }
                    })
                        .catch(errorHandler);
                };
                environment.open(name, url, options, successHandler, errorHandler);
            });
        }
        function find(name, success, error) {
            var windows = windowStore.list;
            var windowsForListing = Object.keys(windows).reduce(function (memo, winId) {
                var window = windows[winId];
                if (window && window.API.name === name) {
                    memo.push(window.API);
                }
                return memo;
            }, []);
            if (typeof success !== "function") {
                return windowsForListing[0];
            }
            if (windowsForListing.length > 0) {
                success(windowsForListing[0]);
            }
            else {
                if (typeof error === "function") {
                    error("There is no window with name:" + name);
                }
            }
        }
        function findById(id, success, error) {
            var windows = windowStore.list;
            var windowsForListing = Object.keys(windows).reduce(function (memo, winId) {
                var window = windows[winId];
                if (typeof window !== "undefined" && window.API.id === id) {
                    memo.push(window.API);
                }
                return memo;
            }, []);
            if (typeof success !== "function") {
                return windowsForListing[0];
            }
            if (windowsForListing.length > 0) {
                success(windowsForListing[0]);
            }
            else {
                if (typeof error === "function") {
                    error("There is no window with such id:" + id);
                }
            }
        }
        function list(success) {
            var windows = windowStore.list;
            var windowsForListing = Object.keys(windows)
                .map(function (k) {
                return windows[k].API;
            });
            if (typeof success !== "function") {
                return windowsForListing;
            }
            success(windowsForListing);
        }
        function configure(options) {
            var win = my();
            var winId = win ? win.id : "";
            return executor.configure(winId, options);
        }
        function windowAdded(callback) {
            return _registry.add("window-added", callback);
        }
        function windowRemoved(callback) {
            return _registry.add("window-removed", callback);
        }
        function tabAttached(callback) {
            var unsubFunc;
            var unsubscribed = false;
            isReady.then(function () {
                if (unsubscribed) {
                    return;
                }
                unsubFunc = environment.tabAttached(callback);
            });
            return function () {
                unsubscribed = true;
                if (unsubFunc) {
                    unsubFunc();
                }
            };
        }
        function tabDetached(callback) {
            var unsubFunc;
            var unsubscribed = false;
            isReady.then(function () {
                if (unsubscribed) {
                    return;
                }
                unsubFunc = environment.tabDetached(callback);
            });
            return function () {
                unsubscribed = true;
                if (unsubFunc) {
                    unsubFunc();
                }
            };
        }
        function onWindowFrameColorChanged(callback) {
            var unsubFunc;
            var unsubscribed = false;
            isReady.then(function () {
                if (unsubscribed) {
                    return;
                }
                unsubFunc = environment.onWindowFrameColorChanged(callback);
            });
            return function () {
                unsubscribed = true;
                if (unsubFunc) {
                    unsubFunc();
                }
            };
        }
        function onWindowGotFocus(callback) {
            var unsubFunc;
            var unsubscribed = false;
            isReady.then(function () {
                if (unsubscribed) {
                    return;
                }
                unsubFunc = environment.onWindowGotFocus(callback);
            });
            return function () {
                unsubscribed = true;
                if (unsubFunc) {
                    unsubFunc();
                }
            };
        }
        function onWindowLostFocus(callback) {
            var unsubFunc;
            var unsubscribed = false;
            isReady.then(function () {
                if (unsubscribed) {
                    return;
                }
                unsubFunc = environment.onWindowLostFocus(callback);
            });
            return function () {
                unsubscribed = true;
                if (unsubFunc) {
                    unsubFunc();
                }
            };
        }
        function onEvent(callback) {
            var unsubFunc;
            var unsubscribed = false;
            isReady.then(function () {
                if (unsubscribed) {
                    return;
                }
                unsubFunc = environment.onEvent(callback);
            });
            return function () {
                unsubscribed = true;
                if (unsubFunc) {
                    unsubFunc();
                }
            };
        }
        function createFlydown(targetId, config) {
            return environment.createFlydown(targetId, config);
        }
        function showPopup(targetId, config) {
            return environment.showPopup(targetId, config);
        }
        function handleWindowAdded(w) {
            _registry.execute("window-added", w.API);
        }
        function handleWindowRemoved(w) {
            _registry.execute("window-removed", w.API);
        }
        windowStore.onReadyWindow(handleWindowAdded);
        windowStore.onRemoved(handleWindowRemoved);
        return {
            my: my,
            open: open,
            find: find,
            findById: findById,
            list: list,
            ready: ready,
            onWindowAdded: windowAdded,
            windowAdded: windowAdded,
            onWindowRemoved: windowRemoved,
            windowRemoved: windowRemoved,
            onTabAttached: tabAttached,
            onTabDetached: tabDetached,
            onWindowFrameColorChanged: onWindowFrameColorChanged,
            get groups() {
                return groups.groupsAPI;
            },
            onWindowGotFocus: onWindowGotFocus,
            onWindowLostFocus: onWindowLostFocus,
            onEvent: onEvent,
            createFlydown: createFlydown,
            showPopup: showPopup,
            configure: configure
        };
    });

    var LayoutStore = (function () {
        function LayoutStore() {
            this.layouts = [];
        }
        LayoutStore.prototype.removeWhere = function (condition) {
            this.layouts = this.layouts.filter(condition);
        };
        LayoutStore.prototype.add = function (item) {
            this.layouts.push(item);
        };
        Object.defineProperty(LayoutStore.prototype, "all", {
            get: function () {
                return this.layouts;
            },
            enumerable: true,
            configurable: true
        });
        LayoutStore.prototype.where = function (condition) {
            return this.layouts.filter(condition);
        };
        LayoutStore.prototype.first = function (condition) {
            return this.where(condition)[0];
        };
        return LayoutStore;
    }());
    var store = new LayoutStore();

    function createCommonjsModule$1(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    // Found this seed-based random generator somewhere
    // Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

    var seed$1 = 1;

    /**
     * return a random number based on a seed
     * @param seed
     * @returns {number}
     */
    function getNextValue$1() {
        seed$1 = (seed$1 * 9301 + 49297) % 233280;
        return seed$1/(233280.0);
    }

    function setSeed$2(_seed_) {
        seed$1 = _seed_;
    }

    var randomFromSeed$1 = {
        nextValue: getNextValue$1,
        seed: setSeed$2
    };

    var ORIGINAL$1 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
    var alphabet$1;
    var previousSeed$1;

    var shuffled$1;

    function reset$1() {
        shuffled$1 = false;
    }

    function setCharacters$1(_alphabet_) {
        if (!_alphabet_) {
            if (alphabet$1 !== ORIGINAL$1) {
                alphabet$1 = ORIGINAL$1;
                reset$1();
            }
            return;
        }

        if (_alphabet_ === alphabet$1) {
            return;
        }

        if (_alphabet_.length !== ORIGINAL$1.length) {
            throw new Error('Custom alphabet for shortid must be ' + ORIGINAL$1.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
        }

        var unique = _alphabet_.split('').filter(function(item, ind, arr){
           return ind !== arr.lastIndexOf(item);
        });

        if (unique.length) {
            throw new Error('Custom alphabet for shortid must be ' + ORIGINAL$1.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
        }

        alphabet$1 = _alphabet_;
        reset$1();
    }

    function characters$1(_alphabet_) {
        setCharacters$1(_alphabet_);
        return alphabet$1;
    }

    function setSeed$3(seed) {
        randomFromSeed$1.seed(seed);
        if (previousSeed$1 !== seed) {
            reset$1();
            previousSeed$1 = seed;
        }
    }

    function shuffle$1() {
        if (!alphabet$1) {
            setCharacters$1(ORIGINAL$1);
        }

        var sourceArray = alphabet$1.split('');
        var targetArray = [];
        var r = randomFromSeed$1.nextValue();
        var characterIndex;

        while (sourceArray.length > 0) {
            r = randomFromSeed$1.nextValue();
            characterIndex = Math.floor(r * sourceArray.length);
            targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
        }
        return targetArray.join('');
    }

    function getShuffled$1() {
        if (shuffled$1) {
            return shuffled$1;
        }
        shuffled$1 = shuffle$1();
        return shuffled$1;
    }

    /**
     * lookup shuffled letter
     * @param index
     * @returns {string}
     */
    function lookup$1(index) {
        var alphabetShuffled = getShuffled$1();
        return alphabetShuffled[index];
    }

    var alphabet_1$1 = {
        characters: characters$1,
        seed: setSeed$3,
        lookup: lookup$1,
        shuffled: getShuffled$1
    };

    var crypto$1 = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

    function randomByte$1() {
        if (!crypto$1 || !crypto$1.getRandomValues) {
            return Math.floor(Math.random() * 256) & 0x30;
        }
        var dest = new Uint8Array(1);
        crypto$1.getRandomValues(dest);
        return dest[0] & 0x30;
    }

    var randomByteBrowser$1 = randomByte$1;

    function encode$1(lookup, number) {
        var loopCounter = 0;
        var done;

        var str = '';

        while (!done) {
            str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByteBrowser$1() );
            done = number < (Math.pow(16, loopCounter + 1 ) );
            loopCounter++;
        }
        return str;
    }

    var encode_1$1 = encode$1;

    /**
     * Decode the id to get the version and worker
     * Mainly for debugging and testing.
     * @param id - the shortid-generated id.
     */
    function decode$1(id) {
        var characters = alphabet_1$1.shuffled();
        return {
            version: characters.indexOf(id.substr(0, 1)) & 0x0f,
            worker: characters.indexOf(id.substr(1, 1)) & 0x0f
        };
    }

    var decode_1$1 = decode$1;

    // Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
    // This number should be updated every year or so to keep the generated id short.
    // To regenerate `new Date() - 0` and bump the version. Always bump the version!
    var REDUCE_TIME = 1459707606518;

    // don't change unless we change the algos or REDUCE_TIME
    // must be an integer and less than 16
    var version$1 = 6;

    // Counter is used when shortid is called multiple times in one second.
    var counter;

    // Remember the last time shortid was called in case counter is needed.
    var previousSeconds;

    /**
     * Generate unique id
     * Returns string id
     */
    function build(clusterWorkerId) {

        var str = '';

        var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

        if (seconds === previousSeconds) {
            counter++;
        } else {
            counter = 0;
            previousSeconds = seconds;
        }

        str = str + encode_1$1(alphabet_1$1.lookup, version$1);
        str = str + encode_1$1(alphabet_1$1.lookup, clusterWorkerId);
        if (counter > 0) {
            str = str + encode_1$1(alphabet_1$1.lookup, counter);
        }
        str = str + encode_1$1(alphabet_1$1.lookup, seconds);

        return str;
    }

    var build_1 = build;

    function isShortId$1(id) {
        if (!id || typeof id !== 'string' || id.length < 6 ) {
            return false;
        }

        var characters = alphabet_1$1.characters();
        var len = id.length;
        for(var i = 0; i < len;i++) {
            if (characters.indexOf(id[i]) === -1) {
                return false;
            }
        }
        return true;
    }

    var isValid$1 = isShortId$1;

    var lib$3 = createCommonjsModule$1(function (module) {







    // if you are using cluster or multiple servers use this to make each instance
    // has a unique value for worker
    // Note: I don't know if this is automatically set when using third
    // party cluster solutions such as pm2.
    var clusterWorkerId =  0;

    /**
     * Set the seed.
     * Highly recommended if you don't want people to try to figure out your id schema.
     * exposed as shortid.seed(int)
     * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
     */
    function seed(seedValue) {
        alphabet_1$1.seed(seedValue);
        return module.exports;
    }

    /**
     * Set the cluster worker or machine id
     * exposed as shortid.worker(int)
     * @param workerId worker must be positive integer.  Number less than 16 is recommended.
     * returns shortid module so it can be chained.
     */
    function worker(workerId) {
        clusterWorkerId = workerId;
        return module.exports;
    }

    /**
     *
     * sets new characters to use in the alphabet
     * returns the shuffled alphabet
     */
    function characters(newCharacters) {
        if (newCharacters !== undefined) {
            alphabet_1$1.characters(newCharacters);
        }

        return alphabet_1$1.shuffled();
    }

    /**
     * Generate unique id
     * Returns string id
     */
    function generate() {
      return build_1(clusterWorkerId);
    }

    // Export all other functions as properties of the generate function
    module.exports = generate;
    module.exports.generate = generate;
    module.exports.seed = seed;
    module.exports.worker = worker;
    module.exports.characters = characters;
    module.exports.decode = decode_1$1;
    module.exports.isValid = isValid$1;
    });
    var lib_1$1 = lib$3.generate;
    var lib_2$1 = lib$3.seed;
    var lib_3$1 = lib$3.worker;
    var lib_4$1 = lib$3.characters;
    var lib_5$1 = lib$3.decode;
    var lib_6$1 = lib$3.isValid;

    var shortid$1 = lib$3;

    var SaveContextMethodName = "T42.HC.GetSaveContext";
    var ContextProvider = (function () {
        function ContextProvider(config, activitiesGetter, callbacks, logger) {
            this.config = config;
            this.activitiesGetter = activitiesGetter;
            this.callbacks = callbacks;
            this.logger = logger;
            this.interop = config.agm;
            this.registerRequestMethods();
        }
        ContextProvider.prototype.onSaveRequested = function (callback) {
            return this.callbacks.add("saveRequested", callback);
        };
        ContextProvider.prototype.isActivityOwner = function () {
            if (typeof htmlContainer !== "undefined") {
                var context_1 = htmlContainer.getContext();
                return context_1 && context_1._t42 && context_1._t42.activityIsOwner;
            }
            var activities = this.activitiesGetter();
            if (!activities) {
                return false;
            }
            if (!activities.inActivity) {
                return false;
            }
            var myWindow = activities.my.window;
            var myActivity = activities.my.activity;
            if (!myActivity && !myWindow) {
                return false;
            }
            return myActivity.owner.id === myWindow.id;
        };
        ContextProvider.prototype.registerRequestMethods = function () {
            var _this = this;
            this.interop.register(SaveContextMethodName, function (args) {
                var _a, _b, _c;
                var usersCbs = _this.callbacks.execute("saveRequested", args);
                if (((_a = usersCbs) === null || _a === void 0 ? void 0 : _a.length) > 1) {
                    _this.logger.warn("Multiple subscriptions for \"glue.layouts.onSaveRequested\" - only the first one will be used");
                }
                var requestResult = usersCbs[0];
                var autoSaveWindowContext = _this.config.autoSaveWindowContext;
                if (autoSaveWindowContext) {
                    return { autoSaveWindowContext: autoSaveWindowContext };
                }
                var result = { windowContext: (_b = requestResult) === null || _b === void 0 ? void 0 : _b.windowContext, activityContext: undefined };
                if (_this.isActivityOwner()) {
                    result.activityContext = (_c = requestResult) === null || _c === void 0 ? void 0 : _c.activityContext;
                }
                return result;
            });
        };
        return ContextProvider;
    }());

    function transformACSLayout(something) {
        if (!something) {
            return something;
        }
        if (Array.isArray(something)) {
            return something.map(function (item) {
                return transformACSLayout(item);
            });
        }
        if (typeof something === "string" || typeof something === "number" || typeof something === "boolean") {
            return something;
        }
        var initial = {};
        return Object.keys(something).reduce(function (accumulator, current) {
            var value = something[current];
            var convertedValue = transformACSLayout(value);
            var key = current;
            if (current[0].toLowerCase() !== current[0]) {
                key = current[0].toLowerCase() + current.substr(1);
            }
            accumulator[key] = convertedValue;
            return accumulator;
        }, initial);
    }

    var LayoutImpl = (function () {
        function LayoutImpl(data) {
            this.name = data.name;
            this.type = data.type;
            this.components = data.components;
            this.context = data.context;
            this.metadata = data.metadata;
            this.version = data.version;
            this.displays = data.displays;
        }
        return LayoutImpl;
    }());

    var LayoutsAPIImpl = (function () {
        function LayoutsAPIImpl(config, stream, callbacks, logger) {
            this.config = config;
            this.stream = stream;
            this.callbacks = callbacks;
            this.appManager = config.appManager;
            this.onEvent = stream.onEvent;
            this.provider = new ContextProvider(config, config.activityGetter, callbacks, logger);
            stream.subscribe();
        }
        LayoutsAPIImpl.prototype.setDefaultGlobal = function (name) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.config.agm.invoke("T42.ACS.SelectDefaultLayout", { name: name })];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        LayoutsAPIImpl.prototype.clearDefaultGlobal = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.config.agm.invoke("T42.ACS.DeselectDefaultLayout")];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        LayoutsAPIImpl.prototype.getDefaultGlobal = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result, layout;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.config.agm.invoke("T42.ACS.GetDefaultLayout")];
                        case 1:
                            result = _a.sent();
                            layout = result.returned;
                            if (!layout) {
                                return [2, undefined];
                            }
                            if (this.isSlimMode()) {
                                return [2, layout];
                            }
                            return [2, this.list().find(function (l) { return l.name === layout.name && l.type === "Global"; })];
                    }
                });
            });
        };
        LayoutsAPIImpl.prototype.ready = function () {
            if (this.config.mode === "fullWaitSnapshot") {
                return this.stream.gotSnapshot;
            }
            return this.stream.ready;
        };
        LayoutsAPIImpl.prototype.save = function (layout) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.verifyNotSlimMode();
                if (!layout.name) {
                    throw Error("layout.name argument is required");
                }
                if (!layout.type) {
                    layout.type = "Global";
                }
                if (layout.activityId) {
                    layout.type = "Activity";
                }
                if (typeof layout.ignoreHidden === "undefined") {
                    layout.ignoreHidden = true;
                }
                var layoutObject = {
                    name: layout.name,
                    actIds: [],
                    appIds: [],
                    type: layout.type,
                    context: layout.context,
                    metadata: layout.metadata || {},
                    options: { ignoreLayoutRestrictions: false },
                };
                if (layout.type === "Activity") {
                    var actId = layout.activityId;
                    if (!actId) {
                        if (!_this.appManager.myInstance.inActivity) {
                            throw new Error("Current application is not in activity. Can not save activity layout for it");
                        }
                        actId = _this.appManager.myInstance.activityId;
                    }
                    layoutObject.actIds.push(actId);
                    layoutObject.options = { ignoreLayoutRestrictions: true };
                }
                else if (layout.type === "Global") {
                    if (_this.config.gdMajorVersion === 2) {
                        var instances = _this.appManager.instances();
                        if (layout.ignoreHidden) {
                            instances = instances.filter(function (i) { return _this.isVisibleWindow(i); });
                        }
                        if (layout.ignoreMyInstance && _this.appManager.myInstance) {
                            instances = instances.filter(function (i) { return i.id !== _this.appManager.myInstance.id; });
                        }
                        instances.reduce(function (prev, current) {
                            if (!current.id) {
                                return prev;
                            }
                            if (current.inActivity) {
                                var actId = current.activityId;
                                if (prev.actIds.indexOf(actId) === -1) {
                                    prev.actIds.push(actId);
                                }
                            }
                            else {
                                prev.appIds.push(current.id);
                            }
                            return prev;
                        }, layoutObject);
                    }
                    else {
                        layoutObject.autoCollectApps = true;
                    }
                }
                else {
                    throw new Error("layout type " + layout.type + " not supported");
                }
                _this.invokeMethodAndTrack("T42.ACS.SaveLayout", layoutObject, resolve, reject);
            });
        };
        LayoutsAPIImpl.prototype.restore = function (options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.verifyNotSlimMode();
                if (typeof options === "undefined") {
                    throw Error("options argument is required");
                }
                if (!options.name) {
                    throw Error("options.name argument is required");
                }
                if (!options.type) {
                    options.type = "Global";
                }
                if (options.activityIdToJoin) {
                    options.type = "Activity";
                }
                if (typeof options.restoreActivityOwner === "undefined") {
                    options.restoreActivityOwner = false;
                }
                if (typeof options.ignoreActivityWindowTypes === "undefined") {
                    options.ignoreActivityWindowTypes = [];
                }
                if (typeof options.setActivityContext === "undefined") {
                    options.setActivityContext = true;
                }
                if (typeof options.closeRunningInstance === "undefined") {
                    if (options.type === "Global") {
                        options.closeRunningInstance = true;
                    }
                    else if (options.type === "Activity") {
                        options.closeRunningInstance = false;
                    }
                }
                if (typeof options.reuseWindows === "undefined") {
                    options.reuseWindows = true;
                }
                options.context = options.context || {};
                var t42 = {
                    restoreOptions: {
                        activityToJoin: options.activityIdToJoin,
                        setActivityContext: options.setActivityContext,
                        ignoreActivityWindowTypes: options.ignoreActivityWindowTypes,
                        restoreActivityOwner: options.restoreActivityOwner,
                        closeOldWindows: options.closeRunningInstance,
                        reuseExistingWindows: options.reuseWindows
                    }
                };
                var arg = {
                    type: options.type,
                    name: options.name,
                    context: options.context,
                    toClose: [],
                    splash: options.splash
                };
                if (_this.config.gdMajorVersion === 2) {
                    if (options.closeRunningInstance) {
                        arg.toClose = _this.getInstancesToClose(options);
                    }
                }
                if (options.timeout) {
                    arg.timeout = options.timeout;
                }
                arg.context._t42 = t42;
                _this.invokeMethodAndTrack("T42.ACS.RestoreLayout", arg, resolve, reject, true);
            });
        };
        LayoutsAPIImpl.prototype.remove = function (type, name) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.verifyNotSlimMode();
                if (!name) {
                    throw Error("name argument is required");
                }
                if (!type) {
                    throw Error("type argument is required");
                }
                var msg = {
                    type: type,
                    name: name,
                };
                _this.invokeMethodAndTrack("T42.ACS.RemoveLayout", msg, resolve, reject);
            });
        };
        LayoutsAPIImpl.prototype.list = function () {
            this.verifyNotSlimMode();
            return store.all;
        };
        LayoutsAPIImpl.prototype.import = function (layouts, mode) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.verifyNotSlimMode();
                var msg = {
                    mode: mode || "replace",
                    layouts: layouts
                };
                _this.invokeMethodAndTrack("T42.ACS.ImportLayouts", msg, resolve, reject, true);
            });
        };
        LayoutsAPIImpl.prototype.export = function (layoutType) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var handleResult = function (result) {
                    var layouts = _this.getObjectValues(result.Layouts).map(function (t) { return new LayoutImpl(transformACSLayout(t)); });
                    if (layoutType) {
                        layouts = layouts.filter(function (l) { return l.type === layoutType; });
                    }
                    resolve(layouts);
                };
                _this.invokeMethodAndTrack("T42.ACS.ExportLayouts", {}, handleResult, reject, true);
            });
        };
        LayoutsAPIImpl.prototype.rename = function (layout, newName) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                _this.verifyNotSlimMode();
                if (!layout) {
                    throw Error("layout argument is required");
                }
                if (!layout.name) {
                    throw Error("name argument is required");
                }
                if (!layout.type) {
                    throw Error("type argument is required");
                }
                var msg = { type: layout.type, oldName: layout.name, newName: newName };
                _this.invokeMethodAndTrack("T42.ACS.RenameLayout", msg, resolve, reject);
            });
        };
        LayoutsAPIImpl.prototype.updateMetadata = function (layout) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!layout) {
                    throw Error("layout argument is required");
                }
                if (!layout.name) {
                    throw Error("name argument is required");
                }
                if (!layout.type) {
                    throw Error("type argument is required");
                }
                if (!layout.metadata) {
                    throw Error("metadata argument is required");
                }
                var layoutObject = {
                    name: layout.name,
                    type: layout.type,
                    metadata: layout.metadata
                };
                _this.invokeMethodAndTrack("T42.ACS.UpdateMetadata", layoutObject, resolve, reject, true);
            });
        };
        LayoutsAPIImpl.prototype.hibernate = function (name, options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!name) {
                    return reject("name cannot be empty");
                }
                options = options || {};
                var request = {
                    name: name,
                    type: "Global",
                    context: options.context || {},
                    metadata: options.metadata || {},
                };
                _this.invokeMethodAndTrack("T42.ACS.HibernateLayout", request, resolve, reject, true);
            });
        };
        LayoutsAPIImpl.prototype.resume = function (name, context, options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!name) {
                    return reject("name cannot be empty");
                }
                var request = __assign({ name: name, type: "Global", context: context }, options);
                _this.invokeMethodAndTrack("T42.ACS.ResumeLayout", request, resolve, reject, true);
            });
        };
        LayoutsAPIImpl.prototype.getCurrentLayout = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result, layout;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.config.agm.invoke("T42.ACS.GetCurrentLayout", {}, "best", { methodResponseTimeoutMs: 120 * 1000 })];
                        case 1:
                            result = _a.sent();
                            layout = result.returned.layout;
                            if (!layout) {
                                return [2, undefined];
                            }
                            if (!this.isSlimMode()) {
                                layout = this.list().find(function (l) { return l.name === layout.name && l.type === layout.type; });
                            }
                            return [2, layout];
                    }
                });
            });
        };
        LayoutsAPIImpl.prototype.onAdded = function (callback) {
            var result = this.callbacks.add("added", callback);
            if (store.all.length > 0) {
                store.all.forEach(function (layout) {
                    try {
                        callback(layout);
                    }
                    catch (err) { }
                });
            }
            return result;
        };
        LayoutsAPIImpl.prototype.onRemoved = function (callback) {
            return this.callbacks.add("removed", callback);
        };
        LayoutsAPIImpl.prototype.onChanged = function (callback) {
            return this.callbacks.add("changed", callback);
        };
        LayoutsAPIImpl.prototype.onRestored = function (callback) {
            return this.callbacks.add("restored", callback);
        };
        LayoutsAPIImpl.prototype.onRenamed = function (callback) {
            return this.callbacks.add("renamed", callback);
        };
        LayoutsAPIImpl.prototype.onEvent = function (callback) {
            return this.stream.onEvent(callback);
        };
        LayoutsAPIImpl.prototype.onSaveRequested = function (callback) {
            return this.provider.onSaveRequested(callback);
        };
        LayoutsAPIImpl.prototype.updateAppContextInCurrent = function (context) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (context && typeof context !== "object") {
                    reject("context must be an object");
                }
                context = (context !== null && context !== void 0 ? context : {});
                var request = {
                    context: context
                };
                _this.invokeMethodAndTrack("T42.ACS.UpdateLayoutComponentContext", request, resolve, reject, true);
            });
        };
        LayoutsAPIImpl.prototype.updateDefaultContext = function (context) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (context && typeof context !== "object") {
                    reject("context must be an object");
                }
                context = (context !== null && context !== void 0 ? context : {});
                var request = {
                    context: context
                };
                _this.invokeMethodAndTrack("T42.ACS.UpdateDefaultContext", request, resolve, reject, true);
            });
        };
        LayoutsAPIImpl.prototype.get = function (name, type) {
            var matching = this.list().find(function (l) { return l.name === name && l.type === type; });
            if (!matching) {
                return Promise.reject("can not find layout with name=" + name + " and type=" + type);
            }
            return Promise.resolve(matching);
        };
        LayoutsAPIImpl.prototype.getAll = function (type) {
            var matching = this.list().filter(function (l) { return type === l.type; });
            return Promise.resolve(matching);
        };
        LayoutsAPIImpl.prototype.isSlimMode = function () {
            return this.config.mode === "slim";
        };
        LayoutsAPIImpl.prototype.verifyNotSlimMode = function () {
            if (this.isSlimMode()) {
                throw Error("Operation not allowed in slim mode. Run in full mode.");
            }
        };
        LayoutsAPIImpl.prototype.isVisibleWindow = function (instance) {
            if (instance.application.type === "exe" || instance.application.type === "node") {
                return true;
            }
            if (instance.application.type === "activity") {
                return true;
            }
            if (!instance || !instance.window) {
                return false;
            }
            return instance.window.isVisible;
        };
        LayoutsAPIImpl.prototype.invokeMethodAndTrack = function (methodName, args, resolve, reject, skipStreamEvent) {
            var streamEventReceived = skipStreamEvent;
            var agmResult;
            var token = shortid$1();
            args.token = token;
            var handleResult = function () {
                if (streamEventReceived && agmResult) {
                    resolve(agmResult);
                }
            };
            if (!skipStreamEvent) {
                this.stream.waitFor(token)
                    .then(function () {
                    streamEventReceived = true;
                    handleResult();
                })
                    .catch(function (err) {
                    reject(err);
                });
            }
            var responseHandler = function (result) {
                if (!result.returned) {
                    reject("No result from method " + methodName);
                }
                if (result.returned.status && (result.returned.status !== "Success" && result.returned.status !== "PartialSuccess")) {
                    reject(result.returned);
                }
                agmResult = result.returned;
                handleResult();
            };
            this.config.agm.invoke(methodName, args, "best", { methodResponseTimeoutMs: 120 * 1000 })
                .then(responseHandler)
                .catch(function (err) { return reject(err); });
        };
        LayoutsAPIImpl.prototype.getInstancesToClose = function (options) {
            var _this = this;
            var instances = [];
            var shellApp = this.appManager.applications().filter(function (a) { return a.isShell; })[0];
            var shellApplicationName = shellApp ? shellApp.name : "AppManager";
            this.appManager.instances().forEach(function (i) {
                if (_this.appManager.myInstance && i.id === _this.appManager.myInstance.id) {
                    return;
                }
                if (i.application.name === shellApplicationName) {
                    return;
                }
                if (!_this.isVisibleWindow(i)) {
                    return;
                }
                if (options.type === "Activity") {
                    if (i.activityId !== options.activityIdToJoin) {
                        return;
                    }
                }
                instances.push({ application: i.application.name, instance: i.id });
            });
            return instances;
        };
        LayoutsAPIImpl.prototype.getObjectValues = function (obj) {
            if (!obj) {
                return [];
            }
            return Object.keys(obj).map(function (k) { return obj[k]; });
        };
        return LayoutsAPIImpl;
    }());

    var ACSStream = (function () {
        function ACSStream(agm, callbacks) {
            var _this = this;
            this.agm = agm;
            this.callbacks = callbacks;
            this.ready = new Promise(function (resolve, reject) {
                _this.resolveReady = resolve;
                _this.rejectReady = reject;
            });
            this.gotSnapshot = new Promise(function (resolve, reject) {
                _this.resolveGotSnapshot = resolve;
                _this.rejectGotSnapshot = reject;
            });
        }
        ACSStream.prototype.subscribe = function (noRetry) {
            var _this = this;
            var transform = function (obj) {
                return _this.getObjectValues(obj).map(function (t) { return transformACSLayout(t); });
            };
            if (!this.checkForLayoutEventMethod()) {
                if (noRetry) {
                    this.resolveReady();
                }
                setTimeout(function () {
                    _this.subscribe(true);
                }, 500);
            }
            else {
                this.agm.subscribe("T42.ACS.OnLayoutEvent", { waitTimeoutMs: 10000 })
                    .then(function (subs) {
                    subs.onData(function (args) {
                        var data = args.data;
                        if (data.IsSnapshot) {
                            _this.resolveGotSnapshot();
                        }
                        _this.addLayouts(transform(data.OnLayoutAdded));
                        _this.removeLayouts(transform(data.OnLayoutRemoved));
                        _this.changeLayouts(transform(data.OnLayoutChanged));
                        _this.renameLayouts(transform(data.OnLayoutRenamed));
                        _this.restoredLayout(transform(data.OnLayoutRestored));
                        _this.callbacks.execute("streamEvent", data);
                    });
                    subs.onFailed(function (err) {
                        var msg = "can not subscribe to T42.ACS.OnLayoutEvent " + err;
                        _this.rejectReady(msg);
                        _this.rejectGotSnapshot(msg);
                    });
                    _this.resolveReady();
                })
                    .catch(function (err) {
                    var msg = "Error subscribing for T42.ACS.OnLayoutEvent stream. Err: " + err;
                    _this.rejectReady(msg);
                    _this.rejectGotSnapshot(msg);
                });
            }
        };
        ACSStream.prototype.onEvent = function (callback) {
            return this.callbacks.add("streamEvent", callback);
        };
        ACSStream.prototype.waitFor = function (token, timeout) {
            var _this = this;
            if (!timeout) {
                timeout = 10000;
            }
            return new Promise(function (resolve, reject) {
                var done = false;
                var unsubscribe = _this.onEvent(function (streamEvent) {
                    if (streamEvent.Token === token) {
                        done = true;
                        unsubscribe();
                        resolve();
                    }
                });
                setTimeout(function () {
                    if (!done) {
                        reject("timed out");
                    }
                }, timeout);
            });
        };
        ACSStream.prototype.checkForLayoutEventMethod = function () {
            try {
                return this.agm
                    .methods()
                    .map(function (m) { return m.name; })
                    .indexOf("T42.ACS.OnLayoutEvent") !== -1;
            }
            catch (e) {
                return false;
            }
        };
        ACSStream.prototype.addLayouts = function (layoutsData) {
            var _this = this;
            if (!layoutsData) {
                return;
            }
            layoutsData.forEach(function (layoutData) {
                var layout = new LayoutImpl(layoutData);
                store.add(layout);
                _this.callbacks.execute("added", layout);
            });
        };
        ACSStream.prototype.removeLayouts = function (removedLayouts) {
            var _this = this;
            if (!removedLayouts) {
                return;
            }
            removedLayouts.forEach(function (removedLayout) {
                store.removeWhere(function (existingLayout) { return !_this.compareLayouts(existingLayout, removedLayout); });
                _this.callbacks.execute("removed", removedLayout);
            });
        };
        ACSStream.prototype.changeLayouts = function (changedLayouts) {
            var _this = this;
            if (!changedLayouts) {
                return;
            }
            changedLayouts.forEach(function (changedLayout) {
                store.removeWhere(function (existingLayout) { return !_this.compareLayouts(existingLayout, changedLayout); });
                store.add(new LayoutImpl(changedLayout));
                _this.callbacks.execute("changed", changedLayout);
            });
        };
        ACSStream.prototype.renameLayouts = function (renamedLayouts) {
            var _this = this;
            if (!renamedLayouts) {
                return;
            }
            renamedLayouts.forEach(function (renamedLayout) {
                var existingLayout = store.first(function (current) { return _this.compareLayouts(current, { type: renamedLayout.type, name: renamedLayout.oldName }); });
                if (!existingLayout) {
                    throw Error("received rename event for unknown layout with type " + renamedLayout.type + " and name " + renamedLayout.oldName);
                }
                existingLayout.name = renamedLayout.newName;
                _this.callbacks.execute("renamed", existingLayout);
            });
        };
        ACSStream.prototype.compareLayouts = function (layout1, layout2) {
            return layout1.name === layout2.name && layout1.type === layout2.type;
        };
        ACSStream.prototype.getObjectValues = function (obj) {
            if (!obj) {
                return [];
            }
            return Object.keys(obj).map(function (k) { return obj[k]; });
        };
        ACSStream.prototype.restoredLayout = function (restoredLayouts) {
            var _this = this;
            if (!restoredLayouts) {
                return;
            }
            restoredLayouts.forEach(function (restoredLayout) {
                var existingLayout = store.first(function (current) { return _this.compareLayouts(current, { type: restoredLayout.type, name: restoredLayout.name }); });
                _this.callbacks.execute("restored", existingLayout);
            });
        };
        return ACSStream;
    }());

    function streamNull () {
        return {
            ready: Promise.resolve(undefined),
            subscribe: function () { },
            onEvent: function (callback) { return function () { }; },
            waitFor: function (token, timeout) { return Promise.resolve(undefined); },
            gotSnapshot: Promise.resolve(undefined),
        };
    }

    function LayoutsFactory (config) {
        if (!config.agm) {
            throw Error("config.agm is required");
        }
        if (!config.logger) {
            throw Error("config.logger is required");
        }
        config.mode = config.mode || "slim";
        var logger = config.logger;
        var callbacks = lib$2();
        var acsStream;
        if (config.mode === "full" || "fullWaitSnapshot") {
            acsStream = new ACSStream(config.agm, callbacks);
        }
        else {
            acsStream = streamNull();
        }
        return new LayoutsAPIImpl(config, acsStream, callbacks, logger);
    }

    var T42DisplayCommand = "T42.Displays.Command";
    var DisplayManager = (function () {
        function DisplayManager(_agm, _logger) {
            var _this = this;
            this._agm = _agm;
            this._logger = _logger;
            this.all = function () { return __awaiter(_this, void 0, void 0, function () {
                var displays;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.callGD(DisplayCommand.GetAll, {})];
                        case 1:
                            displays = _a.sent();
                            return [2, displays.map(this.decorateDisplay)];
                    }
                });
            }); };
            this.get = function (id) { return __awaiter(_this, void 0, void 0, function () {
                var display;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.callGD(DisplayCommand.Get, { id: id })];
                        case 1:
                            display = _a.sent();
                            return [2, this.decorateDisplay(display)];
                    }
                });
            }); };
            this.getPrimary = function () { return __awaiter(_this, void 0, void 0, function () {
                var primary;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.all()];
                        case 1:
                            primary = (_a.sent()).find(function (d) { return d.isPrimary; });
                            return [2, primary];
                    }
                });
            }); };
            this.capture = function (options) { return __awaiter(_this, void 0, void 0, function () {
                var screenshot;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.callGD(DisplayCommand.Capture, __assign({}, options))];
                        case 1:
                            screenshot = _a.sent();
                            return [2, screenshot];
                    }
                });
            }); };
            this.captureAll = function (options) { return __awaiter(_this, void 0, void 0, function () {
                var screenshots;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.callGD(DisplayCommand.CaptureAll, __assign({}, options))];
                        case 1:
                            screenshots = _a.sent();
                            return [2, screenshots];
                    }
                });
            }); };
            this.getMousePosition = function () { return __awaiter(_this, void 0, void 0, function () {
                var point;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.callGD(DisplayCommand.GetMousePosition)];
                        case 1:
                            point = _a.sent();
                            return [2, point];
                    }
                });
            }); };
            this.callGD = function (command, options) { return __awaiter(_this, void 0, void 0, function () {
                var invocationResult;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this._agm.invoke(T42DisplayCommand, { options: __assign({}, options), command: command })];
                        case 1:
                            invocationResult = _a.sent();
                            return [2, invocationResult.returned.data];
                    }
                });
            }); };
            this.decorateDisplay = function (original) {
                return __assign(__assign({}, original), { capture: function (size) { return _this.capture({ id: original.id, size: size }); } });
            };
        }
        return DisplayManager;
    }());
    var DisplayCommand;
    (function (DisplayCommand) {
        DisplayCommand["Capture"] = "capture";
        DisplayCommand["CaptureAll"] = "captureAll";
        DisplayCommand["GetAll"] = "getAll";
        DisplayCommand["Get"] = "get";
        DisplayCommand["GetMousePosition"] = "getMousePosition";
    })(DisplayCommand || (DisplayCommand = {}));

    var interop;
    var windowId;
    function setupAGM(interopLib, channels) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        interop = interopLib;
                        if (typeof window !== "undefined") {
                            if (window.glue42gd) {
                                windowId = window.glue42gd.windowId;
                            }
                        }
                        if (!windowId) {
                            return [2];
                        }
                        return [4, interop.register("T42.Channels.Command", function (args) {
                                var command = args.command;
                                if (!command) {
                                    throw new Error("missing command argument");
                                }
                                if (command === "join") {
                                    var id = args.channel;
                                    if (!id) {
                                        throw new Error("missing argument id");
                                    }
                                    channels.joinNoSelectorSwitch(id);
                                    return;
                                }
                                if (command === "leave") {
                                    channels.leaveNoSelectorSwitch();
                                    return;
                                }
                                if (command === "get") {
                                    var id = channels.current();
                                    return { id: id };
                                }
                                throw new Error("unknown command " + command);
                            })];
                    case 1:
                        _a.sent();
                        interop.invoke("T42.Channels.Announce", { swId: windowId, instance: interop.instance.instance });
                        return [2];
                }
            });
        });
    }
    function switchChannel(channel, id) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                interop.invoke("T42.Channels.Announce", {
                    swId: (id !== null && id !== void 0 ? id : windowId),
                    command: "switchChannel",
                    data: { newChannel: channel }
                });
                return [2];
            });
        });
    }

    var CONTEXT_PREFIX = "___channel___";
    var SharedContextSubscriber = (function () {
        function SharedContextSubscriber(contexts) {
            this.contexts = contexts;
        }
        SharedContextSubscriber.prototype.subscribe = function (callback) {
            this.callback = callback;
        };
        SharedContextSubscriber.prototype.subscribeFor = function (name, callback) {
            if (!this.isChannel(name)) {
                return Promise.reject(new Error("Channel with name: " + name + " doesn't exist!"));
            }
            var contextName = this.createContextName(name);
            return this.contexts.subscribe(contextName, function (data, _, __, ___, extraData) {
                var _a;
                callback(data.data, data, (_a = extraData) === null || _a === void 0 ? void 0 : _a.updaterId);
            });
        };
        SharedContextSubscriber.prototype.switchChannel = function (name) {
            return __awaiter(this, void 0, void 0, function () {
                var contextName, _a;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.unsubscribe();
                            contextName = this.createContextName(name);
                            _a = this;
                            return [4, this.contexts.subscribe(contextName, function (data, _, __, ___, extraData) {
                                    var _a;
                                    if (_this.callback) {
                                        _this.callback(data.data, data, (_a = extraData) === null || _a === void 0 ? void 0 : _a.updaterId);
                                    }
                                })];
                        case 1:
                            _a.unsubscribeFunc = _b.sent();
                            return [2];
                    }
                });
            });
        };
        SharedContextSubscriber.prototype.unsubscribe = function () {
            if (this.unsubscribeFunc) {
                this.unsubscribeFunc();
            }
        };
        SharedContextSubscriber.prototype.all = function () {
            var contextNames = this.contexts.all();
            var channelContextNames = contextNames.filter(function (contextName) { return contextName.startsWith(CONTEXT_PREFIX); });
            var channelNames = channelContextNames.map(function (channelContextName) { return channelContextName.substr(CONTEXT_PREFIX.length); });
            return channelNames;
        };
        SharedContextSubscriber.prototype.getContextData = function (name) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (!_this.isChannel(name)) {
                    return reject(new Error("A channel with name: " + name + " doesn't exist!"));
                }
                var contextName = _this.createContextName(name);
                _this.contexts.subscribe(contextName, function (data) {
                    resolve(data);
                }).then(function (unsubscribeFunc) { return unsubscribeFunc(); });
            });
        };
        SharedContextSubscriber.prototype.updateChannel = function (name, data) {
            var contextName = this.createContextName(name);
            return this.contexts.update(contextName, data);
        };
        SharedContextSubscriber.prototype.updateData = function (name, data) {
            var contextName = this.createContextName(name);
            if (this.contexts.setPathSupported) {
                var pathValues = Object.keys(data).map(function (key) {
                    return {
                        path: "data." + key,
                        value: data[key]
                    };
                });
                return this.contexts.setPaths(contextName, pathValues);
            }
            else {
                return this.contexts.update(contextName, { data: data });
            }
        };
        SharedContextSubscriber.prototype.isChannel = function (name) {
            return this.all().some(function (channelName) { return channelName === name; });
        };
        SharedContextSubscriber.prototype.createContextName = function (name) {
            return CONTEXT_PREFIX + name;
        };
        return SharedContextSubscriber;
    }());

    var ChannelsImpl = (function () {
        function ChannelsImpl(shared) {
            this.shared = shared;
            this.subsKey = "subs";
            this.changedKey = "changed";
            this.registry = lib$2();
            this.shared.subscribe(this.handler.bind(this));
        }
        ChannelsImpl.prototype.subscribe = function (callback) {
            if (typeof callback !== "function") {
                throw new Error("Please provide the callback as a function!");
            }
            return this.registry.add(this.subsKey, callback);
        };
        ChannelsImpl.prototype.subscribeFor = function (name, callback) {
            return __awaiter(this, void 0, void 0, function () {
                var unsubscribeFunc;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (typeof name !== "string") {
                                throw new Error("Please provide the name as a string!");
                            }
                            if (typeof callback !== "function") {
                                throw new Error("Please provide the callback as a function!");
                            }
                            return [4, this.shared.subscribeFor(name, callback)];
                        case 1:
                            unsubscribeFunc = _a.sent();
                            return [2, unsubscribeFunc];
                    }
                });
            });
        };
        ChannelsImpl.prototype.publish = function (data, name) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (typeof data !== "object") {
                        throw new Error("Please provide the data as an object!");
                    }
                    if (name) {
                        if (typeof name !== "string") {
                            throw new Error("Please provide the name as a string!");
                        }
                        if (!this.shared.isChannel(name)) {
                            return [2, Promise.reject(new Error("A channel with name: " + name + " doesn't exist!"))];
                        }
                        return [2, this.shared.updateData(name, data)];
                    }
                    if (!this.currentContext) {
                        throw new Error("Not joined to any channel!");
                    }
                    return [2, this.shared.updateData(this.currentContext, data)];
                });
            });
        };
        ChannelsImpl.prototype.all = function () {
            var channelNames = this.shared.all();
            return Promise.resolve(channelNames);
        };
        ChannelsImpl.prototype.list = function () {
            return __awaiter(this, void 0, void 0, function () {
                var channelNames, channelContexts;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.all()];
                        case 1:
                            channelNames = _a.sent();
                            return [4, Promise.all(channelNames.map(function (channelName) { return _this.get(channelName); }))];
                        case 2:
                            channelContexts = _a.sent();
                            return [2, channelContexts];
                    }
                });
            });
        };
        ChannelsImpl.prototype.get = function (name) {
            if (typeof name !== "string") {
                return Promise.reject(new Error("Please provide the channel name as a string!"));
            }
            return this.shared.getContextData(name);
        };
        ChannelsImpl.prototype.join = function (name) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2, this.joinCore(name)];
                });
            });
        };
        ChannelsImpl.prototype.joinNoSelectorSwitch = function (name) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2, this.joinCore(name, false)];
                });
            });
        };
        ChannelsImpl.prototype.leave = function () {
            return this.leaveCore();
        };
        ChannelsImpl.prototype.leaveNoSelectorSwitch = function () {
            return this.leaveCore(false);
        };
        ChannelsImpl.prototype.current = function () {
            return this.currentContext;
        };
        ChannelsImpl.prototype.my = function () {
            return this.current();
        };
        ChannelsImpl.prototype.changed = function (callback) {
            if (typeof callback !== "function") {
                throw new Error("Please provide the callback as a function!");
            }
            return this.registry.add(this.changedKey, callback);
        };
        ChannelsImpl.prototype.onChanged = function (callback) {
            return this.changed(callback);
        };
        ChannelsImpl.prototype.add = function (info) {
            return __awaiter(this, void 0, void 0, function () {
                var context;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (typeof info !== "object") {
                                throw new Error("Please provide the info as an object!");
                            }
                            if (typeof info.name === "undefined") {
                                throw new Error("info.name is missing!");
                            }
                            if (typeof info.name !== "string") {
                                throw new Error("Please provide the info.name as a string!");
                            }
                            if (typeof info.meta === "undefined") {
                                throw new Error("info.meta is missing!");
                            }
                            if (typeof info.meta !== "object") {
                                throw new Error("Please provide the info.meta as an object!");
                            }
                            if (typeof info.meta.color === "undefined") {
                                throw new Error("info.meta.color is missing!");
                            }
                            if (typeof info.meta.color !== "string") {
                                throw new Error("Please provide the info.meta.color as a string!");
                            }
                            context = {
                                name: info.name,
                                meta: info.meta || {},
                                data: info.data || {}
                            };
                            return [4, this.shared.updateChannel(info.name, context)];
                        case 1:
                            _a.sent();
                            return [2, context];
                    }
                });
            });
        };
        ChannelsImpl.prototype.handler = function (data, context, updaterId) {
            this.registry.execute(this.subsKey, data, context, updaterId);
        };
        ChannelsImpl.prototype.joinCore = function (name, changeSelector) {
            if (changeSelector === void 0) { changeSelector = true; }
            return __awaiter(this, void 0, void 0, function () {
                var doesChannelExist, channelExistsPromise;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (typeof name !== "string") {
                                throw new Error("Please provide the channel name as a string!");
                            }
                            if (name === this.currentContext) {
                                return [2];
                            }
                            doesChannelExist = function (channelName) {
                                var channelNames = _this.shared.all();
                                return channelNames.includes(channelName);
                            };
                            if (!!doesChannelExist(name)) return [3, 2];
                            channelExistsPromise = new Promise(function (resolve, reject) {
                                var timeoutId;
                                var intervalId = setInterval(function () {
                                    if (doesChannelExist(name)) {
                                        clearTimeout(timeoutId);
                                        clearInterval(intervalId);
                                        resolve();
                                    }
                                }, 100);
                                timeoutId = setTimeout(function () {
                                    clearInterval(intervalId);
                                    return reject(new Error("A channel with name: " + name + " doesn't exist!"));
                                }, 3000);
                            });
                            return [4, channelExistsPromise];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            this.currentContext = name;
                            return [4, this.shared.switchChannel(name)];
                        case 3:
                            _a.sent();
                            if (changeSelector) {
                                switchChannel(name);
                            }
                            this.registry.execute(this.changedKey, name);
                            return [2];
                    }
                });
            });
        };
        ChannelsImpl.prototype.leaveCore = function (changeSelector) {
            if (changeSelector === void 0) { changeSelector = true; }
            this.currentContext = undefined;
            this.registry.execute(this.changedKey, undefined);
            this.shared.unsubscribe();
            if (changeSelector) {
                switchChannel();
            }
            return Promise.resolve();
        };
        return ChannelsImpl;
    }());

    function factory(contexts, agm) {
        var sharedContexts = new SharedContextSubscriber(contexts);
        var channels = new ChannelsImpl(sharedContexts);
        setupAGM(agm, channels);
        return {
            subscribe: channels.subscribe.bind(channels),
            subscribeFor: channels.subscribeFor.bind(channels),
            publish: channels.publish.bind(channels),
            all: channels.all.bind(channels),
            list: channels.list.bind(channels),
            get: channels.get.bind(channels),
            join: channels.join.bind(channels),
            leave: channels.leave.bind(channels),
            current: channels.current.bind(channels),
            my: channels.my.bind(channels),
            changed: channels.changed.bind(channels),
            onChanged: channels.onChanged.bind(channels),
            add: channels.add.bind(channels),
            ready: function () { return contexts.ready(); }
        };
    }

    var CommandMethod = "T42.Hotkeys.Command";
    var InvokeMethod = "T42.Hotkeys.Invoke";
    var RegisterCommand = "register";
    var UnregisterCommand = "unregister";
    var UnregisterAllCommand = "unregisterAll";
    var HotkeysImpl = (function () {
        function HotkeysImpl(agm) {
            this.agm = agm;
            this.registry = lib$2();
            this.firstHotkey = true;
            this.hotkeys = new Map();
        }
        HotkeysImpl.prototype.register = function (info, callback) {
            return __awaiter(this, void 0, void 0, function () {
                var hkToLower;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (typeof info === "undefined") {
                                throw new Error("Hotkey parameter missing");
                            }
                            if (typeof info === "string") {
                                info = {
                                    hotkey: info
                                };
                            }
                            else {
                                if (!info.hotkey) {
                                    throw new Error("Info's hotkey parameter missing");
                                }
                                info = {
                                    hotkey: info.hotkey,
                                    description: info.description
                                };
                            }
                            hkToLower = this.formatHotkey(info.hotkey);
                            if (this.hotkeys.has(hkToLower)) {
                                throw new Error("Shortcut for " + hkToLower + " already registered");
                            }
                            if (!this.firstHotkey) return [3, 2];
                            this.firstHotkey = false;
                            return [4, this.registerInvokeAGMMethod()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            this.registry.add(hkToLower, callback);
                            return [4, this.agm.invoke(CommandMethod, { command: RegisterCommand, hotkey: hkToLower, description: info.description })];
                        case 3:
                            _a.sent();
                            this.hotkeys.set(hkToLower, info);
                            return [2];
                    }
                });
            });
        };
        HotkeysImpl.prototype.unregister = function (hotkey) {
            return __awaiter(this, void 0, void 0, function () {
                var hkToLower;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (typeof hotkey === "undefined") {
                                throw new Error("hotkey parameter missing");
                            }
                            if (typeof hotkey !== "string") {
                                throw new Error("hotkey parameter must be string");
                            }
                            hkToLower = this.formatHotkey(hotkey);
                            return [4, this.agm.invoke(CommandMethod, { command: UnregisterCommand, hotkey: hkToLower })];
                        case 1:
                            _a.sent();
                            this.hotkeys.delete(hkToLower);
                            this.registry.clearKey(hkToLower);
                            return [2];
                    }
                });
            });
        };
        HotkeysImpl.prototype.unregisterAll = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.agm.invoke(CommandMethod, { command: UnregisterAllCommand })];
                        case 1:
                            _a.sent();
                            this.hotkeys.clear();
                            this.registry.clear();
                            return [2];
                    }
                });
            });
        };
        HotkeysImpl.prototype.isRegistered = function (hotkey) {
            var hkToLower = this.formatHotkey(hotkey);
            return this.hotkeys.has(hkToLower);
        };
        HotkeysImpl.prototype.registerInvokeAGMMethod = function () {
            var _this = this;
            this.agm.register(InvokeMethod, function (args) {
                var hkToLower = args.key.toLowerCase();
                var info = _this.hotkeys.get(hkToLower);
                _this.registry.execute(hkToLower, info);
            });
        };
        HotkeysImpl.prototype.formatHotkey = function (hotkey) {
            if (hotkey) {
                return hotkey.replace(/\s/g, "").toLowerCase();
            }
        };
        return HotkeysImpl;
    }());

    function factory$1(agm) {
        var hotkeys = new HotkeysImpl(agm);
        return {
            register: hotkeys.register.bind(hotkeys),
            unregister: hotkeys.unregister.bind(hotkeys),
            unregisterAll: hotkeys.unregisterAll.bind(hotkeys),
            isRegistered: hotkeys.isRegistered.bind(hotkeys),
            ready: function () { return Promise.resolve(); }
        };
    }

    var version$2 = "5.5.7";

    var prepareConfig$1 = (function (options) {
        function getLibConfig(value, defaultMode, trueMode) {
            if (typeof value === "boolean" && !value) {
                return undefined;
            }
            var mode = getModeAsString(value, defaultMode, trueMode);
            if (typeof value === "object") {
                value.mode = mode;
                return value;
            }
            return {
                mode: mode,
            };
        }
        function getModeAsString(value, defaultMode, trueMode) {
            if (typeof value === "object") {
                return getModeAsString(value.mode, defaultMode, trueMode) + "";
            }
            else if (typeof value === "undefined") {
                if (typeof defaultMode === "boolean" && !defaultMode) {
                    return undefined;
                }
                else {
                    return defaultMode + "";
                }
            }
            else if (typeof value === "boolean") {
                if (value) {
                    return ((trueMode === undefined) ? defaultMode : trueMode) + "";
                }
                else {
                    return undefined;
                }
            }
            return value + "";
        }
        var appDefaultMode = false;
        var appDefaultTrueMode = "startOnly";
        var activitiesDefaultMode = "trackMyTypeAndInitiatedFromMe";
        var layoutsDefaultMode = "slim";
        return {
            layouts: getLibConfig(options.layouts, layoutsDefaultMode),
            activities: getLibConfig(options.activities, activitiesDefaultMode),
            appManager: getLibConfig(options.appManager, appDefaultMode, appDefaultTrueMode),
            windows: getLibConfig(options.windows, true),
            channels: getLibConfig(options.channels || false, false),
            displays: getLibConfig(options.displays, true)
        };
    });

    var Glue42Notification = (function () {
        function Glue42Notification(options) {
            this.options = options;
            this.callbacks = lib$2();
            this.actions = options.actions;
            this.body = options.body;
            this.badge = options.badge;
            this.data = options.data;
            this.dir = options.dir;
            this.icon = options.icon;
            this.image = options.image;
            this.lang = options.lang;
            this.renotify = options.renotify;
            this.requireInteraction = options.requireInteraction;
            this.silent = options.silent;
            this.tag = options.tag;
            this.timestamp = options.timestamp;
            this.title = options.title;
        }
        Glue42Notification.prototype.close = function () {
            throw new Error("Method not implemented.");
        };
        Glue42Notification.prototype.addEventListener = function (type, listener, options) {
            this.callbacks.add(type, listener);
        };
        Glue42Notification.prototype.removeEventListener = function (type, listener, options) {
        };
        Glue42Notification.prototype.dispatchEvent = function (event) {
            this.callbacks.execute(event.type, event);
            return true;
        };
        return Glue42Notification;
    }());

    var STARTING_INDEX = 0;
    var Notifications = (function () {
        function Notifications(interop) {
            this.interop = interop;
            this.methodsRegistered = false;
            this.methodNameRoot = "T42.Notifications.Handler-" + shortid$1();
            this.nextId = 0;
            this.notifications = {};
        }
        Object.defineProperty(Notifications.prototype, "maxActions", {
            get: function () {
                return 2;
            },
            enumerable: true,
            configurable: true
        });
        Notifications.prototype.raise = function (options) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function () {
                var bunchOfPromises, index, id, notification, validActions, index, _loop_1, this_1, _i, validActions_1, action, g42notification;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            if (!options) {
                                throw new Error("invalid options - should be an object");
                            }
                            if (!options.title) {
                                throw new Error("invalid options - should have title");
                            }
                            if (!!this.methodsRegistered) return [3, 2];
                            bunchOfPromises = [];
                            for (index = STARTING_INDEX; index < this.maxActions; index++) {
                                bunchOfPromises.push(this.interop.register(this.methodNameRoot + "_" + index, this.handleNotificationAction.bind(this)));
                            }
                            return [4, Promise.all(bunchOfPromises)];
                        case 1:
                            _c.sent();
                            this.methodsRegistered = true;
                            _c.label = 2;
                        case 2:
                            id = String(this.nextId++);
                            notification = {
                                title: options.title,
                                severity: "Medium",
                                description: options.body,
                                glueRoutingDetailMethodName: this.methodNameRoot + "_" + STARTING_INDEX,
                                actions: [],
                                source: id
                            };
                            if (options.actions) {
                                validActions = options.actions.slice(0, this.maxActions);
                                index = STARTING_INDEX;
                                _loop_1 = function (action) {
                                    var args = {
                                        g42notificationId: id,
                                        g42action: action.action,
                                        g42interopMethod: (_a = action.interop) === null || _a === void 0 ? void 0 : _a.method,
                                        g42interopTarget: (_b = action.interop) === null || _b === void 0 ? void 0 : _b.target,
                                    };
                                    var parameters = Object.keys(args).map(function (key) {
                                        var value = args[key];
                                        return {
                                            name: key,
                                            value: {
                                                stringValue: value
                                            }
                                        };
                                    });
                                    var glueAction = {
                                        name: this_1.methodNameRoot + "_" + index,
                                        description: action.title,
                                        displayName: action.title,
                                        parameters: parameters
                                    };
                                    notification.actions.push(glueAction);
                                    index++;
                                };
                                this_1 = this;
                                for (_i = 0, validActions_1 = validActions; _i < validActions_1.length; _i++) {
                                    action = validActions_1[_i];
                                    _loop_1(action);
                                }
                            }
                            return [4, this.interop.invoke("T42.GNS.Publish.RaiseNotification", { notification: notification })];
                        case 3:
                            _c.sent();
                            g42notification = new Glue42Notification(options);
                            this.notifications[id] = g42notification;
                            return [2, g42notification];
                    }
                });
            });
        };
        Notifications.prototype.handleNotificationAction = function (args) {
            if (args.g42notificationId) {
                var payload_1 = args;
                var id = payload_1.g42notificationId;
                var notification = this.notifications[id];
                if (!notification) {
                    return;
                }
                var event_1 = new Event("onaction");
                event_1.action = payload_1.g42action;
                if (notification.onaction) {
                    notification.onaction(event_1);
                }
                var actionDefinition = (notification.actions || []).find(function (item) { return item.action === payload_1.g42action; });
                var actionInterop = actionDefinition.interop;
                if (actionInterop) {
                    this.interop.invoke(actionInterop.method, actionInterop.arguments || {}, actionInterop.target || "best");
                }
                notification.dispatchEvent(event_1);
            }
            else if (args.notification && args.notification.source) {
                var id = args.notification.source;
                var notification = this.notifications[id];
                if (!notification) {
                    return;
                }
                var event_2 = new Event("onclick");
                if (notification.onclick) {
                    notification.onclick(event_2);
                }
                var clickInterop = notification.options.clickInterop;
                if (clickInterop) {
                    this.interop.invoke(clickInterop.method, clickInterop.arguments || {}, clickInterop.target || "best");
                }
                notification.dispatchEvent(event_2);
            }
        };
        return Notifications;
    }());

    var ThemesConfigurationMethodName = "T42.Themes.Configuration";
    var ThemesImpl = (function () {
        function ThemesImpl(core) {
            this.core = core;
            this.registry = lib$2();
            this.isSubscribed = false;
            this.getConfiguration();
        }
        ThemesImpl.prototype.list = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.getConfiguration()];
                        case 1:
                            _a.sent();
                            if (!this.getMethodName) {
                                throw new Error("not supported");
                            }
                            return [4, this.getAll()];
                        case 2: return [2, (_a.sent()).returned.all];
                    }
                });
            });
        };
        ThemesImpl.prototype.getCurrent = function () {
            return __awaiter(this, void 0, void 0, function () {
                var all;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.getConfiguration()];
                        case 1:
                            _a.sent();
                            if (!this.getMethodName) {
                                throw new Error("not supported");
                            }
                            return [4, this.getAll()];
                        case 2:
                            all = _a.sent();
                            return [2, all.returned.all.find(function (t) { return t.name === all.returned.selected; })];
                    }
                });
            });
        };
        ThemesImpl.prototype.select = function (theme) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.getConfiguration()];
                        case 1:
                            _a.sent();
                            if (!this.setMethodName) {
                                throw new Error("not supported");
                            }
                            return [4, this.core.interop.invoke(this.setMethodName, { theme: theme })];
                        case 2:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        ThemesImpl.prototype.onChanged = function (callback) {
            this.subscribe();
            return this.registry.add("changed", callback);
        };
        ThemesImpl.prototype.getConfiguration = function () {
            return __awaiter(this, void 0, void 0, function () {
                var config, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            if (this.sharedContextName) {
                                return [2];
                            }
                            return [4, this.core.interop.invoke(ThemesConfigurationMethodName)];
                        case 1:
                            config = _a.sent();
                            this.sharedContextName = config.returned.sharedContextName;
                            this.getMethodName = config.returned.getThemesMethodName;
                            this.setMethodName = config.returned.setThemesMethodName;
                            return [3, 3];
                        case 2:
                            error_1 = _a.sent();
                            return [2];
                        case 3: return [2];
                    }
                });
            });
        };
        ThemesImpl.prototype.getAll = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.getConfiguration()];
                        case 1:
                            _a.sent();
                            return [4, this.core.interop.invoke(this.getMethodName)];
                        case 2: return [2, _a.sent()];
                    }
                });
            });
        };
        ThemesImpl.prototype.subscribe = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.getConfiguration()];
                        case 1:
                            _a.sent();
                            if (this.isSubscribed) {
                                return [2];
                            }
                            this.isSubscribed = true;
                            this.core.contexts.subscribe(this.sharedContextName, function (data) {
                                if (data && data.all && data.selected) {
                                    _this.registry.execute("changed", data.all.find(function (t) { return t.name === data.selected; }));
                                }
                            });
                            return [2];
                    }
                });
            });
        };
        return ThemesImpl;
    }());

    function factory$2(core) {
        var themes = new ThemesImpl(core);
        return {
            list: themes.list.bind(themes),
            getCurrent: themes.getCurrent.bind(themes),
            select: themes.select.bind(themes),
            onChanged: themes.onChanged.bind(themes),
            ready: function () { return Promise.resolve(); },
        };
    }

    var GLUE42_FDC3_INTENTS_METHOD_PREFIX = "Tick42.FDC3.Intents.";
    var Intents = (function () {
        function Intents(interop, windows, logger) {
            this.interop = interop;
            this.windows = windows;
            this.logger = logger;
        }
        Intents.prototype.find = function (intentFilter) {
            return __awaiter(this, void 0, void 0, function () {
                var intents, ctToLower_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.all()];
                        case 1:
                            intents = _a.sent();
                            if (typeof intentFilter === "undefined") {
                                return [2, intents];
                            }
                            if (typeof intentFilter === "string") {
                                return [2, intents.filter(function (intent) { return intent.name === intentFilter; })];
                            }
                            if (typeof intentFilter !== "object") {
                                throw new Error("Please provide the intentFilter as a string or an object!");
                            }
                            if (intentFilter.contextType) {
                                ctToLower_1 = intentFilter.contextType.toLowerCase();
                                intents = intents.filter(function (intent) { return intent.handlers.some(function (handler) { var _a; return (_a = handler.contextTypes) === null || _a === void 0 ? void 0 : _a.some(function (ct) { return ct.toLowerCase() === ctToLower_1; }); }); });
                            }
                            if (intentFilter.name) {
                                intents = intents.filter(function (intent) { return intent.name === intentFilter.name; });
                            }
                            return [2, intents];
                    }
                });
            });
        };
        Intents.prototype.raise = function (intent) {
            return __awaiter(this, void 0, void 0, function () {
                var intentName, intentDef, isDynamicIntent, target, handler, anAppHandler, anInstanceHandler, instanceId, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if ((typeof intent !== "string" && typeof intent !== "object") || (typeof intent === "object" && typeof intent.intent !== "string")) {
                                throw new Error("Please provide the intent as a string or an object with an intent property!");
                            }
                            if (typeof intent === "string") {
                                intent = {
                                    intent: intent
                                };
                            }
                            intentName = intent.intent;
                            return [4, this.get(intentName)];
                        case 1:
                            intentDef = _a.sent();
                            if (typeof intentDef === "undefined") {
                                throw new Error("Intent " + intentName + " not found.");
                            }
                            isDynamicIntent = !intentDef.handlers.some(function (intentDefHandler) { return intentDefHandler.type === "app"; });
                            target = intent.target || (isDynamicIntent ? "reuse" : "startNew");
                            anAppHandler = intentDef.handlers.find(function (intentHandler) { return intentHandler.type === "app"; });
                            if (target === "startNew") {
                                handler = anAppHandler;
                            }
                            else if (target === "reuse") {
                                anInstanceHandler = intentDef.handlers.find(function (intentHandler) { return intentHandler.type === "instance"; });
                                handler = anInstanceHandler || anAppHandler;
                            }
                            else if (target.instance) {
                                handler = intentDef.handlers.find(function (intentHandler) { return intentHandler.type === "instance" && intentHandler.instanceId === target.instance; });
                            }
                            else if (target.app) {
                                handler = intentDef.handlers.find(function (intentHandler) { return intentHandler.type === "app" && intentHandler.applicationName === target.app; });
                            }
                            else {
                                throw new Error("Invalid intent target: " + JSON.stringify(target));
                            }
                            if (!handler) {
                                throw new Error("Can not raise intent for request " + JSON.stringify(intent) + " - can not find intent handler.");
                            }
                            instanceId = handler.instanceId;
                            if (!(handler.type === "app")) return [3, 3];
                            return [4, this.startApp(handler.applicationName, intent.options)];
                        case 2:
                            instanceId = _a.sent();
                            _a.label = 3;
                        case 3: return [4, this.raiseIntentToInstance(instanceId, intentName, intent.context)];
                        case 4:
                            result = _a.sent();
                            result.request = intent;
                            result.handler = handler;
                            return [2, result];
                    }
                });
            });
        };
        Intents.prototype.all = function () {
            return __awaiter(this, void 0, void 0, function () {
                var apps, result, e_1, intents, appsWithIntents, _i, appsWithIntents_1, app, _a, _b, intentDef, intent, handler, servers, serverWindowIds, T42WndGetInfo, isT42WndGetInfoMethodRegistered, windowsInfos, result, e_2, _loop_1, _c, servers_1, server;
                var _this = this;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            _d.trys.push([0, 2, , 3]);
                            return [4, this.interop.invoke("T42.ACS.GetApplications", { withIntentsInfo: true })];
                        case 1:
                            result = _d.sent();
                            apps = result.returned.applications;
                            return [3, 3];
                        case 2:
                            e_1 = _d.sent();
                            this.logger.error("Failed to get the applications!", e_1);
                            return [2, []];
                        case 3:
                            intents = {};
                            appsWithIntents = apps.filter(function (app) { return app.intents && app.intents.length > 0; });
                            for (_i = 0, appsWithIntents_1 = appsWithIntents; _i < appsWithIntents_1.length; _i++) {
                                app = appsWithIntents_1[_i];
                                for (_a = 0, _b = app.intents; _a < _b.length; _a++) {
                                    intentDef = _b[_a];
                                    intent = intents[intentDef.name];
                                    if (!intent) {
                                        intent = {
                                            name: intentDef.name,
                                            handlers: [],
                                        };
                                        intents[intentDef.name] = intent;
                                    }
                                    handler = {
                                        applicationName: app.name,
                                        applicationTitle: app.title || "",
                                        applicationDescription: app.caption,
                                        displayName: intentDef.displayName,
                                        contextTypes: intentDef.contexts,
                                        applicationIcon: app.icon,
                                        type: "app"
                                    };
                                    intent.handlers.push(handler);
                                }
                            }
                            servers = this.interop.servers();
                            serverWindowIds = servers.map(function (server) { return server.windowId; }).filter(function (serverWindowId) { return typeof serverWindowId !== "undefined"; });
                            T42WndGetInfo = "T42.Wnd.GetInfo";
                            isT42WndGetInfoMethodRegistered = this.interop.methods().some(function (method) { return method.name === T42WndGetInfo; });
                            if (!isT42WndGetInfoMethodRegistered) return [3, 7];
                            _d.label = 4;
                        case 4:
                            _d.trys.push([4, 6, , 7]);
                            return [4, this.interop.invoke(T42WndGetInfo, { ids: serverWindowIds })];
                        case 5:
                            result = _d.sent();
                            windowsInfos = result.returned.windows;
                            return [3, 7];
                        case 6:
                            e_2 = _d.sent();
                            return [3, 7];
                        case 7:
                            _loop_1 = function (server) {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4, Promise.all(server.getMethods()
                                                .filter(function (method) { return method.name.startsWith(GLUE42_FDC3_INTENTS_METHOD_PREFIX); })
                                                .map(function (method) { return __awaiter(_this, void 0, void 0, function () {
                                                var intentName, intent, info, app, appIntent, title, handler;
                                                var _a, _b, _c, _d, _e;
                                                return __generator(this, function (_f) {
                                                    switch (_f.label) {
                                                        case 0:
                                                            intentName = method.name.replace(GLUE42_FDC3_INTENTS_METHOD_PREFIX, "");
                                                            intent = intents[intentName];
                                                            if (!intent) {
                                                                intent = {
                                                                    name: intentName,
                                                                    handlers: [],
                                                                };
                                                                intents[intentName] = intent;
                                                            }
                                                            info = method.flags.intent;
                                                            app = apps.find(function (appWithIntents) { return appWithIntents.name === server.application; });
                                                            if (app && app.intents) {
                                                                appIntent = app.intents.find(function (appDefIntent) { return appDefIntent.name === intentName; });
                                                            }
                                                            return [4, this.windowsIdToTitle(server.windowId, windowsInfos)];
                                                        case 1:
                                                            title = _f.sent();
                                                            handler = {
                                                                instanceId: server.instance,
                                                                applicationName: server.application,
                                                                applicationIcon: info.icon || ((_a = app) === null || _a === void 0 ? void 0 : _a.icon),
                                                                applicationTitle: ((_b = app) === null || _b === void 0 ? void 0 : _b.title) || "",
                                                                applicationDescription: info.description || ((_c = app) === null || _c === void 0 ? void 0 : _c.caption),
                                                                displayName: info.displayName || ((_d = appIntent) === null || _d === void 0 ? void 0 : _d.displayName),
                                                                contextTypes: info.contextTypes || ((_e = appIntent) === null || _e === void 0 ? void 0 : _e.contexts),
                                                                instanceTitle: title,
                                                                type: "instance"
                                                            };
                                                            intent.handlers.push(handler);
                                                            return [2];
                                                    }
                                                });
                                            }); }))];
                                        case 1:
                                            _a.sent();
                                            return [2];
                                    }
                                });
                            };
                            _c = 0, servers_1 = servers;
                            _d.label = 8;
                        case 8:
                            if (!(_c < servers_1.length)) return [3, 11];
                            server = servers_1[_c];
                            return [5, _loop_1(server)];
                        case 9:
                            _d.sent();
                            _d.label = 10;
                        case 10:
                            _c++;
                            return [3, 8];
                        case 11: return [2, Object.values(intents)];
                    }
                });
            });
        };
        Intents.prototype.addIntentListener = function (intent, handler) {
            var _this = this;
            if ((typeof intent !== "string" && typeof intent !== "object") || (typeof intent === "object" && typeof intent.intent !== "string")) {
                throw new Error("Please provide the intent as a string or an object with an intent property!");
            }
            if (typeof handler !== "function") {
                throw new Error("Please provide the handler as a function!");
            }
            var result = { unsubscribe: function () { return console.log("Could not unsubscribe!"); } };
            var intentName = typeof intent === "string" ? intent : intent.intent;
            var methodName = "" + GLUE42_FDC3_INTENTS_METHOD_PREFIX + intentName;
            var intentFlag = {};
            if (typeof intent === "object") {
                var removed = intent.intent, rest = __rest(intent, ["intent"]);
                intentFlag = rest;
            }
            this.interop.register({ name: methodName, flags: { intent: intentFlag } }, function (args) {
                return handler(args);
            }).then(function () {
                result.unsubscribe = function () {
                    _this.interop.unregister(methodName);
                };
            });
            return result;
        };
        Intents.prototype.get = function (intent) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.all()];
                        case 1: return [2, (_a.sent()).find(function (registeredIntent) { return registeredIntent.name === intent; })];
                    }
                });
            });
        };
        Intents.prototype.startApp = function (application, options) {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this.interop.invoke("T42.ACS.StartApplication", { Name: application, options: options })];
                        case 1:
                            result = _a.sent();
                            return [2, result.returned.Id];
                    }
                });
            });
        };
        Intents.prototype.raiseIntentToInstance = function (instanceId, intent, context) {
            return __awaiter(this, void 0, void 0, function () {
                var methodName, interopServer, method, result;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            methodName = "" + GLUE42_FDC3_INTENTS_METHOD_PREFIX + intent;
                            interopServer = this.interop.servers().find(function (server) { return server.instance === instanceId; });
                            if (!!interopServer) return [3, 2];
                            return [4, (new Promise(function (resolve, reject) {
                                    var timeoutId;
                                    var unsub = _this.interop.serverAdded(function (server) {
                                        if (server.instance === instanceId) {
                                            interopServer = server;
                                            resolve();
                                            clearTimeout(timeoutId);
                                            unsub();
                                        }
                                    });
                                    timeoutId = setTimeout(function () {
                                        unsub();
                                        reject(new Error("Can not find interop server for instance " + instanceId));
                                    }, 30 * 1000);
                                }))];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            method = interopServer.getMethods().find(function (registeredMethod) { return registeredMethod.name === methodName; });
                            if (!!method) return [3, 4];
                            return [4, (new Promise(function (resolve, reject) {
                                    var timeoutId;
                                    var unsub = _this.interop.methodAdded(function (addedMethod) {
                                        if (addedMethod.name === methodName) {
                                            resolve();
                                            clearTimeout(timeoutId);
                                            unsub();
                                        }
                                    });
                                    timeoutId = setTimeout(function () {
                                        unsub();
                                        reject(new Error("Can not find interop method " + methodName + " for instance " + instanceId));
                                    }, 10 * 1000);
                                }))];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4: return [4, this.interop.invoke(methodName, context, { instance: instanceId })];
                        case 5:
                            result = _a.sent();
                            return [2, {
                                    result: result.returned
                                }];
                    }
                });
            });
        };
        Intents.prototype.windowsIdToTitle = function (id, windowsInfos) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var window, title;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (typeof windowsInfos !== "undefined") {
                                return [2, (_a = windowsInfos.find(function (windowsInfo) { return windowsInfo.id === id; })) === null || _a === void 0 ? void 0 : _a.title];
                            }
                            window = (_b = this.windows) === null || _b === void 0 ? void 0 : _b.findById(id);
                            return [4, ((_c = window) === null || _c === void 0 ? void 0 : _c.getTitle())];
                        case 1:
                            title = _d.sent();
                            return [2, title];
                    }
                });
            });
        };
        return Intents;
    }());

    var InitInfo = (function () {
        function InitInfo() {
            var _this = this;
            this.numberOfCalls = 0;
            this.numberOfCalls = 1;
            this.promise = new Promise(function (resolve, reject) {
                _this.resolve = resolve;
                _this.reject = reject;
            });
        }
        InitInfo.prototype.getPromise = function () {
            this.numberOfCalls++;
            return this.promise;
        };
        InitInfo.prototype.done = function (g) {
            this.resolve(g);
        };
        InitInfo.prototype.error = function (e) {
            this.reject(e);
        };
        return InitInfo;
    }());

    var initInfo;
    var factory$3 = function (options) { return __awaiter(void 0, void 0, void 0, function () {
        var glue42gd, g;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    glue42gd = typeof window !== "undefined" && window.glue42gd;
                    if (glue42gd) {
                        if (initInfo) {
                            return [2, initInfo.getPromise()];
                        }
                        else {
                            initInfo = new InitInfo();
                        }
                    }
                    return [4, factoryCore(options, glue42gd)];
                case 1:
                    g = _b.sent();
                    (_a = initInfo) === null || _a === void 0 ? void 0 : _a.resolve(g);
                    return [2, g];
            }
        });
    }); };
    var factoryCore = function (options, glue42gd) { return __awaiter(void 0, void 0, void 0, function () {
        function createWindows(core) {
            if (glueConfig.windows) {
                var windowsLogger = getLibLogger("windows", core.logger, glueConfig.windows);
                _windows = WindowsFactory(core.agm, windowsLogger, function () {
                    return _appManager;
                }, function () {
                    return _displays;
                }, gdMajorVersion);
                debugLog(_windows);
                return _windows;
            }
        }
        function createActivities(core) {
            var _a, _b;
            if (glueConfig.activities) {
                if (ActivityModule.checkIsUsingGW3Implementation && ActivityModule.checkIsUsingGW3Implementation(core.connection)) {
                    var activityLogger = getLibLogger("activity", core.logger, glueConfig.activities);
                    _activity = new ActivityModule({
                        connection: core.connection,
                        contexts: core.contexts,
                        agm: core.agm,
                        logger: activityLogger,
                        logLevel: "info",
                        disableAutoAnnounce: false,
                        disposeRequestHandling: "exit",
                        announcementInfo: null,
                        windows: _windows,
                        appManagerGetter: function () {
                            return _appManager;
                        },
                        mode: glueConfig.activities.mode,
                        typesToTrack: glueConfig.activities.typesToTrack,
                        activityId: (_b = (_a = glue42gd) === null || _a === void 0 ? void 0 : _a.activityInfo) === null || _b === void 0 ? void 0 : _b.activityId,
                        gdMajorVersion: gdMajorVersion
                    }).api;
                    debugLog(_activity);
                    return _activity;
                }
            }
        }
        function createAppManager(core) {
            if (!glueConfig.appManager) {
                return;
            }
            var logger = getLibLogger("appManager", core.logger, glueConfig.appManager);
            _appManager = AppManagerFactory({
                agm: core.agm,
                windows: _windows,
                logger: logger,
                activities: _activity,
                mode: glueConfig.appManager.mode,
                gdMajorVersion: gdMajorVersion
            });
            debugLog(_appManager);
            return _appManager;
        }
        function createLayouts(core) {
            var _a;
            if (!glueConfig.layouts) {
                return;
            }
            var logger = getLibLogger("layouts", core.logger, glueConfig.layouts);
            var layoutsConfig = glueConfig.layouts;
            var lay = LayoutsFactory({
                agm: core.agm,
                appManager: _appManager,
                activityGetter: function () { return _activity; },
                logger: logger,
                mode: layoutsConfig.mode,
                autoSaveWindowContext: (_a = layoutsConfig.autoSaveWindowContext, (_a !== null && _a !== void 0 ? _a : false)),
                gdMajorVersion: gdMajorVersion
            });
            debugLog(lay);
            return lay;
        }
        function createChannels(core) {
            if (!glueConfig.channels) {
                return;
            }
            if (!core.contexts) {
                return;
            }
            var channelsAPI = factory(core.contexts, core.agm);
            debugLog(channelsAPI);
            return channelsAPI;
        }
        function createHotkeys(core) {
            var hotkeysAPI = factory$1(core.agm);
            debugLog(hotkeysAPI);
            return hotkeysAPI;
        }
        function createIntents(core) {
            var intentsAPI = new Intents(core.agm, _windows, core.logger.subLogger("intents"));
            debugLog(intentsAPI);
            return intentsAPI;
        }
        function createNotifications(core) {
            var notificationsAPI = new Notifications(core.interop);
            debugLog(notificationsAPI);
            return notificationsAPI;
        }
        function createDisplaysApi(core) {
            if (glueConfig.displays) {
                var displaysLogger = getLibLogger("displays", core.logger, glueConfig.displays);
                _displays = new DisplayManager(core.agm, displaysLogger);
                debugLog(_displays);
                return _displays;
            }
        }
        function createThemes(core) {
            if (!core.contexts) {
                return;
            }
            var themesAPI = factory$2(core);
            debugLog(themesAPI);
            return themesAPI;
        }
        function getLibLogger(loggerName, logger, config) {
            var newLogger = logger.subLogger(loggerName);
            if (config && config.logger) {
                var loggerConfig = config.logger;
                if (loggerConfig.console) {
                    newLogger.consoleLevel(loggerConfig.console);
                }
                if (loggerConfig.publish) {
                    newLogger.publishLevel(loggerConfig.publish);
                }
            }
            return newLogger;
        }
        function debugLog(entry) {
            currentLog.push(entry);
        }
        var gdMajorVersion, glueConfig, _appManager, _activity, _windows, _displays, ext, currentLog, glueApi;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    gdMajorVersion = Utils$1.getGDMajorVersion();
                    options = options || {};
                    glueConfig = prepareConfig$1(options);
                    options.gateway = options.gateway || {};
                    ext = {
                        libs: [
                            { name: "windows", create: createWindows },
                            { name: "activities", create: createActivities },
                            { name: "appManager", create: createAppManager },
                            { name: "layouts", create: createLayouts },
                            { name: "channels", create: createChannels },
                            { name: "hotkeys", create: createHotkeys },
                            { name: "displays", create: createDisplaysApi },
                            { name: "intents", create: createIntents },
                            { name: "notifications", create: createNotifications },
                            { name: "themes", create: createThemes }
                        ],
                        version: version$2,
                        enrichGlue: function (glue) {
                            glue.config.activities = glueConfig.activities;
                            glue.config.windows = glueConfig.windows;
                            glue.config.appManager = glueConfig.appManager;
                            glue.config.layouts = glueConfig.layouts;
                            glue.config.channels = glueConfig.channels;
                            glue.config.displays = glueConfig.displays;
                        },
                    };
                    currentLog = [];
                    if (typeof window !== "undefined") {
                        if (!window.glueFactoryLog) {
                            window.glueFactoryLog = [];
                        }
                        window.glueFactoryLog.push(currentLog);
                    }
                    return [4, GlueCore(options, ext)];
                case 1:
                    glueApi = (_b.sent());
                    if (!(Array.isArray((_a = options) === null || _a === void 0 ? void 0 : _a.libraries) && options.libraries.length)) return [3, 3];
                    return [4, Promise.all(options.libraries.map(function (lib) { return lib(glueApi, options); }))];
                case 2:
                    _b.sent();
                    _b.label = 3;
                case 3: return [2, glueApi];
            }
        });
    }); };
    factory$3.coreVersion = GlueCore.version;
    factory$3.version = version$2;
    factory$3.initInfo = initInfo;

    var whatToExpose = factory$3;
    var shouldSetToWindow = true;
    if (typeof window !== "undefined") {
        var glue42gd = window.glue42gd;
        if (glue42gd && glue42gd.autoInjected) {
            whatToExpose = window.Glue;
            shouldSetToWindow = false;
        }
        if (shouldSetToWindow) {
            window.Glue = whatToExpose;
        }
        delete window.GlueCore;
    }
    whatToExpose.default = whatToExpose;
    var whatToExpose$1 = whatToExpose;

    return whatToExpose$1;

})));
//# sourceMappingURL=desktop.browser.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@glue42/gss/dist/web/@glue42/gss.min.js":
/*!**************************************************************!*\
  !*** ./node_modules/@glue42/gss/dist/web/@glue42/gss.min.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t():undefined}("undefined"!=typeof self?self:this,function(){return function(e){function __webpack_require__(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}var t={};return __webpack_require__.m=e,__webpack_require__.c=t,__webpack_require__.d=function(e,t,r){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},__webpack_require__.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return __webpack_require__.d(t,"a",t),t},__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=32)}([function(e,t,r){"use strict";function nodeify(e,r){return"function"!=typeof r?e:e.then(function(e){return(0,t.nextTick)(function(){return r(null,e)})})["catch"](function(e){return(0,t.nextTick)(function(){return r(e,null)})})}function evalValue(e){for(var t=e;a.isFunction(t);)t=t();return t}function spread(e){var t,r,i=[];try{for(var o=n(e),a=o.next();!a.done;a=o.next()){var s=a.value;i.push(s)}}catch(e){t={error:e}}finally{try{a&&!a.done&&(r=o["return"])&&r.call(o)}finally{if(t)throw t.error}}return i}function mapToObject(e){var t={};return spread(e.entries()).reduce(function(e,t){return e[t[0]]=t[1],e},t)}function safeCall(e,r,n){(0,t.nextTick)(function(){try{e()}catch(e){if(n)try{n(e)}catch(e){console.error("Catch callback in safeCall thrown an error",e)}else r?r.error("Callback thrown error - ".concat(e,", stack trace: ").concat(e.stack)):console.error("Callback thrown error",e)}})}function tryGetError(e,t){var r,n=function(e){return"".concat(e.message||"Unspecified error from GSS DM"," (code: ").concat(e.code||"N/A",")")};if(e.error?r=n(e.error):e.errors&&(r="Multiple errors: "+e.errors.map(n).join("; ")),r!==undefined)return t?t.error(r):console.error(r),r}function str(e,t){return e===undefined?"undefined":null===e?"null":Boolean(t)?JSON.stringify(e,undefined,2):JSON.stringify(e)}function genGuid(){return s()}function throwOnDataError(e,t){var r=tryGetError(e,t);if(!a.isUndefined(r)&&a.isUndefined(e.result))throw new Error(r)}function providerConvertEntityTypes(e){return{result:spread(e.values()).map(function(e){var t=e.entityType;return{name:t.name,properties:convertProperties(t.properties)}})}}function convertProperties(e){return e.values().map(function(e){var t={name:e.name,type:e.type.name};return["displayName","description","isArray"].forEach(function(r){var n=a.get(e,r,undefined);n!==undefined&&a.set(t,r,n)}),e.searchType&&(t.searchType=e.searchType.name),e.metaData&&(t.metaData=Object.getOwnPropertyNames(e.metaData).reduce(function(e,r){var n=t.metaData[r];return n!==undefined&&null!==n&&e.push({name:r,value:String(n)}),e},[])),e.type===u["default"].Composite&&(t.properties=convertProperties(e.properties)),t})}function parseQueryFromRequest(e){if(e.entityType===undefined)throw new TypeError("Expected entityType field in query");if(e.filter===undefined)throw new TypeError("Expected filter field in query");return new l["default"](e.entityType,e.filter.map(function(e){return new p["default"](e.name,e.value,e.searchType)}),e.properties,e.limit,e.providers)}function validateQuery(e,t){e.filter.forEach(function(e){var r=e.name;if(r!==p["default"].fullTextSearchFieldName&&!t.properties.deepGet(r))throw new Error("Field ".concat(r," not found in ").concat(t.name))})}function generalConvertEntityTypes(e,t){if(!e)return t&&t.debug&&t.debug("Received empty data on subscription to entity types"),undefined;throwOnDataError(e);var r=e.result;if(r===undefined)return new d["default"]([]);if(!a.isArray(r))throw new Error("EntityTypes is not an array");var n=r.map(function(e){return new f["default"](e.name,new(y["default"].bind.apply(y["default"],o([void 0],i(_generalConvertProperties(e.properties)),!1))))});return new d["default"](n)}function _generalConvertProperties(e){return e.map(function(e){var t=Boolean(e.isArray),r=c["default"].None;e.searchType&&(r=c["default"].valueOf(e.searchType));var n=e.properties&&e.properties.length>0?_generalConvertProperties(e.properties):undefined;return new h["default"](e.name,u["default"].valueOf(e.type),t,r,e.displayName,e.description,e.metaData?a.cloneDeep(e.metaData):undefined,n)})}var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o["return"])&&r.call(o)}finally{if(i)throw i.error}}return a},o=this&&this.__spreadArray||function(e,t,r){if(r||2===arguments.length)for(var n,i=0,o=t.length;i<o;i++)!n&&i in t||(n||(n=Array.prototype.slice.call(t,0,i)),n[i]=t[i]);return e.concat(n||Array.prototype.slice.call(t))};Object.defineProperty(t,"__esModule",{value:!0}),t.generalConvertEntityTypes=t.validateQuery=t.parseQueryFromRequest=t.convertProperties=t.providerConvertEntityTypes=t.throwOnDataError=t.genGuid=t.str=t.tryGetError=t.safeCall=t.mapToObject=t.spread=t.evalValue=t.nodeify=t.slice=t.nextTick=void 0;var a=r(1),s=r(34),u=r(3),c=r(4),l=r(18),p=r(8),f=r(5),d=r(19),h=r(10),y=r(6);t.nextTick=function(){return function(e){return setTimeout(e,0)}}(),t.slice=Function.apply.bind(Array.prototype.slice),t.nodeify=nodeify,t.evalValue=evalValue,t.spread=spread,t.mapToObject=mapToObject,t.safeCall=safeCall,t.tryGetError=tryGetError,t.str=str,t.genGuid=genGuid,t.throwOnDataError=throwOnDataError,t.providerConvertEntityTypes=providerConvertEntityTypes,t.convertProperties=convertProperties,t.parseQueryFromRequest=parseQueryFromRequest,t.validateQuery=validateQuery,t.generalConvertEntityTypes=generalConvertEntityTypes},function(e,t,r){(function(e,n){var i;(function(){function apply(e,t,r){switch(r.length){case 0:return e.call(t);case 1:return e.call(t,r[0]);case 2:return e.call(t,r[0],r[1]);case 3:return e.call(t,r[0],r[1],r[2])}return e.apply(t,r)}function arrayAggregator(e,t,r,n){for(var i=-1,o=null==e?0:e.length;++i<o;){var a=e[i];t(n,a,r(a),e)}return n}function arrayEach(e,t){for(var r=-1,n=null==e?0:e.length;++r<n&&!1!==t(e[r],r,e););return e}function arrayEachRight(e,t){for(var r=null==e?0:e.length;r--&&!1!==t(e[r],r,e););return e}function arrayEvery(e,t){for(var r=-1,n=null==e?0:e.length;++r<n;)if(!t(e[r],r,e))return!1;return!0}function arrayFilter(e,t){for(var r=-1,n=null==e?0:e.length,i=0,o=[];++r<n;){var a=e[r];t(a,r,e)&&(o[i++]=a)}return o}function arrayIncludes(e,t){return!!(null==e?0:e.length)&&baseIndexOf(e,t,0)>-1}function arrayIncludesWith(e,t,r){for(var n=-1,i=null==e?0:e.length;++n<i;)if(r(t,e[n]))return!0;return!1}function arrayMap(e,t){for(var r=-1,n=null==e?0:e.length,i=Array(n);++r<n;)i[r]=t(e[r],r,e);return i}function arrayPush(e,t){for(var r=-1,n=t.length,i=e.length;++r<n;)e[i+r]=t[r];return e}function arrayReduce(e,t,r,n){var i=-1,o=null==e?0:e.length;for(n&&o&&(r=e[++i]);++i<o;)r=t(r,e[i],i,e);return r}function arrayReduceRight(e,t,r,n){var i=null==e?0:e.length;for(n&&i&&(r=e[--i]);i--;)r=t(r,e[i],i,e);return r}function arraySome(e,t){for(var r=-1,n=null==e?0:e.length;++r<n;)if(t(e[r],r,e))return!0;return!1}function asciiToArray(e){return e.split("")}function asciiWords(e){return e.match(Be)||[]}function baseFindKey(e,t,r){var n;return r(e,function(e,r,i){if(t(e,r,i))return n=r,!1}),n}function baseFindIndex(e,t,r,n){for(var i=e.length,o=r+(n?1:-1);n?o--:++o<i;)if(t(e[o],o,e))return o;return-1}function baseIndexOf(e,t,r){return t===t?strictIndexOf(e,t,r):baseFindIndex(e,baseIsNaN,r)}function baseIndexOfWith(e,t,r,n){for(var i=r-1,o=e.length;++i<o;)if(n(e[i],t))return i;return-1}function baseIsNaN(e){return e!==e}function baseMean(e,t){var r=null==e?0:e.length;return r?baseSum(e,t)/r:F}function baseProperty(e){return function(t){return null==t?o:t[e]}}function basePropertyOf(e){return function(t){return null==e?o:e[t]}}function baseReduce(e,t,r,n,i){return i(e,function(e,i,o){r=n?(n=!1,e):t(r,e,i,o)}),r}function baseSortBy(e,t){var r=e.length;for(e.sort(t);r--;)e[r]=e[r].value;return e}function baseSum(e,t){for(var r,n=-1,i=e.length;++n<i;){var a=t(e[n]);a!==o&&(r=r===o?a:r+a)}return r}function baseTimes(e,t){for(var r=-1,n=Array(e);++r<e;)n[r]=t(r);return n}function baseToPairs(e,t){return arrayMap(t,function(t){return[t,e[t]]})}function baseUnary(e){return function(t){return e(t)}}function baseValues(e,t){return arrayMap(t,function(t){return e[t]})}function cacheHas(e,t){return e.has(t)}function charsStartIndex(e,t){for(var r=-1,n=e.length;++r<n&&baseIndexOf(t,e[r],0)>-1;);return r}function charsEndIndex(e,t){for(var r=e.length;r--&&baseIndexOf(t,e[r],0)>-1;);return r}function countHolders(e,t){for(var r=e.length,n=0;r--;)e[r]===t&&++n;return n}function escapeStringChar(e){return"\\"+At[e]}function getValue(e,t){return null==e?o:e[t]}function hasUnicode(e){return _t.test(e)}function hasUnicodeWord(e){return vt.test(e)}function iteratorToArray(e){for(var t,r=[];!(t=e.next()).done;)r.push(t.value);return r}function mapToArray(e){var t=-1,r=Array(e.size);return e.forEach(function(e,n){r[++t]=[n,e]}),r}function overArg(e,t){return function(r){return e(t(r))}}function replaceHolders(e,t){for(var r=-1,n=e.length,i=0,o=[];++r<n;){var a=e[r];a!==t&&a!==p||(e[r]=p,o[i++]=r)}return o}function setToArray(e){var t=-1,r=Array(e.size);return e.forEach(function(e){r[++t]=e}),r}function setToPairs(e){var t=-1,r=Array(e.size);return e.forEach(function(e){r[++t]=[e,e]}),r}function strictIndexOf(e,t,r){for(var n=r-1,i=e.length;++n<i;)if(e[n]===t)return n;return-1}function strictLastIndexOf(e,t,r){for(var n=r+1;n--;)if(e[n]===t)return n;return n}function stringSize(e){return hasUnicode(e)?unicodeSize(e):Ut(e)}function stringToArray(e){return hasUnicode(e)?unicodeToArray(e):asciiToArray(e)}function unicodeSize(e){for(var t=gt.lastIndex=0;gt.test(e);)++t;return t}function unicodeToArray(e){return e.match(gt)||[]}function unicodeWords(e){return e.match(bt)||[]}var o,a=200,s="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",u="Expected a function",c="__lodash_hash_undefined__",l=500,p="__lodash_placeholder__",f=1,d=2,h=4,y=1,g=2,b=1,_=2,v=4,m=8,S=16,T=32,w=64,E=128,P=256,O=512,A=30,I="...",k=800,j=16,x=1,C=2,G=1/0,R=9007199254740991,L=1.7976931348623157e308,F=NaN,N=4294967295,D=N-1,M=N>>>1,B=[["ary",E],["bind",b],["bindKey",_],["curry",m],["curryRight",S],["flip",O],["partial",T],["partialRight",w],["rearg",P]],W="[object Arguments]",q="[object Array]",z="[object AsyncFunction]",U="[object Boolean]",Q="[object Date]",V="[object DOMException]",H="[object Error]",K="[object Function]",J="[object GeneratorFunction]",$="[object Map]",Z="[object Number]",Y="[object Null]",X="[object Object]",ee="[object Proxy]",te="[object RegExp]",re="[object Set]",ne="[object String]",ie="[object Symbol]",oe="[object Undefined]",ae="[object WeakMap]",se="[object WeakSet]",ue="[object ArrayBuffer]",ce="[object DataView]",le="[object Float32Array]",pe="[object Float64Array]",fe="[object Int8Array]",de="[object Int16Array]",he="[object Int32Array]",ye="[object Uint8Array]",ge="[object Uint8ClampedArray]",be="[object Uint16Array]",_e="[object Uint32Array]",ve=/\b__p \+= '';/g,me=/\b(__p \+=) '' \+/g,Se=/(__e\(.*?\)|\b__t\)) \+\n'';/g,Te=/&(?:amp|lt|gt|quot|#39);/g,we=/[&<>"']/g,Ee=RegExp(Te.source),Pe=RegExp(we.source),Oe=/<%-([\s\S]+?)%>/g,Ae=/<%([\s\S]+?)%>/g,Ie=/<%=([\s\S]+?)%>/g,ke=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,je=/^\w*$/,xe=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Ce=/[\\^$.*+?()[\]{}|]/g,Ge=RegExp(Ce.source),Re=/^\s+|\s+$/g,Le=/^\s+/,Fe=/\s+$/,Ne=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,De=/\{\n\/\* \[wrapped with (.+)\] \*/,Me=/,? & /,Be=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,We=/\\(\\)?/g,qe=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,ze=/\w*$/,Ue=/^[-+]0x[0-9a-f]+$/i,Qe=/^0b[01]+$/i,Ve=/^\[object .+?Constructor\]$/,He=/^0o[0-7]+$/i,Ke=/^(?:0|[1-9]\d*)$/,Je=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,$e=/($^)/,Ze=/['\n\r\u2028\u2029\\]/g,Ye="\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",Xe="\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",et="["+Xe+"]",tt="["+Ye+"]",rt="[a-z\\xdf-\\xf6\\xf8-\\xff]",nt="[^\\ud800-\\udfff"+Xe+"\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]",it="\\ud83c[\\udffb-\\udfff]",ot="(?:\\ud83c[\\udde6-\\uddff]){2}",at="[\\ud800-\\udbff][\\udc00-\\udfff]",st="[A-Z\\xc0-\\xd6\\xd8-\\xde]",ut="(?:"+rt+"|"+nt+")",ct="(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?",lt="(?:\\u200d(?:"+["[^\\ud800-\\udfff]",ot,at].join("|")+")[\\ufe0e\\ufe0f]?"+ct+")*",pt="[\\ufe0e\\ufe0f]?"+ct+lt,ft="(?:"+["[\\u2700-\\u27bf]",ot,at].join("|")+")"+pt,dt="(?:"+["[^\\ud800-\\udfff]"+tt+"?",tt,ot,at,"[\\ud800-\\udfff]"].join("|")+")",ht=RegExp("['’]","g"),yt=RegExp(tt,"g"),gt=RegExp(it+"(?="+it+")|"+dt+pt,"g"),bt=RegExp([st+"?"+rt+"+(?:['’](?:d|ll|m|re|s|t|ve))?(?="+[et,st,"$"].join("|")+")","(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?="+[et,st+ut,"$"].join("|")+")",st+"?"+ut+"+(?:['’](?:d|ll|m|re|s|t|ve))?",st+"+(?:['’](?:D|LL|M|RE|S|T|VE))?","\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])","\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])","\\d+",ft].join("|"),"g"),_t=RegExp("[\\u200d\\ud800-\\udfff"+Ye+"\\ufe0e\\ufe0f]"),vt=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,mt=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],St=-1,Tt={};Tt[le]=Tt[pe]=Tt[fe]=Tt[de]=Tt[he]=Tt[ye]=Tt[ge]=Tt[be]=Tt[_e]=!0,Tt[W]=Tt[q]=Tt[ue]=Tt[U]=Tt[ce]=Tt[Q]=Tt[H]=Tt[K]=Tt[$]=Tt[Z]=Tt[X]=Tt[te]=Tt[re]=Tt[ne]=Tt[ae]=!1;var wt={};wt[W]=wt[q]=wt[ue]=wt[ce]=wt[U]=wt[Q]=wt[le]=wt[pe]=wt[fe]=wt[de]=wt[he]=wt[$]=wt[Z]=wt[X]=wt[te]=wt[re]=wt[ne]=wt[ie]=wt[ye]=wt[ge]=wt[be]=wt[_e]=!0,wt[H]=wt[K]=wt[ae]=!1;var Et={"À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","Ç":"C","ç":"c","Ð":"D","ð":"d","È":"E","É":"E","Ê":"E","Ë":"E","è":"e","é":"e","ê":"e","ë":"e","Ì":"I","Í":"I","Î":"I","Ï":"I","ì":"i","í":"i","î":"i","ï":"i","Ñ":"N","ñ":"n","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","Ù":"U","Ú":"U","Û":"U","Ü":"U","ù":"u","ú":"u","û":"u","ü":"u","Ý":"Y","ý":"y","ÿ":"y","Æ":"Ae","æ":"ae","Þ":"Th","þ":"th","ß":"ss","Ā":"A","Ă":"A","Ą":"A","ā":"a","ă":"a","ą":"a","Ć":"C","Ĉ":"C","Ċ":"C","Č":"C","ć":"c","ĉ":"c","ċ":"c","č":"c","Ď":"D","Đ":"D","ď":"d","đ":"d","Ē":"E","Ĕ":"E","Ė":"E","Ę":"E","Ě":"E","ē":"e","ĕ":"e","ė":"e","ę":"e","ě":"e","Ĝ":"G","Ğ":"G","Ġ":"G","Ģ":"G","ĝ":"g","ğ":"g","ġ":"g","ģ":"g","Ĥ":"H","Ħ":"H","ĥ":"h","ħ":"h","Ĩ":"I","Ī":"I","Ĭ":"I","Į":"I","İ":"I","ĩ":"i","ī":"i","ĭ":"i","į":"i","ı":"i","Ĵ":"J","ĵ":"j","Ķ":"K","ķ":"k","ĸ":"k","Ĺ":"L","Ļ":"L","Ľ":"L","Ŀ":"L","Ł":"L","ĺ":"l","ļ":"l","ľ":"l","ŀ":"l","ł":"l","Ń":"N","Ņ":"N","Ň":"N","Ŋ":"N","ń":"n","ņ":"n","ň":"n","ŋ":"n","Ō":"O","Ŏ":"O","Ő":"O","ō":"o","ŏ":"o","ő":"o","Ŕ":"R","Ŗ":"R","Ř":"R","ŕ":"r","ŗ":"r","ř":"r","Ś":"S","Ŝ":"S","Ş":"S","Š":"S","ś":"s","ŝ":"s","ş":"s","š":"s","Ţ":"T","Ť":"T","Ŧ":"T","ţ":"t","ť":"t","ŧ":"t","Ũ":"U","Ū":"U","Ŭ":"U","Ů":"U","Ű":"U","Ų":"U","ũ":"u","ū":"u","ŭ":"u","ů":"u","ű":"u","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","Ż":"Z","Ž":"Z","ź":"z","ż":"z","ž":"z","Ĳ":"IJ","ĳ":"ij","Œ":"Oe","œ":"oe","ŉ":"'n","ſ":"s"},Pt={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Ot={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},At={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},It=parseFloat,kt=parseInt,jt="object"==typeof e&&e&&e.Object===Object&&e,xt="object"==typeof self&&self&&self.Object===Object&&self,Ct=jt||xt||Function("return this")(),Gt="object"==typeof t&&t&&!t.nodeType&&t,Rt=Gt&&"object"==typeof n&&n&&!n.nodeType&&n,Lt=Rt&&Rt.exports===Gt,Ft=Lt&&jt.process,Nt=function(){try{var e=Rt&&Rt.require&&Rt.require("util").types;return e||Ft&&Ft.binding&&Ft.binding("util")}catch(e){}}(),Dt=Nt&&Nt.isArrayBuffer,Mt=Nt&&Nt.isDate,Bt=Nt&&Nt.isMap,Wt=Nt&&Nt.isRegExp,qt=Nt&&Nt.isSet,zt=Nt&&Nt.isTypedArray,Ut=baseProperty("length"),Qt=basePropertyOf(Et),Vt=basePropertyOf(Pt),Ht=basePropertyOf(Ot),Kt=function runInContext(e){function lodash(e){if(isObjectLike(e)&&!In(e)&&!(e instanceof LazyWrapper)){if(e instanceof LodashWrapper)return e;if(st.call(e,"__wrapped__"))return wrapperClone(e)}return new LodashWrapper(e)}function baseLodash(){}function LodashWrapper(e,t){this.__wrapped__=e,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=o}function LazyWrapper(e){this.__wrapped__=e,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=N,this.__views__=[]}function lazyClone(){var e=new LazyWrapper(this.__wrapped__);return e.__actions__=copyArray(this.__actions__),e.__dir__=this.__dir__,e.__filtered__=this.__filtered__,e.__iteratees__=copyArray(this.__iteratees__),e.__takeCount__=this.__takeCount__,e.__views__=copyArray(this.__views__),e}function lazyReverse(){if(this.__filtered__){var e=new LazyWrapper(this);e.__dir__=-1,e.__filtered__=!0}else e=this.clone(),e.__dir__*=-1;return e}function lazyValue(){var e=this.__wrapped__.value(),t=this.__dir__,r=In(e),n=t<0,i=r?e.length:0,o=getView(0,i,this.__views__),a=o.start,s=o.end,u=s-a,c=n?s:a-1,l=this.__iteratees__,p=l.length,f=0,d=nr(u,this.__takeCount__);if(!r||!n&&i==u&&d==u)return baseWrapperValue(e,this.__actions__);var h=[];e:for(;u--&&f<d;){c+=t;for(var y=-1,g=e[c];++y<p;){var b=l[y],_=b.iteratee,v=b.type,m=_(g);if(v==C)g=m;else if(!m){if(v==x)continue e;break e}}h[f++]=g}return h}function Hash(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function hashClear(){this.__data__=dr?dr(null):{},this.size=0}function hashDelete(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}function hashGet(e){var t=this.__data__;if(dr){var r=t[e];return r===c?o:r}return st.call(t,e)?t[e]:o}function hashHas(e){var t=this.__data__;return dr?t[e]!==o:st.call(t,e)}function hashSet(e,t){var r=this.__data__;return this.size+=this.has(e)?0:1,r[e]=dr&&t===o?c:t,this}function ListCache(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function listCacheClear(){this.__data__=[],this.size=0}function listCacheDelete(e){var t=this.__data__,r=assocIndexOf(t,e);return!(r<0)&&(r==t.length-1?t.pop():At.call(t,r,1),--this.size,!0)}function listCacheGet(e){var t=this.__data__,r=assocIndexOf(t,e);return r<0?o:t[r][1]}function listCacheHas(e){return assocIndexOf(this.__data__,e)>-1}function listCacheSet(e,t){var r=this.__data__,n=assocIndexOf(r,e);return n<0?(++this.size,r.push([e,t])):r[n][1]=t,this}function MapCache(e){var t=-1,r=null==e?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function mapCacheClear(){this.size=0,this.__data__={hash:new Hash,map:new(cr||ListCache),string:new Hash}}function mapCacheDelete(e){var t=getMapData(this,e)["delete"](e);return this.size-=t?1:0,t}function mapCacheGet(e){return getMapData(this,e).get(e)}function mapCacheHas(e){return getMapData(this,e).has(e)}function mapCacheSet(e,t){var r=getMapData(this,e),n=r.size;return r.set(e,t),this.size+=r.size==n?0:1,this}function SetCache(e){var t=-1,r=null==e?0:e.length;for(this.__data__=new MapCache;++t<r;)this.add(e[t])}function setCacheAdd(e){return this.__data__.set(e,c),this}function setCacheHas(e){return this.__data__.has(e)}function Stack(e){var t=this.__data__=new ListCache(e);this.size=t.size}function stackClear(){this.__data__=new ListCache,this.size=0}function stackDelete(e){var t=this.__data__,r=t["delete"](e);return this.size=t.size,r}function stackGet(e){return this.__data__.get(e)}function stackHas(e){return this.__data__.has(e)}function stackSet(e,t){var r=this.__data__;if(r instanceof ListCache){var n=r.__data__;if(!cr||n.length<a-1)return n.push([e,t]),this.size=++r.size,this;r=this.__data__=new MapCache(n)}return r.set(e,t),this.size=r.size,this}function arrayLikeKeys(e,t){var r=In(e),n=!r&&An(e),i=!r&&!n&&jn(e),o=!r&&!n&&!i&&Ln(e),a=r||n||i||o,s=a?baseTimes(e.length,et):[],u=s.length;for(var c in e)!t&&!st.call(e,c)||a&&("length"==c||i&&("offset"==c||"parent"==c)||o&&("buffer"==c||"byteLength"==c||"byteOffset"==c)||isIndex(c,u))||s.push(c);return s}function arraySample(e){var t=e.length;return t?e[baseRandom(0,t-1)]:o}function arraySampleSize(e,t){return shuffleSelf(copyArray(e),baseClamp(t,0,e.length))}function arrayShuffle(e){return shuffleSelf(copyArray(e))}function assignMergeValue(e,t,r){(r===o||eq(e[t],r))&&(r!==o||t in e)||baseAssignValue(e,t,r)}function assignValue(e,t,r){var n=e[t];st.call(e,t)&&eq(n,r)&&(r!==o||t in e)||baseAssignValue(e,t,r)}function assocIndexOf(e,t){for(var r=e.length;r--;)if(eq(e[r][0],t))return r;return-1}function baseAggregator(e,t,r,n){return Pr(e,function(e,i,o){t(n,e,r(e),o)}),n}function baseAssign(e,t){return e&&copyObject(t,keys(t),e)}function baseAssignIn(e,t){return e&&copyObject(t,keysIn(t),e)}function baseAssignValue(e,t,r){"__proto__"==t&&Rt?Rt(e,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):e[t]=r}function baseAt(e,r){for(var n=-1,i=r.length,a=t(i),s=null==e;++n<i;)a[n]=s?o:get(e,r[n]);return a}function baseClamp(e,t,r){return e===e&&(r!==o&&(e=e<=r?e:r),t!==o&&(e=e>=t?e:t)),e}function baseClone(e,t,r,n,i,a){var s,u=t&f,c=t&d,l=t&h;if(r&&(s=i?r(e,n,i,a):r(e)),s!==o)return s;if(!isObject(e))return e;var p=In(e);if(p){if(s=initCloneArray(e),!u)return copyArray(e,s)}else{var y=Nr(e),g=y==K||y==J;if(jn(e))return cloneBuffer(e,u);if(y==X||y==W||g&&!i){if(s=c||g?{}:initCloneObject(e),!u)return c?copySymbolsIn(e,baseAssignIn(s,e)):copySymbols(e,baseAssign(s,e))}else{if(!wt[y])return i?e:{};s=initCloneByTag(e,y,u)}}a||(a=new Stack);var b=a.get(e);if(b)return b;a.set(e,s),Rn(e)?e.forEach(function(n){s.add(baseClone(n,t,r,n,e,a))}):Cn(e)&&e.forEach(function(n,i){s.set(i,baseClone(n,t,r,i,e,a))});var _=l?c?getAllKeysIn:getAllKeys:c?keysIn:keys,v=p?o:_(e);return arrayEach(v||e,function(n,i){v&&(i=n,n=e[i]),assignValue(s,i,baseClone(n,t,r,i,e,a))}),s}function baseConforms(e){var t=keys(e);return function(r){return baseConformsTo(r,e,t)}}function baseConformsTo(e,t,r){var n=r.length;if(null==e)return!n;for(e=Ye(e);n--;){var i=r[n],a=t[i],s=e[i];if(s===o&&!(i in e)||!a(s))return!1}return!0}function baseDelay(e,t,r){if("function"!=typeof e)throw new tt(u);return Br(function(){e.apply(o,r)},t)}function baseDifference(e,t,r,n){var i=-1,o=arrayIncludes,s=!0,u=e.length,c=[],l=t.length;if(!u)return c;r&&(t=arrayMap(t,baseUnary(r))),n?(o=arrayIncludesWith,s=!1):t.length>=a&&(o=cacheHas,s=!1,t=new SetCache(t));e:for(;++i<u;){var p=e[i],f=null==r?p:r(p);if(p=n||0!==p?p:0,s&&f===f){for(var d=l;d--;)if(t[d]===f)continue e;c.push(p)}else o(t,f,n)||c.push(p)}return c}function baseEvery(e,t){var r=!0;return Pr(e,function(e,n,i){return r=!!t(e,n,i)}),r}function baseExtremum(e,t,r){for(var n=-1,i=e.length;++n<i;){var a=e[n],s=t(a);if(null!=s&&(u===o?s===s&&!isSymbol(s):r(s,u)))var u=s,c=a}return c}function baseFill(e,t,r,n){var i=e.length;for(r=toInteger(r),r<0&&(r=-r>i?0:i+r),n=n===o||n>i?i:toInteger(n),n<0&&(n+=i),n=r>n?0:toLength(n);r<n;)e[r++]=t;return e}function baseFilter(e,t){var r=[];return Pr(e,function(e,n,i){t(e,n,i)&&r.push(e)}),r}function baseFlatten(e,t,r,n,i){var o=-1,a=e.length;for(r||(r=isFlattenable),i||(i=[]);++o<a;){var s=e[o];t>0&&r(s)?t>1?baseFlatten(s,t-1,r,n,i):arrayPush(i,s):n||(i[i.length]=s)}return i}function baseForOwn(e,t){return e&&Ar(e,t,keys)}function baseForOwnRight(e,t){return e&&Ir(e,t,keys)}function baseFunctions(e,t){return arrayFilter(t,function(t){return isFunction(e[t])})}function baseGet(e,t){t=castPath(t,e);for(var r=0,n=t.length;null!=e&&r<n;)e=e[toKey(t[r++])];return r&&r==n?e:o}function baseGetAllKeys(e,t,r){var n=t(e);return In(e)?n:arrayPush(n,r(e))}function baseGetTag(e){return null==e?e===o?oe:Y:Gt&&Gt in Ye(e)?getRawTag(e):objectToString(e)}function baseGt(e,t){return e>t}function baseHas(e,t){return null!=e&&st.call(e,t)}function baseHasIn(e,t){return null!=e&&t in Ye(e)}function baseInRange(e,t,r){return e>=nr(t,r)&&e<rr(t,r)}function baseIntersection(e,r,n){for(var i=n?arrayIncludesWith:arrayIncludes,a=e[0].length,s=e.length,u=s,c=t(s),l=Infinity,p=[];u--;){var f=e[u];u&&r&&(f=arrayMap(f,baseUnary(r))),l=nr(f.length,l),c[u]=!n&&(r||a>=120&&f.length>=120)?new SetCache(u&&f):o}f=e[0];var d=-1,h=c[0];e:for(;++d<a&&p.length<l;){var y=f[d],g=r?r(y):y;if(y=n||0!==y?y:0,!(h?cacheHas(h,g):i(p,g,n))){for(u=s;--u;){var b=c[u];if(!(b?cacheHas(b,g):i(e[u],g,n)))continue e}h&&h.push(g),p.push(y)}}return p}function baseInverter(e,t,r,n){return baseForOwn(e,function(e,i,o){t(n,r(e),i,o)}),n}function baseInvoke(e,t,r){t=castPath(t,e),e=parent(e,t);var n=null==e?e:e[toKey(last(t))];return null==n?o:apply(n,e,r)}function baseIsArguments(e){return isObjectLike(e)&&baseGetTag(e)==W}function baseIsArrayBuffer(e){return isObjectLike(e)&&baseGetTag(e)==ue}function baseIsDate(e){return isObjectLike(e)&&baseGetTag(e)==Q}function baseIsEqual(e,t,r,n,i){return e===t||(null==e||null==t||!isObjectLike(e)&&!isObjectLike(t)?e!==e&&t!==t:baseIsEqualDeep(e,t,r,n,baseIsEqual,i))}function baseIsEqualDeep(e,t,r,n,i,o){var a=In(e),s=In(t),u=a?q:Nr(e),c=s?q:Nr(t);u=u==W?X:u,c=c==W?X:c;var l=u==X,p=c==X,f=u==c;if(f&&jn(e)){if(!jn(t))return!1;a=!0,l=!1}if(f&&!l)return o||(o=new Stack),a||Ln(e)?equalArrays(e,t,r,n,i,o):equalByTag(e,t,u,r,n,i,o);if(!(r&y)){var d=l&&st.call(e,"__wrapped__"),h=p&&st.call(t,"__wrapped__");if(d||h){var g=d?e.value():e,b=h?t.value():t;return o||(o=new Stack),i(g,b,r,n,o)}}return!!f&&(o||(o=new Stack),equalObjects(e,t,r,n,i,o))}function baseIsMap(e){return isObjectLike(e)&&Nr(e)==$}function baseIsMatch(e,t,r,n){var i=r.length,a=i,s=!n;if(null==e)return!a;for(e=Ye(e);i--;){var u=r[i];if(s&&u[2]?u[1]!==e[u[0]]:!(u[0]in e))return!1}for(;++i<a;){u=r[i];var c=u[0],l=e[c],p=u[1];if(s&&u[2]){if(l===o&&!(c in e))return!1}else{var f=new Stack;if(n)var d=n(l,p,c,e,t,f);if(!(d===o?baseIsEqual(p,l,y|g,n,f):d))return!1}}return!0}function baseIsNative(e){return!(!isObject(e)||isMasked(e))&&(isFunction(e)?dt:Ve).test(toSource(e))}function baseIsRegExp(e){return isObjectLike(e)&&baseGetTag(e)==te}function baseIsSet(e){return isObjectLike(e)&&Nr(e)==re}function baseIsTypedArray(e){return isObjectLike(e)&&isLength(e.length)&&!!Tt[baseGetTag(e)]}function baseIteratee(e){return"function"==typeof e?e:null==e?identity:"object"==typeof e?In(e)?baseMatchesProperty(e[0],e[1]):baseMatches(e):property(e)}function baseKeys(e){if(!isPrototype(e))return tr(e);var t=[];for(var r in Ye(e))st.call(e,r)&&"constructor"!=r&&t.push(r);return t}function baseKeysIn(e){if(!isObject(e))return nativeKeysIn(e);var t=isPrototype(e),r=[];for(var n in e)("constructor"!=n||!t&&st.call(e,n))&&r.push(n);return r}function baseLt(e,t){return e<t}function baseMap(e,r){var n=-1,i=isArrayLike(e)?t(e.length):[];return Pr(e,function(e,t,o){i[++n]=r(e,t,o)}),i}function baseMatches(e){var t=getMatchData(e);return 1==t.length&&t[0][2]?matchesStrictComparable(t[0][0],t[0][1]):function(r){return r===e||baseIsMatch(r,e,t)}}function baseMatchesProperty(e,t){return isKey(e)&&isStrictComparable(t)?matchesStrictComparable(toKey(e),t):function(r){var n=get(r,e);return n===o&&n===t?hasIn(r,e):baseIsEqual(t,n,y|g)}}function baseMerge(e,t,r,n,i){e!==t&&Ar(t,function(a,s){if(i||(i=new Stack),isObject(a))baseMergeDeep(e,t,s,r,baseMerge,n,i);else{var u=n?n(safeGet(e,s),a,s+"",e,t,i):o;u===o&&(u=a),assignMergeValue(e,s,u)}},keysIn)}function baseMergeDeep(e,t,r,n,i,a,s){var u=safeGet(e,r),c=safeGet(t,r),l=s.get(c);if(l)return void assignMergeValue(e,r,l);var p=a?a(u,c,r+"",e,t,s):o,f=p===o;if(f){var d=In(c),h=!d&&jn(c),y=!d&&!h&&Ln(c);p=c,d||h||y?In(u)?p=u:isArrayLikeObject(u)?p=copyArray(u):h?(f=!1,p=cloneBuffer(c,!0)):y?(f=!1,p=cloneTypedArray(c,!0)):p=[]:isPlainObject(c)||An(c)?(p=u,An(u)?p=toPlainObject(u):isObject(u)&&!isFunction(u)||(p=initCloneObject(c))):f=!1}f&&(s.set(c,p),i(p,c,n,a,s),s["delete"](c)),assignMergeValue(e,r,p)}function baseNth(e,t){var r=e.length;if(r)return t+=t<0?r:0,isIndex(t,r)?e[t]:o}function baseOrderBy(e,t,r){var n=-1;return t=arrayMap(t.length?t:[identity],baseUnary(getIteratee())),baseSortBy(baseMap(e,function(e,r,i){return{criteria:arrayMap(t,function(t){return t(e)}),index:++n,value:e}}),function(e,t){return compareMultiple(e,t,r)})}function basePick(e,t){return basePickBy(e,t,function(t,r){return hasIn(e,r)})}function basePickBy(e,t,r){for(var n=-1,i=t.length,o={};++n<i;){var a=t[n],s=baseGet(e,a);r(s,a)&&baseSet(o,castPath(a,e),s)}return o}function basePropertyDeep(e){return function(t){return baseGet(t,e)}}function basePullAll(e,t,r,n){var i=n?baseIndexOfWith:baseIndexOf,o=-1,a=t.length,s=e;for(e===t&&(t=copyArray(t)),r&&(s=arrayMap(e,baseUnary(r)));++o<a;)for(var u=0,c=t[o],l=r?r(c):c;(u=i(s,l,u,n))>-1;)s!==e&&At.call(s,u,1),At.call(e,u,1);return e}function basePullAt(e,t){for(var r=e?t.length:0,n=r-1;r--;){var i=t[r];if(r==n||i!==o){var o=i;isIndex(i)?At.call(e,i,1):baseUnset(e,i)}}return e}function baseRandom(e,t){return e+$t(ar()*(t-e+1))}function baseRange(e,r,n,i){for(var o=-1,a=rr(Jt((r-e)/(n||1)),0),s=t(a);a--;)s[i?a:++o]=e,e+=n;return s}function baseRepeat(e,t){var r="";if(!e||t<1||t>R)return r;do{t%2&&(r+=e),(t=$t(t/2))&&(e+=e)}while(t);return r}function baseRest(e,t){return Wr(overRest(e,t,identity),e+"")}function baseSample(e){return arraySample(values(e))}function baseSampleSize(e,t){var r=values(e);return shuffleSelf(r,baseClamp(t,0,r.length))}function baseSet(e,t,r,n){if(!isObject(e))return e;t=castPath(t,e);for(var i=-1,a=t.length,s=a-1,u=e;null!=u&&++i<a;){var c=toKey(t[i]),l=r;if(i!=s){var p=u[c];l=n?n(p,c,u):o,l===o&&(l=isObject(p)?p:isIndex(t[i+1])?[]:{})}assignValue(u,c,l),u=u[c]}return e}function baseShuffle(e){return shuffleSelf(values(e))}function baseSlice(e,r,n){var i=-1,o=e.length;r<0&&(r=-r>o?0:o+r),n=n>o?o:n,n<0&&(n+=o),o=r>n?0:n-r>>>0,r>>>=0;for(var a=t(o);++i<o;)a[i]=e[i+r];return a}function baseSome(e,t){var r;return Pr(e,function(e,n,i){return!(r=t(e,n,i))}),!!r}function baseSortedIndex(e,t,r){var n=0,i=null==e?n:e.length;if("number"==typeof t&&t===t&&i<=M){for(;n<i;){var o=n+i>>>1,a=e[o];null!==a&&!isSymbol(a)&&(r?a<=t:a<t)?n=o+1:i=o}return i}return baseSortedIndexBy(e,t,identity,r)}function baseSortedIndexBy(e,t,r,n){t=r(t);for(var i=0,a=null==e?0:e.length,s=t!==t,u=null===t,c=isSymbol(t),l=t===o;i<a;){var p=$t((i+a)/2),f=r(e[p]),d=f!==o,h=null===f,y=f===f,g=isSymbol(f);if(s)var b=n||y;else b=l?y&&(n||d):u?y&&d&&(n||!h):c?y&&d&&!h&&(n||!g):!h&&!g&&(n?f<=t:f<t);b?i=p+1:a=p}return nr(a,D)}function baseSortedUniq(e,t){for(var r=-1,n=e.length,i=0,o=[];++r<n;){var a=e[r],s=t?t(a):a;if(!r||!eq(s,u)){var u=s;o[i++]=0===a?0:a}}return o}function baseToNumber(e){return"number"==typeof e?e:isSymbol(e)?F:+e}function baseToString(e){if("string"==typeof e)return e;if(In(e))return arrayMap(e,baseToString)+"";if(isSymbol(e))return wr?wr.call(e):"";var t=e+"";return"0"==t&&1/e==-G?"-0":t}function baseUniq(e,t,r){var n=-1,i=arrayIncludes,o=e.length,s=!0,u=[],c=u;if(r)s=!1,i=arrayIncludesWith;else if(o>=a){var l=t?null:Gr(e);if(l)return setToArray(l);s=!1,i=cacheHas,c=new SetCache}else c=t?[]:u;e:for(;++n<o;){var p=e[n],f=t?t(p):p;if(p=r||0!==p?p:0,s&&f===f){for(var d=c.length;d--;)if(c[d]===f)continue e;t&&c.push(f),u.push(p)}else i(c,f,r)||(c!==u&&c.push(f),u.push(p))}return u}function baseUnset(e,t){return t=castPath(t,e),null==(e=parent(e,t))||delete e[toKey(last(t))]}function baseUpdate(e,t,r,n){return baseSet(e,t,r(baseGet(e,t)),n)}function baseWhile(e,t,r,n){for(var i=e.length,o=n?i:-1;(n?o--:++o<i)&&t(e[o],o,e););return r?baseSlice(e,n?0:o,n?o+1:i):baseSlice(e,n?o+1:0,n?i:o)}function baseWrapperValue(e,t){var r=e;return r instanceof LazyWrapper&&(r=r.value()),arrayReduce(t,function(e,t){return t.func.apply(t.thisArg,arrayPush([e],t.args))},r)}function baseXor(e,r,n){var i=e.length;if(i<2)return i?baseUniq(e[0]):[];for(var o=-1,a=t(i);++o<i;)for(var s=e[o],u=-1;++u<i;)u!=o&&(a[o]=baseDifference(a[o]||s,e[u],r,n));return baseUniq(baseFlatten(a,1),r,n)}function baseZipObject(e,t,r){for(var n=-1,i=e.length,a=t.length,s={};++n<i;){var u=n<a?t[n]:o;r(s,e[n],u)}return s}function castArrayLikeObject(e){return isArrayLikeObject(e)?e:[]}function castFunction(e){return"function"==typeof e?e:identity}function castPath(e,t){return In(e)?e:isKey(e,t)?[e]:qr(toString(e))}function castSlice(e,t,r){var n=e.length;return r=r===o?n:r,!t&&r>=n?e:baseSlice(e,t,r)}function cloneBuffer(e,t){if(t)return e.slice();var r=e.length,n=vt?vt(r):new e.constructor(r);return e.copy(n),n}function cloneArrayBuffer(e){var t=new e.constructor(e.byteLength);return new _t(t).set(new _t(e)),t}function cloneDataView(e,t){var r=t?cloneArrayBuffer(e.buffer):e.buffer;return new e.constructor(r,e.byteOffset,e.byteLength)}function cloneRegExp(e){var t=new e.constructor(e.source,ze.exec(e));return t.lastIndex=e.lastIndex,t}function cloneSymbol(e){return Tr?Ye(Tr.call(e)):{}}function cloneTypedArray(e,t){var r=t?cloneArrayBuffer(e.buffer):e.buffer;return new e.constructor(r,e.byteOffset,e.length)}function compareAscending(e,t){if(e!==t){var r=e!==o,n=null===e,i=e===e,a=isSymbol(e),s=t!==o,u=null===t,c=t===t,l=isSymbol(t);if(!u&&!l&&!a&&e>t||a&&s&&c&&!u&&!l||n&&s&&c||!r&&c||!i)return 1;if(!n&&!a&&!l&&e<t||l&&r&&i&&!n&&!a||u&&r&&i||!s&&i||!c)return-1}return 0}function compareMultiple(e,t,r){for(var n=-1,i=e.criteria,o=t.criteria,a=i.length,s=r.length;++n<a;){var u=compareAscending(i[n],o[n]);if(u){if(n>=s)return u;return u*("desc"==r[n]?-1:1)}}return e.index-t.index}function composeArgs(e,r,n,i){for(var o=-1,a=e.length,s=n.length,u=-1,c=r.length,l=rr(a-s,0),p=t(c+l),f=!i;++u<c;)p[u]=r[u];for(;++o<s;)(f||o<a)&&(p[n[o]]=e[o]);for(;l--;)p[u++]=e[o++];return p}function composeArgsRight(e,r,n,i){for(var o=-1,a=e.length,s=-1,u=n.length,c=-1,l=r.length,p=rr(a-u,0),f=t(p+l),d=!i;++o<p;)f[o]=e[o];for(var h=o;++c<l;)f[h+c]=r[c];for(;++s<u;)(d||o<a)&&(f[h+n[s]]=e[o++]);return f}function copyArray(e,r){var n=-1,i=e.length;for(r||(r=t(i));++n<i;)r[n]=e[n];return r}function copyObject(e,t,r,n){var i=!r;r||(r={});for(var a=-1,s=t.length;++a<s;){var u=t[a],c=n?n(r[u],e[u],u,r,e):o;c===o&&(c=e[u]),i?baseAssignValue(r,u,c):assignValue(r,u,c)}return r}function copySymbols(e,t){return copyObject(e,Lr(e),t)}function copySymbolsIn(e,t){return copyObject(e,Fr(e),t)}function createAggregator(e,t){return function(r,n){var i=In(r)?arrayAggregator:baseAggregator,o=t?t():{};return i(r,e,getIteratee(n,2),o)}}function createAssigner(e){return baseRest(function(t,r){var n=-1,i=r.length,a=i>1?r[i-1]:o,s=i>2?r[2]:o;for(a=e.length>3&&"function"==typeof a?(i--,a):o,s&&isIterateeCall(r[0],r[1],s)&&(a=i<3?o:a,i=1),t=Ye(t);++n<i;){var u=r[n];u&&e(t,u,n,a)}return t})}function createBaseEach(e,t){return function(r,n){if(null==r)return r;if(!isArrayLike(r))return e(r,n);for(var i=r.length,o=t?i:-1,a=Ye(r);(t?o--:++o<i)&&!1!==n(a[o],o,a););return r}}function createBaseFor(e){return function(t,r,n){for(var i=-1,o=Ye(t),a=n(t),s=a.length;s--;){var u=a[e?s:++i];if(!1===r(o[u],u,o))break}return t}}function createBind(e,t,r){function wrapper(){return(this&&this!==Ct&&this instanceof wrapper?i:e).apply(n?r:this,arguments)}var n=t&b,i=createCtor(e);return wrapper}function createCaseFirst(e){return function(t){t=toString(t);var r=hasUnicode(t)?stringToArray(t):o,n=r?r[0]:t.charAt(0),i=r?castSlice(r,1).join(""):t.slice(1);return n[e]()+i}}function createCompounder(e){return function(t){return arrayReduce(words(deburr(t).replace(ht,"")),e,"")}}function createCtor(e){return function(){var t=arguments;switch(t.length){case 0:return new e;case 1:return new e(t[0]);case 2:return new e(t[0],t[1]);case 3:return new e(t[0],t[1],t[2]);case 4:return new e(t[0],t[1],t[2],t[3]);case 5:return new e(t[0],t[1],t[2],t[3],t[4]);case 6:return new e(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new e(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=Er(e.prototype),n=e.apply(r,t);return isObject(n)?n:r}}function createCurry(e,r,n){function wrapper(){for(var a=arguments.length,s=t(a),u=a,c=getHolder(wrapper);u--;)s[u]=arguments[u];var l=a<3&&s[0]!==c&&s[a-1]!==c?[]:replaceHolders(s,c);return(a-=l.length)<n?createRecurry(e,r,createHybrid,wrapper.placeholder,o,s,l,o,o,n-a):apply(this&&this!==Ct&&this instanceof wrapper?i:e,this,s)}var i=createCtor(e);return wrapper}function createFind(e){return function(t,r,n){var i=Ye(t);if(!isArrayLike(t)){var a=getIteratee(r,3);t=keys(t),r=function(e){return a(i[e],e,i)}}var s=e(t,r,n);return s>-1?i[a?t[s]:s]:o}}function createFlow(e){return flatRest(function(t){var r=t.length,n=r,i=LodashWrapper.prototype.thru;for(e&&t.reverse();n--;){var a=t[n];if("function"!=typeof a)throw new tt(u);if(i&&!s&&"wrapper"==getFuncName(a))var s=new LodashWrapper([],!0)}for(n=s?n:r;++n<r;){a=t[n];var c=getFuncName(a),l="wrapper"==c?Rr(a):o;s=l&&isLaziable(l[0])&&l[1]==(E|m|T|P)&&!l[4].length&&1==l[9]?s[getFuncName(l[0])].apply(s,l[3]):1==a.length&&isLaziable(a)?s[c]():s.thru(a)}return function(){var e=arguments,n=e[0];if(s&&1==e.length&&In(n))return s.plant(n).value();for(var i=0,o=r?t[i].apply(this,e):n;++i<r;)o=t[i].call(this,o);return o}})}function createHybrid(e,r,n,i,a,s,u,c,l,p){function wrapper(){for(var o=arguments.length,b=t(o),_=o;_--;)b[_]=arguments[_];if(y)var m=getHolder(wrapper),S=countHolders(b,m);if(i&&(b=composeArgs(b,i,a,y)),s&&(b=composeArgsRight(b,s,u,y)),o-=S,y&&o<p){var T=replaceHolders(b,m);return createRecurry(e,r,createHybrid,wrapper.placeholder,n,b,T,c,l,p-o)}var w=d?n:this,E=h?w[e]:e;return o=b.length,c?b=reorder(b,c):g&&o>1&&b.reverse(),f&&l<o&&(b.length=l),this&&this!==Ct&&this instanceof wrapper&&(E=v||createCtor(E)),E.apply(w,b)}var f=r&E,d=r&b,h=r&_,y=r&(m|S),g=r&O,v=h?o:createCtor(e);return wrapper}function createInverter(e,t){return function(r,n){return baseInverter(r,e,t(n),{})}}function createMathOperation(e,t){return function(r,n){var i;if(r===o&&n===o)return t;if(r!==o&&(i=r),n!==o){if(i===o)return n;"string"==typeof r||"string"==typeof n?(r=baseToString(r),n=baseToString(n)):(r=baseToNumber(r),n=baseToNumber(n)),i=e(r,n)}return i}}function createOver(e){return flatRest(function(t){return t=arrayMap(t,baseUnary(getIteratee())),baseRest(function(r){var n=this;return e(t,function(e){return apply(e,n,r)})})})}function createPadding(e,t){t=t===o?" ":baseToString(t);var r=t.length;if(r<2)return r?baseRepeat(t,e):t;var n=baseRepeat(t,Jt(e/stringSize(t)));return hasUnicode(t)?castSlice(stringToArray(n),0,e).join(""):n.slice(0,e)}function createPartial(e,r,n,i){function wrapper(){for(var r=-1,s=arguments.length,u=-1,c=i.length,l=t(c+s),p=this&&this!==Ct&&this instanceof wrapper?a:e;++u<c;)l[u]=i[u];for(;s--;)l[u++]=arguments[++r];return apply(p,o?n:this,l)}var o=r&b,a=createCtor(e);return wrapper}function createRange(e){return function(t,r,n){return n&&"number"!=typeof n&&isIterateeCall(t,r,n)&&(r=n=o),t=toFinite(t),r===o?(r=t,t=0):r=toFinite(r),n=n===o?t<r?1:-1:toFinite(n),baseRange(t,r,n,e)}}function createRelationalOperation(e){return function(t,r){return"string"==typeof t&&"string"==typeof r||(t=toNumber(t),r=toNumber(r)),e(t,r)}}function createRecurry(e,t,r,n,i,a,s,u,c,l){var p=t&m,f=p?s:o,d=p?o:s,h=p?a:o,y=p?o:a;t|=p?T:w,(t&=~(p?w:T))&v||(t&=~(b|_));var g=[e,t,i,h,f,y,d,u,c,l],S=r.apply(o,g);return isLaziable(e)&&Mr(S,g),S.placeholder=n,setWrapToString(S,e,t)}function createRound(e){var t=Be[e];return function(e,r){if(e=toNumber(e),(r=null==r?0:nr(toInteger(r),292))&&Xt(e)){var n=(toString(e)+"e").split("e");return n=(toString(t(n[0]+"e"+(+n[1]+r)))+"e").split("e"),+(n[0]+"e"+(+n[1]-r))}return t(e)}}function createToPairs(e){return function(t){var r=Nr(t);return r==$?mapToArray(t):r==re?setToPairs(t):baseToPairs(t,e(t))}}function createWrap(e,t,r,n,i,a,s,c){var l=t&_;if(!l&&"function"!=typeof e)throw new tt(u);var p=n?n.length:0;if(p||(t&=~(T|w),n=i=o),s=s===o?s:rr(toInteger(s),0),c=c===o?c:toInteger(c),p-=i?i.length:0,t&w){var f=n,d=i;n=i=o}var h=l?o:Rr(e),y=[e,t,r,n,i,f,d,a,s,c];if(h&&mergeData(y,h),e=y[0],t=y[1],r=y[2],n=y[3],i=y[4],c=y[9]=y[9]===o?l?0:e.length:rr(y[9]-p,0),!c&&t&(m|S)&&(t&=~(m|S)),t&&t!=b)g=t==m||t==S?createCurry(e,t,c):t!=T&&t!=(b|T)||i.length?createHybrid.apply(o,y):createPartial(e,t,r,n);else var g=createBind(e,t,r);return setWrapToString((h?kr:Mr)(g,y),e,t)}function customDefaultsAssignIn(e,t,r,n){return e===o||eq(e,it[r])&&!st.call(n,r)?t:e}function customDefaultsMerge(e,t,r,n,i,a){return isObject(e)&&isObject(t)&&(a.set(t,e),baseMerge(e,t,o,customDefaultsMerge,a),a["delete"](t)),e}function customOmitClone(e){return isPlainObject(e)?o:e}function equalArrays(e,t,r,n,i,a){var s=r&y,u=e.length,c=t.length;if(u!=c&&!(s&&c>u))return!1;var l=a.get(e);if(l&&a.get(t))return l==t;var p=-1,f=!0,d=r&g?new SetCache:o;for(a.set(e,t),a.set(t,e);++p<u;){var h=e[p],b=t[p];if(n)var _=s?n(b,h,p,t,e,a):n(h,b,p,e,t,a);if(_!==o){if(_)continue;f=!1;break}if(d){if(!arraySome(t,function(e,t){if(!cacheHas(d,t)&&(h===e||i(h,e,r,n,a)))return d.push(t)})){f=!1;break}}else if(h!==b&&!i(h,b,r,n,a)){f=!1;break}}return a["delete"](e),a["delete"](t),f}function equalByTag(e,t,r,n,i,o,a){switch(r){case ce:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case ue:return!(e.byteLength!=t.byteLength||!o(new _t(e),new _t(t)));case U:case Q:case Z:return eq(+e,+t);case H:return e.name==t.name&&e.message==t.message;case te:case ne:return e==t+"";case $:var s=mapToArray;case re:var u=n&y;if(s||(s=setToArray),e.size!=t.size&&!u)return!1;var c=a.get(e);if(c)return c==t;n|=g,a.set(e,t);var l=equalArrays(s(e),s(t),n,i,o,a);return a["delete"](e),l;case ie:if(Tr)return Tr.call(e)==Tr.call(t)}return!1}function equalObjects(e,t,r,n,i,a){var s=r&y,u=getAllKeys(e),c=u.length;if(c!=getAllKeys(t).length&&!s)return!1;for(var l=c;l--;){var p=u[l];if(!(s?p in t:st.call(t,p)))return!1}var f=a.get(e);if(f&&a.get(t))return f==t;var d=!0;a.set(e,t),a.set(t,e);for(var h=s;++l<c;){p=u[l];var g=e[p],b=t[p];if(n)var _=s?n(b,g,p,t,e,a):n(g,b,p,e,t,a);if(!(_===o?g===b||i(g,b,r,n,a):_)){d=!1;break}h||(h="constructor"==p)}if(d&&!h){var v=e.constructor,m=t.constructor;v!=m&&"constructor"in e&&"constructor"in t&&!("function"==typeof v&&v instanceof v&&"function"==typeof m&&m instanceof m)&&(d=!1)}return a["delete"](e),a["delete"](t),d}function flatRest(e){return Wr(overRest(e,o,flatten),e+"")}function getAllKeys(e){return baseGetAllKeys(e,keys,Lr)}function getAllKeysIn(e){return baseGetAllKeys(e,keysIn,Fr)}function getFuncName(e){for(var t=e.name+"",r=yr[t],n=st.call(yr,t)?r.length:0;n--;){var i=r[n],o=i.func;if(null==o||o==e)return i.name}return t}function getHolder(e){return(st.call(lodash,"placeholder")?lodash:e).placeholder}function getIteratee(){var e=lodash.iteratee||iteratee;return e=e===iteratee?baseIteratee:e,arguments.length?e(arguments[0],arguments[1]):e}function getMapData(e,t){var r=e.__data__;return isKeyable(t)?r["string"==typeof t?"string":"hash"]:r.map}function getMatchData(e){for(var t=keys(e),r=t.length;r--;){var n=t[r],i=e[n];t[r]=[n,i,isStrictComparable(i)]}return t}function getNative(e,t){var r=getValue(e,t);return baseIsNative(r)?r:o}function getRawTag(e){var t=st.call(e,Gt),r=e[Gt];try{e[Gt]=o;var n=!0}catch(e){}var i=lt.call(e);return n&&(t?e[Gt]=r:delete e[Gt]),i}function getView(e,t,r){for(var n=-1,i=r.length;++n<i;){var o=r[n],a=o.size;switch(o.type){case"drop":e+=a;break;case"dropRight":t-=a;break;case"take":t=nr(t,e+a);break;case"takeRight":e=rr(e,t-a)}}return{start:e,end:t}}function getWrapDetails(e){var t=e.match(De);return t?t[1].split(Me):[]}function hasPath(e,t,r){t=castPath(t,e);for(var n=-1,i=t.length,o=!1;++n<i;){var a=toKey(t[n]);if(!(o=null!=e&&r(e,a)))break;e=e[a]}return o||++n!=i?o:!!(i=null==e?0:e.length)&&isLength(i)&&isIndex(a,i)&&(In(e)||An(e))}function initCloneArray(e){var t=e.length,r=new e.constructor(t);return t&&"string"==typeof e[0]&&st.call(e,"index")&&(r.index=e.index,r.input=e.input),r}function initCloneObject(e){return"function"!=typeof e.constructor||isPrototype(e)?{}:Er(Et(e))}function initCloneByTag(e,t,r){var n=e.constructor;switch(t){case ue:return cloneArrayBuffer(e);case U:case Q:return new n(+e);case ce:return cloneDataView(e,r);case le:case pe:case fe:case de:case he:case ye:case ge:case be:case _e:return cloneTypedArray(e,r);case $:return new n;case Z:case ne:return new n(e);case te:return cloneRegExp(e);case re:return new n;case ie:return cloneSymbol(e)}}function insertWrapDetails(e,t){var r=t.length;if(!r)return e;var n=r-1;return t[n]=(r>1?"& ":"")+t[n],t=t.join(r>2?", ":" "),e.replace(Ne,"{\n/* [wrapped with "+t+"] */\n")}function isFlattenable(e){return In(e)||An(e)||!!(jt&&e&&e[jt])}function isIndex(e,t){var r=typeof e;return!!(t=null==t?R:t)&&("number"==r||"symbol"!=r&&Ke.test(e))&&e>-1&&e%1==0&&e<t}function isIterateeCall(e,t,r){if(!isObject(r))return!1;var n=typeof t;return!!("number"==n?isArrayLike(r)&&isIndex(t,r.length):"string"==n&&t in r)&&eq(r[t],e)}function isKey(e,t){if(In(e))return!1;var r=typeof e;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=e&&!isSymbol(e))||(je.test(e)||!ke.test(e)||null!=t&&e in Ye(t))}function isKeyable(e){var t=typeof e;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==e:null===e}function isLaziable(e){var t=getFuncName(e),r=lodash[t];if("function"!=typeof r||!(t in LazyWrapper.prototype))return!1;if(e===r)return!0;var n=Rr(r);return!!n&&e===n[0]}function isMasked(e){return!!ct&&ct in e}function isPrototype(e){var t=e&&e.constructor;return e===("function"==typeof t&&t.prototype||it)}function isStrictComparable(e){return e===e&&!isObject(e)}function matchesStrictComparable(e,t){return function(r){return null!=r&&(r[e]===t&&(t!==o||e in Ye(r)))}}function mergeData(e,t){var r=e[1],n=t[1],i=r|n,o=i<(b|_|E),a=n==E&&r==m||n==E&&r==P&&e[7].length<=t[8]||n==(E|P)&&t[7].length<=t[8]&&r==m;if(!o&&!a)return e;n&b&&(e[2]=t[2],i|=r&b?0:v);var s=t[3];if(s){var u=e[3];e[3]=u?composeArgs(u,s,t[4]):s,e[4]=u?replaceHolders(e[3],p):t[4]}return s=t[5],s&&(u=e[5],e[5]=u?composeArgsRight(u,s,t[6]):s,e[6]=u?replaceHolders(e[5],p):t[6]),s=t[7],s&&(e[7]=s),n&E&&(e[8]=null==e[8]?t[8]:nr(e[8],t[8])),null==e[9]&&(e[9]=t[9]),e[0]=t[0],e[1]=i,e}function nativeKeysIn(e){var t=[];if(null!=e)for(var r in Ye(e))t.push(r);return t}function objectToString(e){return lt.call(e)}function overRest(e,r,n){return r=rr(r===o?e.length-1:r,0),function(){for(var i=arguments,o=-1,a=rr(i.length-r,0),s=t(a);++o<a;)s[o]=i[r+o];o=-1;for(var u=t(r+1);++o<r;)u[o]=i[o];return u[r]=n(s),apply(e,this,u)}}function parent(e,t){return t.length<2?e:baseGet(e,baseSlice(t,0,-1))}function reorder(e,t){for(var r=e.length,n=nr(t.length,r),i=copyArray(e);n--;){var a=t[n];e[n]=isIndex(a,r)?i[a]:o}return e}function safeGet(e,t){if(("constructor"!==t||"function"!=typeof e[t])&&"__proto__"!=t)return e[t]}function setWrapToString(e,t,r){var n=t+"";return Wr(e,insertWrapDetails(n,updateWrapDetails(getWrapDetails(n),r)))}function shortOut(e){var t=0,r=0;return function(){var n=ir(),i=j-(n-r);if(r=n,i>0){if(++t>=k)return arguments[0]}else t=0;return e.apply(o,arguments)}}function shuffleSelf(e,t){var r=-1,n=e.length,i=n-1;for(t=t===o?n:t;++r<t;){var a=baseRandom(r,i),s=e[a];e[a]=e[r],e[r]=s}return e.length=t,e}function toKey(e){if("string"==typeof e||isSymbol(e))return e;var t=e+"";return"0"==t&&1/e==-G?"-0":t}function toSource(e){if(null!=e){try{return at.call(e)}catch(e){}try{return e+""}catch(e){}}return""}function updateWrapDetails(e,t){return arrayEach(B,function(r){var n="_."+r[0];t&r[1]&&!arrayIncludes(e,n)&&e.push(n)}),e.sort()}function wrapperClone(e){if(e instanceof LazyWrapper)return e.clone();var t=new LodashWrapper(e.__wrapped__,e.__chain__);return t.__actions__=copyArray(e.__actions__),t.__index__=e.__index__,t.__values__=e.__values__,t}function chunk(e,r,n){r=(n?isIterateeCall(e,r,n):r===o)?1:rr(toInteger(r),0);var i=null==e?0:e.length;if(!i||r<1)return[];for(var a=0,s=0,u=t(Jt(i/r));a<i;)u[s++]=baseSlice(e,a,a+=r);return u}function compact(e){for(var t=-1,r=null==e?0:e.length,n=0,i=[];++t<r;){var o=e[t];o&&(i[n++]=o)}return i}function concat(){var e=arguments.length;if(!e)return[];for(var r=t(e-1),n=arguments[0],i=e;i--;)r[i-1]=arguments[i];return arrayPush(In(n)?copyArray(n):[n],baseFlatten(r,1))}function drop(e,t,r){var n=null==e?0:e.length;return n?(t=r||t===o?1:toInteger(t),baseSlice(e,t<0?0:t,n)):[]}function dropRight(e,t,r){var n=null==e?0:e.length;return n?(t=r||t===o?1:toInteger(t),t=n-t,baseSlice(e,0,t<0?0:t)):[]}function dropRightWhile(e,t){return e&&e.length?baseWhile(e,getIteratee(t,3),!0,!0):[]}function dropWhile(e,t){return e&&e.length?baseWhile(e,getIteratee(t,3),!0):[]}function fill(e,t,r,n){var i=null==e?0:e.length;return i?(r&&"number"!=typeof r&&isIterateeCall(e,t,r)&&(r=0,n=i),baseFill(e,t,r,n)):[]}function findIndex(e,t,r){var n=null==e?0:e.length;if(!n)return-1;var i=null==r?0:toInteger(r);return i<0&&(i=rr(n+i,0)),baseFindIndex(e,getIteratee(t,3),i)}function findLastIndex(e,t,r){var n=null==e?0:e.length;if(!n)return-1;var i=n-1;return r!==o&&(i=toInteger(r),i=r<0?rr(n+i,0):nr(i,n-1)),baseFindIndex(e,getIteratee(t,3),i,!0)}function flatten(e){return(null==e?0:e.length)?baseFlatten(e,1):[]}function flattenDeep(e){return(null==e?0:e.length)?baseFlatten(e,G):[]}function flattenDepth(e,t){return(null==e?0:e.length)?(t=t===o?1:toInteger(t),baseFlatten(e,t)):[]}function fromPairs(e){for(var t=-1,r=null==e?0:e.length,n={};++t<r;){var i=e[t];n[i[0]]=i[1]}return n}function head(e){return e&&e.length?e[0]:o}function indexOf(e,t,r){var n=null==e?0:e.length;if(!n)return-1;var i=null==r?0:toInteger(r);return i<0&&(i=rr(n+i,0)),baseIndexOf(e,t,i)}function initial(e){return(null==e?0:e.length)?baseSlice(e,0,-1):[]}function join(e,t){return null==e?"":er.call(e,t)}function last(e){var t=null==e?0:e.length;return t?e[t-1]:o}function lastIndexOf(e,t,r){var n=null==e?0:e.length;if(!n)return-1;var i=n;return r!==o&&(i=toInteger(r),i=i<0?rr(n+i,0):nr(i,n-1)),t===t?strictLastIndexOf(e,t,i):baseFindIndex(e,baseIsNaN,i,!0)}function nth(e,t){return e&&e.length?baseNth(e,toInteger(t)):o}function pullAll(e,t){return e&&e.length&&t&&t.length?basePullAll(e,t):e}function pullAllBy(e,t,r){return e&&e.length&&t&&t.length?basePullAll(e,t,getIteratee(r,2)):e}function pullAllWith(e,t,r){return e&&e.length&&t&&t.length?basePullAll(e,t,o,r):e}function remove(e,t){var r=[];if(!e||!e.length)return r;var n=-1,i=[],o=e.length;for(t=getIteratee(t,3);++n<o;){var a=e[n];t(a,n,e)&&(r.push(a),i.push(n))}return basePullAt(e,i),r}function reverse(e){return null==e?e:sr.call(e)}function slice(e,t,r){var n=null==e?0:e.length;return n?(r&&"number"!=typeof r&&isIterateeCall(e,t,r)?(t=0,r=n):(t=null==t?0:toInteger(t),r=r===o?n:toInteger(r)),baseSlice(e,t,r)):[]}function sortedIndex(e,t){return baseSortedIndex(e,t)}function sortedIndexBy(e,t,r){return baseSortedIndexBy(e,t,getIteratee(r,2))}function sortedIndexOf(e,t){var r=null==e?0:e.length;if(r){var n=baseSortedIndex(e,t);if(n<r&&eq(e[n],t))return n}return-1}function sortedLastIndex(e,t){return baseSortedIndex(e,t,!0)}function sortedLastIndexBy(e,t,r){return baseSortedIndexBy(e,t,getIteratee(r,2),!0)}function sortedLastIndexOf(e,t){if(null==e?0:e.length){var r=baseSortedIndex(e,t,!0)-1;if(eq(e[r],t))return r}return-1}function sortedUniq(e){return e&&e.length?baseSortedUniq(e):[]}function sortedUniqBy(e,t){return e&&e.length?baseSortedUniq(e,getIteratee(t,2)):[]}function tail(e){var t=null==e?0:e.length;return t?baseSlice(e,1,t):[]}function take(e,t,r){return e&&e.length?(t=r||t===o?1:toInteger(t),baseSlice(e,0,t<0?0:t)):[]}function takeRight(e,t,r){var n=null==e?0:e.length;return n?(t=r||t===o?1:toInteger(t),t=n-t,baseSlice(e,t<0?0:t,n)):[]}function takeRightWhile(e,t){return e&&e.length?baseWhile(e,getIteratee(t,3),!1,!0):[]}function takeWhile(e,t){return e&&e.length?baseWhile(e,getIteratee(t,3)):[]}function uniq(e){return e&&e.length?baseUniq(e):[]}function uniqBy(e,t){return e&&e.length?baseUniq(e,getIteratee(t,2)):[]}function uniqWith(e,t){return t="function"==typeof t?t:o,e&&e.length?baseUniq(e,o,t):[]}function unzip(e){if(!e||!e.length)return[];var t=0;return e=arrayFilter(e,function(e){if(isArrayLikeObject(e))return t=rr(e.length,t),!0}),baseTimes(t,function(t){return arrayMap(e,baseProperty(t))})}function unzipWith(e,t){if(!e||!e.length)return[];var r=unzip(e);return null==t?r:arrayMap(r,function(e){return apply(t,o,e)})}function zipObject(e,t){return baseZipObject(e||[],t||[],assignValue)}function zipObjectDeep(e,t){return baseZipObject(e||[],t||[],baseSet)}function chain(e){var t=lodash(e);return t.__chain__=!0,t}function tap(e,t){return t(e),e}function thru(e,t){return t(e)}function wrapperChain(){return chain(this)}function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__)}function wrapperNext(){this.__values__===o&&(this.__values__=toArray(this.value()));var e=this.__index__>=this.__values__.length;return{done:e,value:e?o:this.__values__[this.__index__++]}}function wrapperToIterator(){return this}function wrapperPlant(e){for(var t,r=this;r instanceof baseLodash;){var n=wrapperClone(r);n.__index__=0,n.__values__=o,t?i.__wrapped__=n:t=n;var i=n;r=r.__wrapped__}return i.__wrapped__=e,t}function wrapperReverse(){var e=this.__wrapped__;if(e instanceof LazyWrapper){var t=e;return this.__actions__.length&&(t=new LazyWrapper(this)),t=t.reverse(),t.__actions__.push({func:thru,args:[reverse],thisArg:o}),new LodashWrapper(t,this.__chain__)}return this.thru(reverse)}function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__)}function every(e,t,r){var n=In(e)?arrayEvery:baseEvery;return r&&isIterateeCall(e,t,r)&&(t=o),n(e,getIteratee(t,3))}function filter(e,t){return(In(e)?arrayFilter:baseFilter)(e,getIteratee(t,3))}function flatMap(e,t){return baseFlatten(map(e,t),1)}function flatMapDeep(e,t){return baseFlatten(map(e,t),G)}function flatMapDepth(e,t,r){return r=r===o?1:toInteger(r),baseFlatten(map(e,t),r)}function forEach(e,t){return(In(e)?arrayEach:Pr)(e,getIteratee(t,3))}function forEachRight(e,t){return(In(e)?arrayEachRight:Or)(e,getIteratee(t,3))}function includes(e,t,r,n){e=isArrayLike(e)?e:values(e),r=r&&!n?toInteger(r):0;var i=e.length;return r<0&&(r=rr(i+r,0)),isString(e)?r<=i&&e.indexOf(t,r)>-1:!!i&&baseIndexOf(e,t,r)>-1}function map(e,t){return(In(e)?arrayMap:baseMap)(e,getIteratee(t,3))}function orderBy(e,t,r,n){return null==e?[]:(In(t)||(t=null==t?[]:[t]),r=n?o:r,In(r)||(r=null==r?[]:[r]),baseOrderBy(e,t,r))}function reduce(e,t,r){var n=In(e)?arrayReduce:baseReduce,i=arguments.length<3;return n(e,getIteratee(t,4),r,i,Pr)}function reduceRight(e,t,r){var n=In(e)?arrayReduceRight:baseReduce,i=arguments.length<3;return n(e,getIteratee(t,4),r,i,Or)}function reject(e,t){return(In(e)?arrayFilter:baseFilter)(e,negate(getIteratee(t,3)))}function sample(e){return(In(e)?arraySample:baseSample)(e)}function sampleSize(e,t,r){return t=(r?isIterateeCall(e,t,r):t===o)?1:toInteger(t),(In(e)?arraySampleSize:baseSampleSize)(e,t)}function shuffle(e){return(In(e)?arrayShuffle:baseShuffle)(e)}function size(e){if(null==e)return 0;if(isArrayLike(e))return isString(e)?stringSize(e):e.length;var t=Nr(e);return t==$||t==re?e.size:baseKeys(e).length}function some(e,t,r){var n=In(e)?arraySome:baseSome;return r&&isIterateeCall(e,t,r)&&(t=o),n(e,getIteratee(t,3))}function after(e,t){if("function"!=typeof t)throw new tt(u);return e=toInteger(e),function(){if(--e<1)return t.apply(this,arguments)}}function ary(e,t,r){return t=r?o:t,t=e&&null==t?e.length:t,createWrap(e,E,o,o,o,o,t)}function before(e,t){var r;if("function"!=typeof t)throw new tt(u);return e=toInteger(e),function(){return--e>0&&(r=t.apply(this,arguments)),e<=1&&(t=o),r}}function curry(e,t,r){t=r?o:t;var n=createWrap(e,m,o,o,o,o,o,t);return n.placeholder=curry.placeholder,n}function curryRight(e,t,r){t=r?o:t;var n=createWrap(e,S,o,o,o,o,o,t);return n.placeholder=curryRight.placeholder,n}function debounce(e,t,r){function invokeFunc(t){var r=n,a=i;return n=i=o,p=t,s=e.apply(a,r)}function leadingEdge(e){return p=e,c=Br(timerExpired,t),f?invokeFunc(e):s}function remainingWait(e){var r=e-l,n=e-p,i=t-r;return d?nr(i,a-n):i}function shouldInvoke(e){var r=e-l,n=e-p;return l===o||r>=t||r<0||d&&n>=a}function timerExpired(){var e=gn();if(shouldInvoke(e))return trailingEdge(e);c=Br(timerExpired,remainingWait(e))}function trailingEdge(e){return c=o,h&&n?invokeFunc(e):(n=i=o,s)}function cancel(){c!==o&&Cr(c),p=0,n=l=i=c=o}function flush(){return c===o?s:trailingEdge(gn())}function debounced(){var e=gn(),r=shouldInvoke(e);if(n=arguments,i=this,l=e,r){if(c===o)return leadingEdge(l);if(d)return Cr(c),c=Br(timerExpired,t),invokeFunc(l)}return c===o&&(c=Br(timerExpired,t)),s}var n,i,a,s,c,l,p=0,f=!1,d=!1,h=!0;if("function"!=typeof e)throw new tt(u);return t=toNumber(t)||0,isObject(r)&&(f=!!r.leading,d="maxWait"in r,a=d?rr(toNumber(r.maxWait)||0,t):a,h="trailing"in r?!!r.trailing:h),debounced.cancel=cancel,debounced.flush=flush,debounced}function flip(e){return createWrap(e,O)}function memoize(e,t){if("function"!=typeof e||null!=t&&"function"!=typeof t)throw new tt(u);var r=function(){var n=arguments,i=t?t.apply(this,n):n[0],o=r.cache;if(o.has(i))return o.get(i);var a=e.apply(this,n);return r.cache=o.set(i,a)||o,a};return r.cache=new(memoize.Cache||MapCache),r}function negate(e){if("function"!=typeof e)throw new tt(u);return function(){var t=arguments;switch(t.length){case 0:return!e.call(this);case 1:return!e.call(this,t[0]);case 2:return!e.call(this,t[0],t[1]);case 3:return!e.call(this,t[0],t[1],t[2])}return!e.apply(this,t)}}function once(e){return before(2,e)}function rest(e,t){if("function"!=typeof e)throw new tt(u);return t=t===o?t:toInteger(t),baseRest(e,t)}function spread(e,t){if("function"!=typeof e)throw new tt(u);return t=null==t?0:rr(toInteger(t),0),baseRest(function(r){var n=r[t],i=castSlice(r,0,t);return n&&arrayPush(i,n),apply(e,this,i)})}function throttle(e,t,r){var n=!0,i=!0;if("function"!=typeof e)throw new tt(u);return isObject(r)&&(n="leading"in r?!!r.leading:n,i="trailing"in r?!!r.trailing:i),debounce(e,t,{leading:n,maxWait:t,trailing:i})}function unary(e){return ary(e,1)}function wrap(e,t){return Tn(castFunction(t),e)}function castArray(){if(!arguments.length)return[];var e=arguments[0];return In(e)?e:[e]}function clone(e){return baseClone(e,h)}function cloneWith(e,t){return t="function"==typeof t?t:o,baseClone(e,h,t)}function cloneDeep(e){return baseClone(e,f|h)}function cloneDeepWith(e,t){return t="function"==typeof t?t:o,baseClone(e,f|h,t)}function conformsTo(e,t){return null==t||baseConformsTo(e,t,keys(t))}function eq(e,t){return e===t||e!==e&&t!==t}function isArrayLike(e){return null!=e&&isLength(e.length)&&!isFunction(e)}function isArrayLikeObject(e){return isObjectLike(e)&&isArrayLike(e)}function isBoolean(e){return!0===e||!1===e||isObjectLike(e)&&baseGetTag(e)==U}function isElement(e){return isObjectLike(e)&&1===e.nodeType&&!isPlainObject(e)}function isEmpty(e){if(null==e)return!0;if(isArrayLike(e)&&(In(e)||"string"==typeof e||"function"==typeof e.splice||jn(e)||Ln(e)||An(e)))return!e.length;var t=Nr(e);if(t==$||t==re)return!e.size;if(isPrototype(e))return!baseKeys(e).length;for(var r in e)if(st.call(e,r))return!1;return!0}function isEqual(e,t){return baseIsEqual(e,t)}function isEqualWith(e,t,r){r="function"==typeof r?r:o;var n=r?r(e,t):o;return n===o?baseIsEqual(e,t,o,r):!!n}function isError(e){if(!isObjectLike(e))return!1;var t=baseGetTag(e);return t==H||t==V||"string"==typeof e.message&&"string"==typeof e.name&&!isPlainObject(e)}function isFinite(e){return"number"==typeof e&&Xt(e)}function isFunction(e){if(!isObject(e))return!1;var t=baseGetTag(e);return t==K||t==J||t==z||t==ee}function isInteger(e){return"number"==typeof e&&e==toInteger(e)}function isLength(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=R}function isObject(e){var t=typeof e;return null!=e&&("object"==t||"function"==t)}function isObjectLike(e){return null!=e&&"object"==typeof e}function isMatch(e,t){return e===t||baseIsMatch(e,t,getMatchData(t))}function isMatchWith(e,t,r){return r="function"==typeof r?r:o,baseIsMatch(e,t,getMatchData(t),r)}function isNaN(e){return isNumber(e)&&e!=+e}function isNative(e){if(Dr(e))throw new n(s);return baseIsNative(e)}function isNull(e){return null===e}function isNil(e){return null==e}function isNumber(e){return"number"==typeof e||isObjectLike(e)&&baseGetTag(e)==Z}function isPlainObject(e){if(!isObjectLike(e)||baseGetTag(e)!=X)return!1;var t=Et(e);if(null===t)return!0;var r=st.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&at.call(r)==pt}function isSafeInteger(e){return isInteger(e)&&e>=-R&&e<=R}function isString(e){return"string"==typeof e||!In(e)&&isObjectLike(e)&&baseGetTag(e)==ne}function isSymbol(e){return"symbol"==typeof e||isObjectLike(e)&&baseGetTag(e)==ie}function isUndefined(e){return e===o}function isWeakMap(e){return isObjectLike(e)&&Nr(e)==ae}function isWeakSet(e){return isObjectLike(e)&&baseGetTag(e)==se}function toArray(e){if(!e)return[];if(isArrayLike(e))return isString(e)?stringToArray(e):copyArray(e);if(xt&&e[xt])return iteratorToArray(e[xt]());var t=Nr(e);return(t==$?mapToArray:t==re?setToArray:values)(e)}function toFinite(e){if(!e)return 0===e?e:0;if((e=toNumber(e))===G||e===-G){return(e<0?-1:1)*L}return e===e?e:0}function toInteger(e){var t=toFinite(e),r=t%1;return t===t?r?t-r:t:0}function toLength(e){return e?baseClamp(toInteger(e),0,N):0}function toNumber(e){if("number"==typeof e)return e;if(isSymbol(e))return F;if(isObject(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=isObject(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(Re,"");var r=Qe.test(e);return r||He.test(e)?kt(e.slice(2),r?2:8):Ue.test(e)?F:+e}function toPlainObject(e){return copyObject(e,keysIn(e))}function toSafeInteger(e){return e?baseClamp(toInteger(e),-R,R):0===e?e:0}function toString(e){return null==e?"":baseToString(e)}function create(e,t){var r=Er(e);return null==t?r:baseAssign(r,t)}function findKey(e,t){return baseFindKey(e,getIteratee(t,3),baseForOwn)}function findLastKey(e,t){return baseFindKey(e,getIteratee(t,3),baseForOwnRight)}function forIn(e,t){return null==e?e:Ar(e,getIteratee(t,3),keysIn)}function forInRight(e,t){return null==e?e:Ir(e,getIteratee(t,3),keysIn)}function forOwn(e,t){return e&&baseForOwn(e,getIteratee(t,3))}function forOwnRight(e,t){return e&&baseForOwnRight(e,getIteratee(t,3))}function functions(e){return null==e?[]:baseFunctions(e,keys(e))}function functionsIn(e){return null==e?[]:baseFunctions(e,keysIn(e))}function get(e,t,r){var n=null==e?o:baseGet(e,t);return n===o?r:n}function has(e,t){return null!=e&&hasPath(e,t,baseHas)}function hasIn(e,t){return null!=e&&hasPath(e,t,baseHasIn)}function keys(e){return isArrayLike(e)?arrayLikeKeys(e):baseKeys(e)}function keysIn(e){return isArrayLike(e)?arrayLikeKeys(e,!0):baseKeysIn(e)}function mapKeys(e,t){var r={};return t=getIteratee(t,3),baseForOwn(e,function(e,n,i){baseAssignValue(r,t(e,n,i),e)}),r}function mapValues(e,t){var r={};return t=getIteratee(t,3),baseForOwn(e,function(e,n,i){baseAssignValue(r,n,t(e,n,i))}),r}function omitBy(e,t){return pickBy(e,negate(getIteratee(t)))}function pickBy(e,t){if(null==e)return{};var r=arrayMap(getAllKeysIn(e),function(e){return[e]});return t=getIteratee(t),basePickBy(e,r,function(e,r){return t(e,r[0])})}function result(e,t,r){t=castPath(t,e);var n=-1,i=t.length;for(i||(i=1,e=o);++n<i;){var a=null==e?o:e[toKey(t[n])];a===o&&(n=i,a=r),e=isFunction(a)?a.call(e):a}return e}function set(e,t,r){return null==e?e:baseSet(e,t,r)}function setWith(e,t,r,n){return n="function"==typeof n?n:o,null==e?e:baseSet(e,t,r,n)}function transform(e,t,r){var n=In(e),i=n||jn(e)||Ln(e);if(t=getIteratee(t,4),null==r){var o=e&&e.constructor;r=i?n?new o:[]:isObject(e)&&isFunction(o)?Er(Et(e)):{}}return(i?arrayEach:baseForOwn)(e,function(e,n,i){return t(r,e,n,i)}),r}function unset(e,t){return null==e||baseUnset(e,t)}function update(e,t,r){return null==e?e:baseUpdate(e,t,castFunction(r))}function updateWith(e,t,r,n){return n="function"==typeof n?n:o,null==e?e:baseUpdate(e,t,castFunction(r),n)}function values(e){return null==e?[]:baseValues(e,keys(e))}function valuesIn(e){return null==e?[]:baseValues(e,keysIn(e))}function clamp(e,t,r){return r===o&&(r=t,t=o),r!==o&&(r=toNumber(r),r=r===r?r:0),t!==o&&(t=toNumber(t),t=t===t?t:0),baseClamp(toNumber(e),t,r)}function inRange(e,t,r){return t=toFinite(t),r===o?(r=t,t=0):r=toFinite(r),e=toNumber(e),baseInRange(e,t,r)}function random(e,t,r){if(r&&"boolean"!=typeof r&&isIterateeCall(e,t,r)&&(t=r=o),r===o&&("boolean"==typeof t?(r=t,t=o):"boolean"==typeof e&&(r=e,e=o)),e===o&&t===o?(e=0,t=1):(e=toFinite(e),t===o?(t=e,e=0):t=toFinite(t)),e>t){var n=e;e=t,t=n}if(r||e%1||t%1){var i=ar();return nr(e+i*(t-e+It("1e-"+((i+"").length-1))),t)}return baseRandom(e,t)}function capitalize(e){return si(toString(e).toLowerCase())}function deburr(e){return(e=toString(e))&&e.replace(Je,Qt).replace(yt,"")}function endsWith(e,t,r){e=toString(e),t=baseToString(t);var n=e.length;r=r===o?n:baseClamp(toInteger(r),0,n);var i=r;return(r-=t.length)>=0&&e.slice(r,i)==t}function escape(e){return e=toString(e),e&&Pe.test(e)?e.replace(we,Vt):e}function escapeRegExp(e){return e=toString(e),e&&Ge.test(e)?e.replace(Ce,"\\$&"):e}function pad(e,t,r){e=toString(e),t=toInteger(t);var n=t?stringSize(e):0;if(!t||n>=t)return e;var i=(t-n)/2;return createPadding($t(i),r)+e+createPadding(Jt(i),r)}function padEnd(e,t,r){e=toString(e),t=toInteger(t);var n=t?stringSize(e):0;return t&&n<t?e+createPadding(t-n,r):e}function padStart(e,t,r){e=toString(e),t=toInteger(t);var n=t?stringSize(e):0;return t&&n<t?createPadding(t-n,r)+e:e}function parseInt(e,t,r){return r||null==t?t=0:t&&(t=+t),or(toString(e).replace(Le,""),t||0)}function repeat(e,t,r){return t=(r?isIterateeCall(e,t,r):t===o)?1:toInteger(t),baseRepeat(toString(e),t)}function replace(){var e=arguments,t=toString(e[0]);return e.length<3?t:t.replace(e[1],e[2])}function split(e,t,r){return r&&"number"!=typeof r&&isIterateeCall(e,t,r)&&(t=r=o),(r=r===o?N:r>>>0)?(e=toString(e),e&&("string"==typeof t||null!=t&&!Gn(t))&&!(t=baseToString(t))&&hasUnicode(e)?castSlice(stringToArray(e),0,r):e.split(t,r)):[]}function startsWith(e,t,r){return e=toString(e),r=null==r?0:baseClamp(toInteger(r),0,e.length),t=baseToString(t),e.slice(r,r+t.length)==t}function template(e,t,r){var n=lodash.templateSettings;r&&isIterateeCall(e,t,r)&&(t=o),e=toString(e),t=Bn({},t,n,customDefaultsAssignIn);var a,s,u=Bn({},t.imports,n.imports,customDefaultsAssignIn),c=keys(u),l=baseValues(u,c),p=0,f=t.interpolate||$e,d="__p += '",h=Xe((t.escape||$e).source+"|"+f.source+"|"+(f===Ie?qe:$e).source+"|"+(t.evaluate||$e).source+"|$","g"),y="//# sourceURL="+(st.call(t,"sourceURL")?(t.sourceURL+"").replace(/[\r\n]/g," "):"lodash.templateSources["+ ++St+"]")+"\n";e.replace(h,function(t,r,n,i,o,u){return n||(n=i),d+=e.slice(p,u).replace(Ze,escapeStringChar),r&&(a=!0,d+="' +\n__e("+r+") +\n'"),o&&(s=!0,d+="';\n"+o+";\n__p += '"),n&&(d+="' +\n((__t = ("+n+")) == null ? '' : __t) +\n'"),p=u+t.length,t}),d+="';\n";var g=st.call(t,"variable")&&t.variable;g||(d="with (obj) {\n"+d+"\n}\n"),d=(s?d.replace(ve,""):d).replace(me,"$1").replace(Se,"$1;"),d="function("+(g||"obj")+") {\n"+(g?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(a?", __e = _.escape":"")+(s?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+d+"return __p\n}";var b=ui(function(){return i(c,y+"return "+d).apply(o,l)});if(b.source=d,isError(b))throw b;return b}function toLower(e){return toString(e).toLowerCase()}function toUpper(e){return toString(e).toUpperCase()}function trim(e,t,r){if((e=toString(e))&&(r||t===o))return e.replace(Re,"");if(!e||!(t=baseToString(t)))return e;var n=stringToArray(e),i=stringToArray(t);return castSlice(n,charsStartIndex(n,i),charsEndIndex(n,i)+1).join("")}function trimEnd(e,t,r){if((e=toString(e))&&(r||t===o))return e.replace(Fe,"");if(!e||!(t=baseToString(t)))return e;var n=stringToArray(e);return castSlice(n,0,charsEndIndex(n,stringToArray(t))+1).join("")}function trimStart(e,t,r){if((e=toString(e))&&(r||t===o))return e.replace(Le,"");if(!e||!(t=baseToString(t)))return e;var n=stringToArray(e);return castSlice(n,charsStartIndex(n,stringToArray(t))).join("")}function truncate(e,t){var r=A,n=I;if(isObject(t)){var i="separator"in t?t.separator:i;r="length"in t?toInteger(t.length):r,n="omission"in t?baseToString(t.omission):n}e=toString(e);var a=e.length;if(hasUnicode(e)){var s=stringToArray(e);a=s.length}if(r>=a)return e;var u=r-stringSize(n);if(u<1)return n;var c=s?castSlice(s,0,u).join(""):e.slice(0,u);if(i===o)return c+n;if(s&&(u+=c.length-u),Gn(i)){if(e.slice(u).search(i)){var l,p=c;for(i.global||(i=Xe(i.source,toString(ze.exec(i))+"g")),i.lastIndex=0;l=i.exec(p);)var f=l.index;c=c.slice(0,f===o?u:f)}}else if(e.indexOf(baseToString(i),u)!=u){var d=c.lastIndexOf(i);d>-1&&(c=c.slice(0,d))}return c+n}function unescape(e){return e=toString(e),e&&Ee.test(e)?e.replace(Te,Ht):e}function words(e,t,r){return e=toString(e),t=r?o:t,t===o?hasUnicodeWord(e)?unicodeWords(e):asciiWords(e):e.match(t)||[]}function cond(e){var t=null==e?0:e.length,r=getIteratee();return e=t?arrayMap(e,function(e){if("function"!=typeof e[1])throw new tt(u);return[r(e[0]),e[1]]}):[],baseRest(function(r){for(var n=-1;++n<t;){var i=e[n];if(apply(i[0],this,r))return apply(i[1],this,r)}})}function conforms(e){return baseConforms(baseClone(e,f))}function constant(e){return function(){return e}}function defaultTo(e,t){return null==e||e!==e?t:e}function identity(e){return e}function iteratee(e){return baseIteratee("function"==typeof e?e:baseClone(e,f))}function matches(e){return baseMatches(baseClone(e,f))}function matchesProperty(e,t){return baseMatchesProperty(e,baseClone(t,f))}function mixin(e,t,r){var n=keys(t),i=baseFunctions(t,n);null!=r||isObject(t)&&(i.length||!n.length)||(r=t,t=e,e=this,i=baseFunctions(t,keys(t)));var o=!(isObject(r)&&"chain"in r&&!r.chain),a=isFunction(e);return arrayEach(i,function(r){var n=t[r];e[r]=n,a&&(e.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=e(this.__wrapped__);return(r.__actions__=copyArray(this.__actions__)).push({func:n,args:arguments,thisArg:e}),r.__chain__=t,r}return n.apply(e,arrayPush([this.value()],arguments))})}),e}function noConflict(){return Ct._===this&&(Ct._=ft),this}function noop(){}function nthArg(e){return e=toInteger(e),baseRest(function(t){return baseNth(t,e)})}function property(e){return isKey(e)?baseProperty(toKey(e)):basePropertyDeep(e)}function propertyOf(e){return function(t){return null==e?o:baseGet(e,t)}}function stubArray(){return[]}function stubFalse(){return!1}function stubObject(){return{}}function stubString(){return""}function stubTrue(){return!0}function times(e,t){if((e=toInteger(e))<1||e>R)return[];var r=N,n=nr(e,N);t=getIteratee(t),e-=N;for(var i=baseTimes(n,t);++r<e;)t(r);return i}function toPath(e){return In(e)?arrayMap(e,toKey):isSymbol(e)?[e]:copyArray(qr(toString(e)))}function uniqueId(e){var t=++ut;return toString(e)+t}function max(e){return e&&e.length?baseExtremum(e,identity,baseGt):o}function maxBy(e,t){return e&&e.length?baseExtremum(e,getIteratee(t,2),baseGt):o}function mean(e){return baseMean(e,identity)}function meanBy(e,t){return baseMean(e,getIteratee(t,2))}function min(e){return e&&e.length?baseExtremum(e,identity,baseLt):o}function minBy(e,t){return e&&e.length?baseExtremum(e,getIteratee(t,2),baseLt):o}function sum(e){return e&&e.length?baseSum(e,identity):0}function sumBy(e,t){return e&&e.length?baseSum(e,getIteratee(t,2)):0}e=null==e?Ct:Kt.defaults(Ct.Object(),e,Kt.pick(Ct,mt));var t=e.Array,r=e.Date,n=e.Error,i=e.Function,Be=e.Math,Ye=e.Object,Xe=e.RegExp,et=e.String,tt=e.TypeError,rt=t.prototype,nt=i.prototype,it=Ye.prototype,ot=e["__core-js_shared__"],at=nt.toString,st=it.hasOwnProperty,ut=0,ct=function(){var e=/[^.]+$/.exec(ot&&ot.keys&&ot.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),lt=it.toString,pt=at.call(Ye),ft=Ct._,dt=Xe("^"+at.call(st).replace(Ce,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),gt=Lt?e.Buffer:o,bt=e.Symbol,_t=e.Uint8Array,vt=gt?gt.allocUnsafe:o,Et=overArg(Ye.getPrototypeOf,Ye),Pt=Ye.create,Ot=it.propertyIsEnumerable,At=rt.splice,jt=bt?bt.isConcatSpreadable:o,xt=bt?bt.iterator:o,Gt=bt?bt.toStringTag:o,Rt=function(){try{var e=getNative(Ye,"defineProperty");return e({},"",{}),e}catch(e){}}(),Ft=e.clearTimeout!==Ct.clearTimeout&&e.clearTimeout,Nt=r&&r.now!==Ct.Date.now&&r.now,Ut=e.setTimeout!==Ct.setTimeout&&e.setTimeout,Jt=Be.ceil,$t=Be.floor,Zt=Ye.getOwnPropertySymbols,Yt=gt?gt.isBuffer:o,Xt=e.isFinite,er=rt.join,tr=overArg(Ye.keys,Ye),rr=Be.max,nr=Be.min,ir=r.now,or=e.parseInt,ar=Be.random,sr=rt.reverse,ur=getNative(e,"DataView"),cr=getNative(e,"Map"),lr=getNative(e,"Promise"),pr=getNative(e,"Set"),fr=getNative(e,"WeakMap"),dr=getNative(Ye,"create"),hr=fr&&new fr,yr={},gr=toSource(ur),br=toSource(cr),_r=toSource(lr),vr=toSource(pr),mr=toSource(fr),Sr=bt?bt.prototype:o,Tr=Sr?Sr.valueOf:o,wr=Sr?Sr.toString:o,Er=function(){function object(){}return function(e){if(!isObject(e))return{};if(Pt)return Pt(e);object.prototype=e;var t=new object;return object.prototype=o,t}}();lodash.templateSettings={escape:Oe,evaluate:Ae,interpolate:Ie,variable:"",imports:{_:lodash}},lodash.prototype=baseLodash.prototype,lodash.prototype.constructor=lodash,LodashWrapper.prototype=Er(baseLodash.prototype),LodashWrapper.prototype.constructor=LodashWrapper,LazyWrapper.prototype=Er(baseLodash.prototype),LazyWrapper.prototype.constructor=LazyWrapper,Hash.prototype.clear=hashClear,Hash.prototype["delete"]=hashDelete,Hash.prototype.get=hashGet,Hash.prototype.has=hashHas,Hash.prototype.set=hashSet,ListCache.prototype.clear=listCacheClear,ListCache.prototype["delete"]=listCacheDelete,ListCache.prototype.get=listCacheGet,ListCache.prototype.has=listCacheHas,ListCache.prototype.set=listCacheSet,MapCache.prototype.clear=mapCacheClear,MapCache.prototype["delete"]=mapCacheDelete,MapCache.prototype.get=mapCacheGet,MapCache.prototype.has=mapCacheHas,MapCache.prototype.set=mapCacheSet,SetCache.prototype.add=SetCache.prototype.push=setCacheAdd,SetCache.prototype.has=setCacheHas,Stack.prototype.clear=stackClear,Stack.prototype["delete"]=stackDelete,Stack.prototype.get=stackGet,Stack.prototype.has=stackHas,Stack.prototype.set=stackSet;var Pr=createBaseEach(baseForOwn),Or=createBaseEach(baseForOwnRight,!0),Ar=createBaseFor(),Ir=createBaseFor(!0),kr=hr?function(e,t){return hr.set(e,t),e}:identity,jr=Rt?function(e,t){return Rt(e,"toString",{configurable:!0,enumerable:!1,value:constant(t),writable:!0})}:identity,xr=baseRest,Cr=Ft||function(e){return Ct.clearTimeout(e)},Gr=pr&&1/setToArray(new pr([,-0]))[1]==G?function(e){return new pr(e)}:noop,Rr=hr?function(e){return hr.get(e)}:noop,Lr=Zt?function(e){return null==e?[]:(e=Ye(e),arrayFilter(Zt(e),function(t){return Ot.call(e,t)}))}:stubArray,Fr=Zt?function(e){for(var t=[];e;)arrayPush(t,Lr(e)),e=Et(e);return t}:stubArray,Nr=baseGetTag;(ur&&Nr(new ur(new ArrayBuffer(1)))!=ce||cr&&Nr(new cr)!=$||lr&&"[object Promise]"!=Nr(lr.resolve())||pr&&Nr(new pr)!=re||fr&&Nr(new fr)!=ae)&&(Nr=function(e){var t=baseGetTag(e),r=t==X?e.constructor:o,n=r?toSource(r):"";if(n)switch(n){case gr:return ce;case br:return $;case _r:return"[object Promise]";case vr:return re;case mr:return ae}return t});var Dr=ot?isFunction:stubFalse,Mr=shortOut(kr),Br=Ut||function(e,t){return Ct.setTimeout(e,t)},Wr=shortOut(jr),qr=function(e){var t=memoize(e,function(e){return r.size===l&&r.clear(),e}),r=t.cache;return t}(function(e){var t=[];return 46===e.charCodeAt(0)&&t.push(""),e.replace(xe,function(e,r,n,i){t.push(n?i.replace(We,"$1"):r||e)}),t}),zr=baseRest(function(e,t){return isArrayLikeObject(e)?baseDifference(e,baseFlatten(t,1,isArrayLikeObject,!0)):[]}),Ur=baseRest(function(e,t){var r=last(t);return isArrayLikeObject(r)&&(r=o),isArrayLikeObject(e)?baseDifference(e,baseFlatten(t,1,isArrayLikeObject,!0),getIteratee(r,2)):[]}),Qr=baseRest(function(e,t){var r=last(t);return isArrayLikeObject(r)&&(r=o),isArrayLikeObject(e)?baseDifference(e,baseFlatten(t,1,isArrayLikeObject,!0),o,r):[]}),Vr=baseRest(function(e){var t=arrayMap(e,castArrayLikeObject);return t.length&&t[0]===e[0]?baseIntersection(t):[]}),Hr=baseRest(function(e){var t=last(e),r=arrayMap(e,castArrayLikeObject);return t===last(r)?t=o:r.pop(),r.length&&r[0]===e[0]?baseIntersection(r,getIteratee(t,2)):[]}),Kr=baseRest(function(e){var t=last(e),r=arrayMap(e,castArrayLikeObject);return t="function"==typeof t?t:o,t&&r.pop(),r.length&&r[0]===e[0]?baseIntersection(r,o,t):[]}),Jr=baseRest(pullAll),$r=flatRest(function(e,t){var r=null==e?0:e.length,n=baseAt(e,t);return basePullAt(e,arrayMap(t,function(e){return isIndex(e,r)?+e:e}).sort(compareAscending)),n}),Zr=baseRest(function(e){return baseUniq(baseFlatten(e,1,isArrayLikeObject,!0))}),Yr=baseRest(function(e){var t=last(e);return isArrayLikeObject(t)&&(t=o),baseUniq(baseFlatten(e,1,isArrayLikeObject,!0),getIteratee(t,2))}),Xr=baseRest(function(e){var t=last(e);return t="function"==typeof t?t:o,baseUniq(baseFlatten(e,1,isArrayLikeObject,!0),o,t)}),en=baseRest(function(e,t){return isArrayLikeObject(e)?baseDifference(e,t):[]}),tn=baseRest(function(e){return baseXor(arrayFilter(e,isArrayLikeObject))}),rn=baseRest(function(e){var t=last(e);return isArrayLikeObject(t)&&(t=o),baseXor(arrayFilter(e,isArrayLikeObject),getIteratee(t,2))}),nn=baseRest(function(e){var t=last(e);return t="function"==typeof t?t:o,baseXor(arrayFilter(e,isArrayLikeObject),o,t)}),on=baseRest(unzip),an=baseRest(function(e){var t=e.length,r=t>1?e[t-1]:o;return r="function"==typeof r?(e.pop(),r):o,unzipWith(e,r)}),sn=flatRest(function(e){var t=e.length,r=t?e[0]:0,n=this.__wrapped__,i=function(t){return baseAt(t,e)};return!(t>1||this.__actions__.length)&&n instanceof LazyWrapper&&isIndex(r)?(n=n.slice(r,+r+(t?1:0)),n.__actions__.push({func:thru,args:[i],thisArg:o}),new LodashWrapper(n,this.__chain__).thru(function(e){return t&&!e.length&&e.push(o),e})):this.thru(i)}),un=createAggregator(function(e,t,r){st.call(e,r)?++e[r]:baseAssignValue(e,r,1)}),cn=createFind(findIndex),ln=createFind(findLastIndex),pn=createAggregator(function(e,t,r){st.call(e,r)?e[r].push(t):baseAssignValue(e,r,[t])}),fn=baseRest(function(e,r,n){var i=-1,o="function"==typeof r,a=isArrayLike(e)?t(e.length):[];return Pr(e,function(e){a[++i]=o?apply(r,e,n):baseInvoke(e,r,n)}),a}),dn=createAggregator(function(e,t,r){baseAssignValue(e,r,t)}),hn=createAggregator(function(e,t,r){e[r?0:1].push(t)},function(){return[[],[]]}),yn=baseRest(function(e,t){if(null==e)return[];var r=t.length;return r>1&&isIterateeCall(e,t[0],t[1])?t=[]:r>2&&isIterateeCall(t[0],t[1],t[2])&&(t=[t[0]]),baseOrderBy(e,baseFlatten(t,1),[])}),gn=Nt||function(){return Ct.Date.now()},bn=baseRest(function(e,t,r){var n=b;if(r.length){var i=replaceHolders(r,getHolder(bn));n|=T}return createWrap(e,n,t,r,i)}),_n=baseRest(function(e,t,r){var n=b|_;if(r.length){var i=replaceHolders(r,getHolder(_n));n|=T}return createWrap(t,n,e,r,i)}),vn=baseRest(function(e,t){return baseDelay(e,1,t)}),mn=baseRest(function(e,t,r){return baseDelay(e,toNumber(t)||0,r)});memoize.Cache=MapCache;var Sn=xr(function(e,t){t=1==t.length&&In(t[0])?arrayMap(t[0],baseUnary(getIteratee())):arrayMap(baseFlatten(t,1),baseUnary(getIteratee()));var r=t.length;return baseRest(function(n){for(var i=-1,o=nr(n.length,r);++i<o;)n[i]=t[i].call(this,n[i]);return apply(e,this,n)})}),Tn=baseRest(function(e,t){var r=replaceHolders(t,getHolder(Tn));return createWrap(e,T,o,t,r)}),wn=baseRest(function(e,t){var r=replaceHolders(t,getHolder(wn));return createWrap(e,w,o,t,r)}),En=flatRest(function(e,t){return createWrap(e,P,o,o,o,t)}),Pn=createRelationalOperation(baseGt),On=createRelationalOperation(function(e,t){return e>=t}),An=baseIsArguments(function(){return arguments}())?baseIsArguments:function(e){return isObjectLike(e)&&st.call(e,"callee")&&!Ot.call(e,"callee")},In=t.isArray,kn=Dt?baseUnary(Dt):baseIsArrayBuffer,jn=Yt||stubFalse,xn=Mt?baseUnary(Mt):baseIsDate,Cn=Bt?baseUnary(Bt):baseIsMap,Gn=Wt?baseUnary(Wt):baseIsRegExp,Rn=qt?baseUnary(qt):baseIsSet,Ln=zt?baseUnary(zt):baseIsTypedArray,Fn=createRelationalOperation(baseLt),Nn=createRelationalOperation(function(e,t){return e<=t}),Dn=createAssigner(function(e,t){if(isPrototype(t)||isArrayLike(t))return void copyObject(t,keys(t),e);for(var r in t)st.call(t,r)&&assignValue(e,r,t[r])}),Mn=createAssigner(function(e,t){copyObject(t,keysIn(t),e)}),Bn=createAssigner(function(e,t,r,n){copyObject(t,keysIn(t),e,n)}),Wn=createAssigner(function(e,t,r,n){copyObject(t,keys(t),e,n)}),qn=flatRest(baseAt),zn=baseRest(function(e,t){e=Ye(e);var r=-1,n=t.length,i=n>2?t[2]:o;for(i&&isIterateeCall(t[0],t[1],i)&&(n=1);++r<n;)for(var a=t[r],s=keysIn(a),u=-1,c=s.length;++u<c;){var l=s[u],p=e[l];(p===o||eq(p,it[l])&&!st.call(e,l))&&(e[l]=a[l])}return e}),Un=baseRest(function(e){return e.push(o,customDefaultsMerge),apply(Jn,o,e)}),Qn=createInverter(function(e,t,r){null!=t&&"function"!=typeof t.toString&&(t=lt.call(t)),e[t]=r},constant(identity)),Vn=createInverter(function(e,t,r){null!=t&&"function"!=typeof t.toString&&(t=lt.call(t)),st.call(e,t)?e[t].push(r):e[t]=[r]},getIteratee),Hn=baseRest(baseInvoke),Kn=createAssigner(function(e,t,r){baseMerge(e,t,r)}),Jn=createAssigner(function(e,t,r,n){baseMerge(e,t,r,n)}),$n=flatRest(function(e,t){var r={};if(null==e)return r;var n=!1;t=arrayMap(t,function(t){return t=castPath(t,e),n||(n=t.length>1),t}),copyObject(e,getAllKeysIn(e),r),n&&(r=baseClone(r,f|d|h,customOmitClone));for(var i=t.length;i--;)baseUnset(r,t[i]);return r}),Zn=flatRest(function(e,t){return null==e?{}:basePick(e,t)}),Yn=createToPairs(keys),Xn=createToPairs(keysIn),ei=createCompounder(function(e,t,r){return t=t.toLowerCase(),e+(r?capitalize(t):t)}),ti=createCompounder(function(e,t,r){return e+(r?"-":"")+t.toLowerCase()}),ri=createCompounder(function(e,t,r){return e+(r?" ":"")+t.toLowerCase()}),ni=createCaseFirst("toLowerCase"),ii=createCompounder(function(e,t,r){return e+(r?"_":"")+t.toLowerCase()}),oi=createCompounder(function(e,t,r){return e+(r?" ":"")+si(t)}),ai=createCompounder(function(e,t,r){return e+(r?" ":"")+t.toUpperCase()}),si=createCaseFirst("toUpperCase"),ui=baseRest(function(e,t){try{return apply(e,o,t)}catch(e){return isError(e)?e:new n(e)}}),ci=flatRest(function(e,t){return arrayEach(t,function(t){t=toKey(t),baseAssignValue(e,t,bn(e[t],e))}),e}),li=createFlow(),pi=createFlow(!0),fi=baseRest(function(e,t){return function(r){return baseInvoke(r,e,t)}}),di=baseRest(function(e,t){return function(r){return baseInvoke(e,r,t)}}),hi=createOver(arrayMap),yi=createOver(arrayEvery),gi=createOver(arraySome),bi=createRange(),_i=createRange(!0),vi=createMathOperation(function(e,t){return e+t},0),mi=createRound("ceil"),Si=createMathOperation(function(e,t){return e/t},1),Ti=createRound("floor"),wi=createMathOperation(function(e,t){return e*t},1),Ei=createRound("round"),Pi=createMathOperation(function(e,t){return e-t},0);return lodash.after=after,lodash.ary=ary,lodash.assign=Dn,lodash.assignIn=Mn,lodash.assignInWith=Bn,lodash.assignWith=Wn,lodash.at=qn,lodash.before=before,lodash.bind=bn,lodash.bindAll=ci,lodash.bindKey=_n,lodash.castArray=castArray,lodash.chain=chain,lodash.chunk=chunk,lodash.compact=compact,lodash.concat=concat,lodash.cond=cond,lodash.conforms=conforms,lodash.constant=constant,lodash.countBy=un,lodash.create=create,lodash.curry=curry,lodash.curryRight=curryRight,lodash.debounce=debounce,lodash.defaults=zn,lodash.defaultsDeep=Un,lodash.defer=vn,lodash.delay=mn,lodash.difference=zr,lodash.differenceBy=Ur,lodash.differenceWith=Qr,lodash.drop=drop,lodash.dropRight=dropRight,lodash.dropRightWhile=dropRightWhile,lodash.dropWhile=dropWhile,lodash.fill=fill,lodash.filter=filter,lodash.flatMap=flatMap,lodash.flatMapDeep=flatMapDeep,lodash.flatMapDepth=flatMapDepth,lodash.flatten=flatten,lodash.flattenDeep=flattenDeep,lodash.flattenDepth=flattenDepth,lodash.flip=flip,lodash.flow=li,lodash.flowRight=pi,lodash.fromPairs=fromPairs,lodash.functions=functions,lodash.functionsIn=functionsIn,lodash.groupBy=pn,lodash.initial=initial,lodash.intersection=Vr,lodash.intersectionBy=Hr,lodash.intersectionWith=Kr,lodash.invert=Qn,lodash.invertBy=Vn,lodash.invokeMap=fn,lodash.iteratee=iteratee,lodash.keyBy=dn,lodash.keys=keys,lodash.keysIn=keysIn,lodash.map=map,lodash.mapKeys=mapKeys,lodash.mapValues=mapValues,lodash.matches=matches,lodash.matchesProperty=matchesProperty,lodash.memoize=memoize,lodash.merge=Kn,lodash.mergeWith=Jn,lodash.method=fi,lodash.methodOf=di,lodash.mixin=mixin,lodash.negate=negate,lodash.nthArg=nthArg,lodash.omit=$n,lodash.omitBy=omitBy,lodash.once=once,lodash.orderBy=orderBy,lodash.over=hi,lodash.overArgs=Sn,lodash.overEvery=yi,lodash.overSome=gi,lodash.partial=Tn,lodash.partialRight=wn,lodash.partition=hn,lodash.pick=Zn,lodash.pickBy=pickBy,lodash.property=property,lodash.propertyOf=propertyOf,lodash.pull=Jr,lodash.pullAll=pullAll,lodash.pullAllBy=pullAllBy,lodash.pullAllWith=pullAllWith,lodash.pullAt=$r,lodash.range=bi,lodash.rangeRight=_i,lodash.rearg=En,lodash.reject=reject,lodash.remove=remove,lodash.rest=rest,lodash.reverse=reverse,lodash.sampleSize=sampleSize,lodash.set=set,lodash.setWith=setWith,lodash.shuffle=shuffle,lodash.slice=slice,lodash.sortBy=yn,lodash.sortedUniq=sortedUniq,lodash.sortedUniqBy=sortedUniqBy,lodash.split=split,lodash.spread=spread,lodash.tail=tail,lodash.take=take,lodash.takeRight=takeRight,lodash.takeRightWhile=takeRightWhile,lodash.takeWhile=takeWhile,lodash.tap=tap,lodash.throttle=throttle,lodash.thru=thru,lodash.toArray=toArray,lodash.toPairs=Yn,lodash.toPairsIn=Xn,lodash.toPath=toPath,lodash.toPlainObject=toPlainObject,lodash.transform=transform,lodash.unary=unary,lodash.union=Zr,lodash.unionBy=Yr,lodash.unionWith=Xr,lodash.uniq=uniq,lodash.uniqBy=uniqBy,lodash.uniqWith=uniqWith,lodash.unset=unset,lodash.unzip=unzip,lodash.unzipWith=unzipWith,lodash.update=update,lodash.updateWith=updateWith,lodash.values=values,lodash.valuesIn=valuesIn,lodash.without=en,lodash.words=words,lodash.wrap=wrap,lodash.xor=tn,lodash.xorBy=rn,lodash.xorWith=nn,lodash.zip=on,lodash.zipObject=zipObject,lodash.zipObjectDeep=zipObjectDeep,lodash.zipWith=an,lodash.entries=Yn,lodash.entriesIn=Xn,lodash.extend=Mn,lodash.extendWith=Bn,mixin(lodash,lodash),lodash.add=vi,lodash.attempt=ui,lodash.camelCase=ei,lodash.capitalize=capitalize,lodash.ceil=mi,lodash.clamp=clamp,lodash.clone=clone,lodash.cloneDeep=cloneDeep,lodash.cloneDeepWith=cloneDeepWith,lodash.cloneWith=cloneWith,lodash.conformsTo=conformsTo,lodash.deburr=deburr,lodash.defaultTo=defaultTo,lodash.divide=Si,lodash.endsWith=endsWith,lodash.eq=eq,lodash.escape=escape,lodash.escapeRegExp=escapeRegExp,lodash.every=every,lodash.find=cn,lodash.findIndex=findIndex,lodash.findKey=findKey,lodash.findLast=ln,lodash.findLastIndex=findLastIndex,lodash.findLastKey=findLastKey,lodash.floor=Ti,lodash.forEach=forEach,lodash.forEachRight=forEachRight,lodash.forIn=forIn,lodash.forInRight=forInRight,lodash.forOwn=forOwn,lodash.forOwnRight=forOwnRight,lodash.get=get,lodash.gt=Pn,lodash.gte=On,lodash.has=has,lodash.hasIn=hasIn,lodash.head=head,lodash.identity=identity,lodash.includes=includes,lodash.indexOf=indexOf,lodash.inRange=inRange,lodash.invoke=Hn,lodash.isArguments=An,lodash.isArray=In,lodash.isArrayBuffer=kn,lodash.isArrayLike=isArrayLike,lodash.isArrayLikeObject=isArrayLikeObject,lodash.isBoolean=isBoolean,lodash.isBuffer=jn,lodash.isDate=xn,lodash.isElement=isElement,lodash.isEmpty=isEmpty,lodash.isEqual=isEqual,lodash.isEqualWith=isEqualWith,lodash.isError=isError,lodash.isFinite=isFinite,lodash.isFunction=isFunction,lodash.isInteger=isInteger,lodash.isLength=isLength,lodash.isMap=Cn,lodash.isMatch=isMatch,lodash.isMatchWith=isMatchWith,lodash.isNaN=isNaN,lodash.isNative=isNative,lodash.isNil=isNil,lodash.isNull=isNull,lodash.isNumber=isNumber,lodash.isObject=isObject,lodash.isObjectLike=isObjectLike,lodash.isPlainObject=isPlainObject,lodash.isRegExp=Gn,lodash.isSafeInteger=isSafeInteger,lodash.isSet=Rn,lodash.isString=isString,lodash.isSymbol=isSymbol,lodash.isTypedArray=Ln,lodash.isUndefined=isUndefined,lodash.isWeakMap=isWeakMap,lodash.isWeakSet=isWeakSet,lodash.join=join,lodash.kebabCase=ti,lodash.last=last,lodash.lastIndexOf=lastIndexOf,lodash.lowerCase=ri,lodash.lowerFirst=ni,lodash.lt=Fn,lodash.lte=Nn,lodash.max=max,lodash.maxBy=maxBy,lodash.mean=mean,lodash.meanBy=meanBy,lodash.min=min,lodash.minBy=minBy,lodash.stubArray=stubArray,lodash.stubFalse=stubFalse,lodash.stubObject=stubObject,lodash.stubString=stubString,lodash.stubTrue=stubTrue,lodash.multiply=wi,lodash.nth=nth,lodash.noConflict=noConflict,lodash.noop=noop,lodash.now=gn,lodash.pad=pad,lodash.padEnd=padEnd,lodash.padStart=padStart,lodash.parseInt=parseInt,lodash.random=random,lodash.reduce=reduce,lodash.reduceRight=reduceRight,lodash.repeat=repeat,lodash.replace=replace,lodash.result=result,lodash.round=Ei,lodash.runInContext=runInContext,lodash.sample=sample,lodash.size=size,lodash.snakeCase=ii,lodash.some=some,lodash.sortedIndex=sortedIndex,lodash.sortedIndexBy=sortedIndexBy,lodash.sortedIndexOf=sortedIndexOf,lodash.sortedLastIndex=sortedLastIndex,lodash.sortedLastIndexBy=sortedLastIndexBy,lodash.sortedLastIndexOf=sortedLastIndexOf,lodash.startCase=oi,lodash.startsWith=startsWith,lodash.subtract=Pi,lodash.sum=sum,lodash.sumBy=sumBy,lodash.template=template,lodash.times=times,lodash.toFinite=toFinite,lodash.toInteger=toInteger,lodash.toLength=toLength,lodash.toLower=toLower,lodash.toNumber=toNumber,lodash.toSafeInteger=toSafeInteger,lodash.toString=toString,lodash.toUpper=toUpper,lodash.trim=trim,lodash.trimEnd=trimEnd,lodash.trimStart=trimStart,lodash.truncate=truncate,lodash.unescape=unescape,lodash.uniqueId=uniqueId,lodash.upperCase=ai,lodash.upperFirst=si,lodash.each=forEach,lodash.eachRight=forEachRight,lodash.first=head,mixin(lodash,function(){var e={};return baseForOwn(lodash,function(t,r){st.call(lodash.prototype,r)||(e[r]=t)}),e}(),{chain:!1}),lodash.VERSION="4.17.15",arrayEach(["bind","bindKey","curry","curryRight","partial","partialRight"],function(e){lodash[e].placeholder=lodash}),arrayEach(["drop","take"],function(e,t){LazyWrapper.prototype[e]=function(r){r=r===o?1:rr(toInteger(r),0);var n=this.__filtered__&&!t?new LazyWrapper(this):this.clone();return n.__filtered__?n.__takeCount__=nr(r,n.__takeCount__):n.__views__.push({size:nr(r,N),type:e+(n.__dir__<0?"Right":"")}),n},LazyWrapper.prototype[e+"Right"]=function(t){return this.reverse()[e](t).reverse()}}),arrayEach(["filter","map","takeWhile"],function(e,t){var r=t+1,n=r==x||3==r;LazyWrapper.prototype[e]=function(e){var t=this.clone();return t.__iteratees__.push({iteratee:getIteratee(e,3),type:r}),t.__filtered__=t.__filtered__||n,t}}),arrayEach(["head","last"],function(e,t){var r="take"+(t?"Right":"");LazyWrapper.prototype[e]=function(){return this[r](1).value()[0]}}),arrayEach(["initial","tail"],function(e,t){var r="drop"+(t?"":"Right");LazyWrapper.prototype[e]=function(){return this.__filtered__?new LazyWrapper(this):this[r](1)}}),LazyWrapper.prototype.compact=function(){return this.filter(identity)},LazyWrapper.prototype.find=function(e){return this.filter(e).head()},LazyWrapper.prototype.findLast=function(e){return this.reverse().find(e)},LazyWrapper.prototype.invokeMap=baseRest(function(e,t){return"function"==typeof e?new LazyWrapper(this):this.map(function(r){return baseInvoke(r,e,t)})}),LazyWrapper.prototype.reject=function(e){return this.filter(negate(getIteratee(e)))},LazyWrapper.prototype.slice=function(e,t){e=toInteger(e);var r=this;return r.__filtered__&&(e>0||t<0)?new LazyWrapper(r):(e<0?r=r.takeRight(-e):e&&(r=r.drop(e)),t!==o&&(t=toInteger(t),r=t<0?r.dropRight(-t):r.take(t-e)),r)},LazyWrapper.prototype.takeRightWhile=function(e){return this.reverse().takeWhile(e).reverse()},LazyWrapper.prototype.toArray=function(){return this.take(N)},baseForOwn(LazyWrapper.prototype,function(e,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),n=/^(?:head|last)$/.test(t),i=lodash[n?"take"+("last"==t?"Right":""):t],a=n||/^find/.test(t);i&&(lodash.prototype[t]=function(){var t=this.__wrapped__,s=n?[1]:arguments,u=t instanceof LazyWrapper,c=s[0],l=u||In(t),p=function(e){var t=i.apply(lodash,arrayPush([e],s));return n&&f?t[0]:t};l&&r&&"function"==typeof c&&1!=c.length&&(u=l=!1);var f=this.__chain__,d=!!this.__actions__.length,h=a&&!f,y=u&&!d;if(!a&&l){t=y?t:new LazyWrapper(this);var g=e.apply(t,s);return g.__actions__.push({func:thru,args:[p],thisArg:o}),new LodashWrapper(g,f)}return h&&y?e.apply(this,s):(g=this.thru(p),h?n?g.value()[0]:g.value():g)})}),arrayEach(["pop","push","shift","sort","splice","unshift"],function(e){var t=rt[e],r=/^(?:push|sort|unshift)$/.test(e)?"tap":"thru",n=/^(?:pop|shift)$/.test(e);lodash.prototype[e]=function(){var e=arguments;if(n&&!this.__chain__){var i=this.value();return t.apply(In(i)?i:[],e)}return this[r](function(r){return t.apply(In(r)?r:[],e)})}}),baseForOwn(LazyWrapper.prototype,function(e,t){var r=lodash[t];if(r){var n=r.name+"";st.call(yr,n)||(yr[n]=[]),yr[n].push({name:t,func:r})}}),yr[createHybrid(o,_).name]=[{name:"wrapper",func:o}],LazyWrapper.prototype.clone=lazyClone,LazyWrapper.prototype.reverse=lazyReverse,LazyWrapper.prototype.value=lazyValue,lodash.prototype.at=sn,lodash.prototype.chain=wrapperChain,lodash.prototype.commit=wrapperCommit,lodash.prototype.next=wrapperNext,lodash.prototype.plant=wrapperPlant,lodash.prototype.reverse=wrapperReverse,lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue,lodash.prototype.first=lodash.prototype.head,xt&&(lodash.prototype[xt]=wrapperToIterator),lodash}();Ct._=Kt,(i=function(){return Kt}.call(t,r,t,n))!==o&&(n.exports=i)}).call(this)}).call(t,r(16),r(33)(e))},function(e,t,r){"use strict";function isArray(e){return"[object Array]"===o.call(e)}function isArrayBuffer(e){return"[object ArrayBuffer]"===o.call(e)}function isFormData(e){return"undefined"!=typeof FormData&&e instanceof FormData}function isArrayBufferView(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&e.buffer instanceof ArrayBuffer}function isString(e){return"string"==typeof e}function isNumber(e){return"number"==typeof e}function isUndefined(e){return void 0===e}function isObject(e){return null!==e&&"object"==typeof e}function isDate(e){return"[object Date]"===o.call(e)}function isFile(e){return"[object File]"===o.call(e)}function isBlob(e){return"[object Blob]"===o.call(e)}function isFunction(e){return"[object Function]"===o.call(e)}function isStream(e){return isObject(e)&&isFunction(e.pipe)}function isURLSearchParams(e){return"undefined"!=typeof URLSearchParams&&e instanceof URLSearchParams}function trim(e){return e.replace(/^\s*/,"").replace(/\s*$/,"")}function isStandardBrowserEnv(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)}function forEach(e,t){if(null!==e&&void 0!==e)if("object"==typeof e||isArray(e)||(e=[e]),isArray(e))for(var r=0,n=e.length;r<n;r++)t.call(null,e[r],r,e);else for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.call(null,e[i],i,e)}function merge(){function assignValue(t,r){"object"==typeof e[r]&&"object"==typeof t?e[r]=merge(e[r],t):e[r]=t}for(var e={},t=0,r=arguments.length;t<r;t++)forEach(arguments[t],assignValue);return e}function extend(e,t,r){return forEach(t,function(t,i){e[i]=r&&"function"==typeof t?n(t,r):t}),e}var n=r(24),i=r(54),o=Object.prototype.toString;e.exports={isArray:isArray,isArrayBuffer:isArrayBuffer,isBuffer:i,isFormData:isFormData,isArrayBufferView:isArrayBufferView,isString:isString,isNumber:isNumber,isObject:isObject,isUndefined:isUndefined,isDate:isDate,isFile:isFile,isBlob:isBlob,isFunction:isFunction,isStream:isStream,isURLSearchParams:isURLSearchParams,isStandardBrowserEnv:isStandardBrowserEnv,forEach:forEach,merge:merge,extend:extend,trim:trim}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function GssType(e){this._name=e,Object.freeze(this)}return GssType.valueOf=function(e){if(!e)throw new Error("expected required parameter name");var t=d.get(e);if(!t)throw new Error("invalid name ".concat(e));return t},Object.defineProperty(GssType.prototype,"name",{get:function(){return this._name},enumerable:!1,configurable:!0}),Object.defineProperty(GssType,"Bool",{get:function(){return i},enumerable:!1,configurable:!0}),Object.defineProperty(GssType,"Int",{get:function(){return o},enumerable:!1,configurable:!0}),Object.defineProperty(GssType,"Long",{get:function(){return a},enumerable:!1,configurable:!0}),Object.defineProperty(GssType,"Double",{get:function(){return s},enumerable:!1,configurable:!0}),Object.defineProperty(GssType,"DateTime",{get:function(){return u},enumerable:!1,configurable:!0}),Object.defineProperty(GssType,"String",{get:function(){return c},enumerable:!1,configurable:!0}),Object.defineProperty(GssType,"Composite",{get:function(){return l},enumerable:!1,configurable:!0}),Object.defineProperty(GssType,"Members",{get:function(){return p},enumerable:!1,configurable:!0}),GssType}();t["default"]=n;var i=new n("Bool"),o=new n("Int"),a=new n("Long"),s=new n("Double"),u=new n("DateTime"),c=new n("String"),l=new n("Composite"),p=[i,o,a,s,u,c,l],f=p.map(function(e){return[e.name,e]}),d=new Map(f)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function GssSearchType(e){this._name=e,Object.freeze(this)}return GssSearchType.valueOf=function(e){if(!e)throw new Error("Expected required parameter name");var t=l.get(e);if(!t)throw new Error("invalid name ".concat(e));return t},Object.defineProperty(GssSearchType.prototype,"name",{get:function(){return this._name},enumerable:!1,configurable:!0}),Object.defineProperty(GssSearchType,"None",{get:function(){return i},enumerable:!1,configurable:!0}),Object.defineProperty(GssSearchType,"Exact",{get:function(){return o},enumerable:!1,configurable:!0}),Object.defineProperty(GssSearchType,"Partial",{get:function(){return a},enumerable:!1,configurable:!0}),Object.defineProperty(GssSearchType,"Both",{get:function(){return s},enumerable:!1,configurable:!0}),Object.defineProperty(GssSearchType,"Members",{get:function(){return u},enumerable:!1,configurable:!0}),GssSearchType}();t["default"]=n;var i=new n("None"),o=new n("Exact"),a=new n("Partial"),s=new n("Both"),u=[i,o,a,s],c=u.map(function(e){return[e.name,e]}),l=new Map(c)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(6),i=r(1),o=function(){function GssEntityType(e,t){if(!e)throw new Error("Expected required parameter name");if(!(t&&t instanceof n["default"]))throw new Error("Expected required parameter propertyDescriptors");this._name=e,this._properties=t,Object.freeze(this)}return GssEntityType.fromJS=function(e){if(e instanceof GssEntityType)return e;if(!i.isObjectLike(e))throw new TypeError("Cannot convert argument of type ${typeof entityType} to GssEntityType");var t=e.properties;return new GssEntityType(e.name,n["default"].fromJS(t))},Object.defineProperty(GssEntityType.prototype,"name",{get:function(){return this._name},enumerable:!1,configurable:!0}),Object.defineProperty(GssEntityType.prototype,"properties",{get:function(){return this._properties},enumerable:!1,configurable:!0}),GssEntityType.prototype.sameAs=function(e){return this._name===e._name&&this._haveSameFields(this._properties,e._properties)},GssEntityType.prototype._haveSameFields=function(e,t){return null==e?null==t:e.sameAs(t)},GssEntityType}();t["default"]=o},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o["return"])&&r.call(o)}finally{if(i)throw i.error}}return a},i=this&&this.__spreadArray||function(e,t,r){if(r||2===arguments.length)for(var n,i=0,o=t.length;i<o;i++)!n&&i in t||(n||(n=Array.prototype.slice.call(t,0,i)),n[i]=t[i]);return e.concat(n||Array.prototype.slice.call(t))};Object.defineProperty(t,"__esModule",{value:!0});var o=r(10),a=r(0),s=r(1),u=function(){function GssFields(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=this;if(e===undefined||!e||!Array.isArray(e)||0===e.length)throw new Error("expected 1 or more property descriptors");this._fields=new Map,e.forEach(function(e){if(!(e&&e instanceof o["default"]))throw new Error("expected GssPropertyDescriptor got ".concat(e));var t=e.name;if(r._fields.get(t))throw new Error("Property descriptor ".concat(t," already exists with type ").concat(e.type));r._fields.set(t,e)}),Object.freeze(this)}return GssFields.fromJS=function(e){if(e instanceof GssFields)return e;if(!s.isArray(e))throw new TypeError("Cannot convert fields of type ".concat(typeof e," to GssFields"));return new(GssFields.bind.apply(GssFields,i([void 0],n(e.map(function(e){return o["default"].fromJS(e)})),!1)))},GssFields.prototype.keys=function(){return(0,a.spread)(this._fields.keys())},GssFields.prototype.values=function(){return(0,a.spread)(this._fields.values())},GssFields.prototype.entries=function(){return(0,a.spread)(this._fields.entries())},GssFields.prototype.get=function(e){return this._fields.get(e)},GssFields.prototype.deepGet=function(e){var t=e.toString().split(".");if(t=t.filter(function(e){return e.length>0}),t.length<=1)return this.get(e);var r,n=this._fields,i=!1;return t.forEach(function(e){if(!n.get(e)||i)return r=undefined,void(i=!0);r=n.get(e),n.get(e).properties&&(n=n.get(e).properties._fields)}),r},GssFields.prototype.has=function(e){return this._fields.has(e)},GssFields.prototype.forEach=function(e){return this._fields.forEach(e)},Object.defineProperty(GssFields.prototype,"size",{get:function(){return this._fields.size},enumerable:!1,configurable:!0}),GssFields.prototype.sameAs=function(e){var t=this;return null!=e&&(this.size===e.size&&s.every(this.keys(),function(r){return t.get(r).sameAs(e.get(r))}))},GssFields}();t["default"]=u},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),i=function(){function ConsoleLogger(e,t){this.name=e,t=t||{debug:!1,trace:!1},this._prefix=e?"["+String(e)+"] ":"",this._debug=Boolean(t.debug),this._trace=Boolean(t.trace)}return ConsoleLogger.prototype.trace=function(e){this._trace&&console.log(this._prefix+"(TRACE) "+(0,n.evalValue)(e))},ConsoleLogger.prototype.debug=function(e){this._debug&&console.log(this._prefix+"(DEBUG) "+(0,n.evalValue)(e))},ConsoleLogger.prototype.log=function(e){console.log(this._prefix+(0,n.evalValue)(e))},ConsoleLogger.prototype.info=function(e){console.info(this._prefix+(0,n.evalValue)(e))},ConsoleLogger.prototype.warn=function(e){console.warn(this._prefix+(0,n.evalValue)(e))},ConsoleLogger.prototype.error=function(e){e=(0,n.evalValue)(e),e instanceof Error&&(e=e.message+" @ "+e.stack),console.error(this._prefix+e)},ConsoleLogger.prototype.subLogger=function(e){var t="__"+e+"__",r=this[t];if(!r){r=new ConsoleLogger(e&&this._name?this._name+"."+e:e,{debug:this._debug,trace:this._trace}),this[t]=r}return r},ConsoleLogger}();t["default"]=i},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(1),i=r(4),o=[n.isString,n.isNumber,n.isDate,n.isBoolean],a=function(){function GssFieldFilter(e,t,r){if(!e)throw new TypeError("Expected mandatory parameter name");if(!n.some(o,function(e){return e(t)}))throw new TypeError("Expected mandatory parameter value must be a scalar");n.isString(r)&&(r=i["default"].valueOf(r)),this._name=e,this._value=t,this._searchType=r}return Object.defineProperty(GssFieldFilter.prototype,"name",{get:function(){return this._name},enumerable:!1,configurable:!0}),Object.defineProperty(GssFieldFilter.prototype,"value",{get:function(){return this._value},enumerable:!1,configurable:!0}),Object.defineProperty(GssFieldFilter.prototype,"searchType",{get:function(){return this._searchType},enumerable:!1,configurable:!0}),Object.defineProperty(GssFieldFilter,"fullTextSearchFieldName",{get:function(){return"ANY"},enumerable:!1,configurable:!0}),GssFieldFilter}();t["default"]=a},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),i=function(){function Promised(e){var t=this;this._fulfilled=arguments.length>0,this._error=null,this._result=this._fulfilled?(0,n.evalValue)(e):undefined,this._resolve=undefined,this._reject=undefined,this._promise=new Promise(function(e,r){t._resolve=e,t._reject=r}),this._fulfilled&&this.resolve(this._result)}return Promised.resolved=function(e,t){return new Promised(e).subscribe(t)},Promised.delayedResolved=function(e,t,r){var n=new Promised;return setTimeout(function(){return n.resolve(e)},t),n.subscribe(r)},Promised.rejected=function(e,t){var r=new Promised;return r.reject(e),r.subscribe(t)},Promised.prototype.subscribe=function(e){return(0,n.nodeify)(this._promise,e)},Object.defineProperty(Promised.prototype,"promise",{get:function(){return this._promise},enumerable:!1,configurable:!0}),Object.defineProperty(Promised.prototype,"fulfilled",{get:function(){return this._fulfilled},enumerable:!1,configurable:!0}),Object.defineProperty(Promised.prototype,"error",{get:function(){return this._error},enumerable:!1,configurable:!0}),Object.defineProperty(Promised.prototype,"result",{get:function(){return this._result},enumerable:!1,configurable:!0}),Promised.prototype.resolve=function(e){this._fulfill(null,e)},Promised.prototype.reject=function(e){this._fulfill(e,null)},Promised.prototype._fulfill=function(e,t){this._fulfilled=!0,this._error=e,this._result=(0,n.evalValue)(t),this._error?this._reject(this._error):this._resolve(this._result)},Promised}();t["default"]=i},function(e,t,r){"use strict";function stringifyValues(e){return e&&0!==e.length?Object.getOwnPropertyNames(e).reduce(function(t,r){var n=e[r];return n!==undefined&&null!==n&&(t[r]=String(n)),t},{}):undefined}Object.defineProperty(t,"__esModule",{value:!0});var n=r(3),i=r(4),o=r(1),a=r(6),s=function(){function GssField(e,t,r,o,s,u,c,l){if(!e)throw new Error("Expected required parameter name");if(!t)throw new Error("Expected required parameter type");"string"==typeof t&&(t=n["default"].valueOf(t)),"string"==typeof o&&(o=i["default"].valueOf(o)),t===n["default"].Composite&&o&&o!==i["default"].None&&(o=i["default"].None),this._name=e,this._type=t,this._isArray=r,this._searchType=o||i["default"].None,this._displayName=s,this._description=u,this._metaData=stringifyValues(c)||{},l&&(this._properties=a["default"].fromJS(l)),Object.freeze(this)}return GssField.fromJS=function(e){if(e instanceof GssField)return e;if(!o.isObjectLike(e))throw new TypeError("Cannot convert argument of type ".concat(typeof e," to GssField"));var t=e.properties?a["default"].fromJS(e.properties):undefined;return new GssField(e.name,e.type,e.isArray,e.searchType,e.displayName,e.description,e.metaData,t)},Object.defineProperty(GssField.prototype,"name",{get:function(){return this._name},enumerable:!1,configurable:!0}),Object.defineProperty(GssField.prototype,"displayName",{get:function(){return this._displayName},enumerable:!1,configurable:!0}),Object.defineProperty(GssField.prototype,"description",{get:function(){return this._description},enumerable:!1,configurable:!0}),Object.defineProperty(GssField.prototype,"type",{get:function(){return this._type},enumerable:!1,configurable:!0}),Object.defineProperty(GssField.prototype,"isArray",{get:function(){return this._isArray},enumerable:!1,configurable:!0}),Object.defineProperty(GssField.prototype,"searchType",{get:function(){return this._searchType},enumerable:!1,configurable:!0}),Object.defineProperty(GssField.prototype,"metaData",{get:function(){return this._metaData},enumerable:!1,configurable:!0}),Object.defineProperty(GssField.prototype,"properties",{get:function(){return this._properties},enumerable:!1,configurable:!0}),GssField.prototype.sameAs=function(e){return null!=e&&(this.type===e.type&&this.isArray===e.isArray&&this.searchType===e.searchType&&this._haveSameFields(this.properties,e.properties))},GssField.prototype._haveSameFields=function(e,t){return null==e?null==t:e.sameAs(t)},GssField}();t["default"]=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProvidersSubStreamName=t.SearchPubStreamName=t.EntityTypesPubStreamName=t.SearchSubStreamName=t.EntityTypesSubStreamName=void 0,t.EntityTypesSubStreamName="T42.GSS.Subscribe.EntityTypes",t.SearchSubStreamName="T42.GSS.Subscribe.Search",t.EntityTypesPubStreamName="T42.GSS.Publish.EntityTypes",t.SearchPubStreamName="T42.GSS.Publish.Search",t.ProvidersSubStreamName="T42.GSS.Subscribe.Providers"},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ON_FAILED=t.ON_ENTITIES=t.STATE_OKAY=t.STATE_FAILED=t.defaultFetchOptions=t.defaultOptions=t.STARTED=t.STOPPED=t.lookup=void 0,t.lookup=new Map([["NoneNone","None"],["NoneExact","Exact"],["NonePartial","Partial"],["NoneBoth","Both"],["ExactNone","Exact"],["ExactExact","Exact"],["ExactPartial","Both"],["ExactBoth","Both"],["PartialNone","Partial"],["PartialExact","Both"],["PartialPartial","Partial"],["PartialBoth","Both"],["BothNone","Both"],["BothExact","Both"],["BothPartial","Both"],["BothBoth","Both"]]),t.STOPPED="stopped",t.STARTED="started",t.defaultOptions=new Map(Object.entries({debug:!1,pollIntervalInMillis:1e4,autoDiscoverSearchProviders:!0})),t.defaultFetchOptions={method:"POST",withCredentials:!1,timeout:1e4,maxContentLength:Infinity},t.STATE_FAILED="failed",t.STATE_OKAY="okay",t.ON_ENTITIES="onEntities",t.ON_FAILED="onFailed"},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function GssQueryState(e){this._name=e,Object.freeze(this)}return Object.defineProperty(GssQueryState.prototype,"name",{get:function(){return this._name},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryState,"Created",{get:function(){return i},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryState,"Pending",{get:function(){return o},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryState,"Active",{get:function(){return a},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryState,"Canceled",{get:function(){return s},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryState,"Closed",{get:function(){return u},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryState,"PartiallyFailed",{get:function(){return c},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryState,"Failed",{get:function(){return l},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryState,"TimedOut",{get:function(){return p},enumerable:!1,configurable:!0}),GssQueryState}();t["default"]=n;var i=new n("Created"),o=new n("Pending"),a=new n("Active"),s=new n("Canceled"),u=new n("Closed"),c=new n("PartiallyFailed"),l=new n("Failed"),p=new n("TimedOut")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(1),i=function(){function GssOptions(e){e=n.assign({},e||{}),e.target&&"string"==typeof e.target&&(e.target={application:e.target}),this.fullTextSearchPropertyName=e.fullTextSearchPropertyName||GssOptions.DefaultFullTextSearchPropertyName,this.target=e.target||{application:GssOptions.DefaultTargetApplication},this.debug=Boolean(e.debug),this.trace=Boolean(e.trace),this.measureLatency=Boolean(e.measureLatency),this.logger=e.logger,this.rescheduleQueriesOnDisconnect=Boolean(e.rescheduleQueriesOnDisconnect),this.connectTimeoutInMillis=e.connectTimeoutInMillis,this.searchTimeoutInMillis=e.searchTimeoutInMillis,this._testNoAgm=Boolean(e._testNoAgm),this._testFailReady=Boolean(e._testFailReady),this._testDontCheckEntityType=Boolean(e._testDontCheckEntityType)}return Object.defineProperty(GssOptions.prototype,"target",{get:function(){return this._target},set:function(e){this._target=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssOptions.prototype,"connectTimeoutInMillis",{get:function(){return this._connectTimeoutInMillis},set:function(e){this._connectTimeoutInMillis=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssOptions.prototype,"searchTimeoutInMillis",{get:function(){return this._searchTimeoutInMillis},set:function(e){this._searchTimeoutInMillis=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssOptions.prototype,"debug",{get:function(){return this._debug},set:function(e){this._debug=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssOptions.prototype,"trace",{get:function(){return this._trace},set:function(e){this._trace=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssOptions.prototype,"measureLatency",{get:function(){return this._measureLatency},set:function(e){this._measureLatency=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssOptions.prototype,"logger",{get:function(){return this._logger},set:function(e){this._logger=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssOptions.prototype,"rescheduleQueriesOnDisconnect",{get:function(){return this._rescheduleQueriesOnDisconnect},set:function(e){this._rescheduleQueriesOnDisconnect=e},enumerable:!1,configurable:!0}),GssOptions.DefaultTargetApplication="GssDesktopManager",GssOptions.DefaultFullTextSearchPropertyName="ANY",GssOptions}();t["default"]=i},function(e,t,r){"use strict";(function(t){function setContentTypeIfUnset(e,t){!n.isUndefined(e)&&n.isUndefined(e["Content-Type"])&&(e["Content-Type"]=t)}var n=r(2),i=r(57),o={"Content-Type":"application/x-www-form-urlencoded"},a={adapter:function(){var e;return"undefined"!=typeof XMLHttpRequest?e=r(25):void 0!==t&&(e=r(25)),e}(),transformRequest:[function(e,t){return i(t,"Content-Type"),n.isFormData(e)||n.isArrayBuffer(e)||n.isBuffer(e)||n.isStream(e)||n.isFile(e)||n.isBlob(e)?e:n.isArrayBufferView(e)?e.buffer:n.isURLSearchParams(e)?(setContentTypeIfUnset(t,"application/x-www-form-urlencoded;charset=utf-8"),e.toString()):n.isObject(e)?(setContentTypeIfUnset(t,"application/json;charset=utf-8"),JSON.stringify(e)):e}],transformResponse:[function(e){if("string"==typeof e)try{e=JSON.parse(e)}catch(e){}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,validateStatus:function(e){return e>=200&&e<300}};a.headers={common:{Accept:"application/json, text/plain, */*"}},n.forEach(["delete","get","head"],function(e){a.headers[e]={}}),n.forEach(["post","put","patch"],function(e){a.headers[e]=n.merge(o)}),e.exports=a}).call(t,r(56))},function(e,t){var r;r=function(){return this}();try{r=r||Function("return this")()||(0,eval)("this")}catch(e){"object"==typeof window&&(r=window)}e.exports=r},function(e,t,r){"use strict";var n=this&&this.__values||function(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(t,"__esModule",{value:!0});var i=r(9),o=r(37),a=r(1),s=r(5),u=r(13),c=r(7),l=r(14),p=r(11),f=r(0),d=r(22),h=function(){function GlueSearchService(e,t){if(!e)throw new Error("expected mandatory parameter agm");this._id=(0,f.genGuid)(),this._disposed=!1,this._agm=e,this._options=new l["default"](t),this._logger=this._options.logger||new c["default"]("main",{debug:this._options.debug,trace:this._options.trace}),this._entityTypeMethodAvailable=!1,this._searchMethodAvailable=!1,this._isReady=undefined,this._isConnected=!1,this._connectionStatusCallbacks=[],this._entityTypeCallbacks=[],this._entityTypes=undefined,this._entityTypesSubscription=undefined,this._isPendingEntityTypeSubscription=!1,this._pendingQueries=new Set,this._providersCallbacks=[],this._providers=undefined,this._providersSubscription=undefined,this._isPendingProvidersSubscription=!1,this._aliases=undefined,this._logger.trace(function(){return"constructed with ".concat(JSON.stringify(t,null,2))})}return GlueSearchService.prototype.ready=function(e){if(this._throwIfDisposed(),e&&!a.isFunction(e))throw new TypeError("Callback not a function");return this._logger.trace&&this._logger.trace("Method ready() called with".concat(e?"":"out"," callback")),this._isReady||(this._isReady=new i["default"],this._connect()),this._isReady.subscribe(e)},GlueSearchService.prototype.onConnectionStatus=function(e){var t=this;if(this._throwIfDisposed(),!a.isFunction(e))throw new TypeError("expected mandatory parameter callback");this._options.trace&&this._logger.trace("onConnectionStatus called"),this._connectionStatusCallbacks.push(e),(0,f.safeCall)(function(){return e(t._isConnected)},this._logger)},Object.defineProperty(GlueSearchService.prototype,"connected",{get:function(){return this._throwIfDisposed(),this._isConnected},enumerable:!1,configurable:!0}),GlueSearchService.prototype.onEntityTypes=function(e){var t=this;if(this._throwIfDisposed(),this._isReady||(0,d._throwNotReady)(),!a.isFunction(e))throw new TypeError("expected mandatory parameter callback of type function");if(this._options.trace&&this._logger.trace("onEntityTypes called"),this._entityTypeCallbacks.push(e),this._entityTypes!==undefined&&(0,f.safeCall)(function(){return e(null,t._entityTypes)},this._logger),this._entityTypesSubscription===undefined)return this._activateEntityTypesSubscription(),this},GlueSearchService.prototype.onProviders=function(e){var t=this;if(this._throwIfDisposed(),this._isReady||(0,d._throwNotReady)(),!a.isFunction(e))throw new TypeError("expected mandatory parameter callback of type function");if(this._options.trace&&this._logger.trace("onProviders called"),this._providersCallbacks.push(e),this._providers!==undefined&&(0,f.safeCall)(function(){return e(null,t._providers)},this._logger),this._providersSubscription===undefined)return this._activateProvidersSubscription(),this},Object.defineProperty(GlueSearchService.prototype,"providers",{get:function(){return this._throwIfDisposed(),this._providers?this._providers.values():[]},enumerable:!1,configurable:!0}),GlueSearchService.prototype.addProviderAlias=function(e,t){if(this._throwIfDisposed(),"string"!=typeof e||""===e)throw new TypeError("alias must be non-empty string");if("string"!=typeof t||""===t)throw new TypeError("providerName must be non-empty string");if(this._aliases||(this._aliases=new Map),this._aliases.has(e))throw new Error("cannot overwrite, alias ".concat(e," is already in use"));if(-1!==(0,f.spread)(this._aliases.values()).indexOf(t))throw new Error("cannot overwrite providerName ".concat(t," with new alias"));return this._aliases.set(e,t),this},GlueSearchService.prototype.createQuery=function(e,t){if(this._throwIfDisposed(),!e)throw new TypeError("expected required parameter entityType");if(!this._options._testDontCheckEntityType){if(this._entityTypes===undefined)throw new Error("You must subscribe to onEntityTypes before calling createQuery()");if(!(e instanceof s["default"])){if("string"!=typeof e)throw new TypeError("expected entityType of type string or GssEntityType");var r=e;if((e=this._entityTypes.get(r))===undefined)throw new TypeError("entity type '".concat(r," not available"))}}var n;return t&&((0,d._validateQueryOptions)(e,t),n=t),this._options.debug&&this._logger.debug("Creating query with entity type ".concat(e.name," and options ").concat((0,f.str)(t,!0))),new o["default"](this,e,n,this._logger)},GlueSearchService.prototype.dispose=function(){this._disposed||(this._disposed=!0,this._entityTypeMethodAvailable=!1,this._searchMethodAvailable=!1,this._isReady=undefined,this._isConnected=!1,this._connectionStatusCallbacks=[],this._entityTypeCallbacks=[],this._entityTypes=undefined,this._entityTypesSubscription=undefined,this._isPendingEntityTypeSubscription=!1,this._pendingQueries=new Set,this._providersCallbacks=[],this._providers=undefined,this._providersSubscription=undefined,this._isPendingProvidersSubscription=!1,this._aliases=undefined,this._logger.info("GlueSearchService disposed."))},GlueSearchService.prototype._cancelSearch=function(e){this._disposed||(this._pendingQueries["delete"](e),e._setStatus(u["default"].Canceled),this._deactivateQuery(e))},GlueSearchService.prototype._startSearch=function(e){if(!this._disposed){if(this._deactivateQuery(e),e._setStatus(u["default"].Pending),!this._isConnected)return void this._pendingQueries.add(e);this._activateQuery(e)}},GlueSearchService.prototype._throwIfDisposed=function(){if(this._disposed)throw new Error("GlueSearchService is disposed")},GlueSearchService.prototype._activateEntityTypesSubscription=function(){var e=this;if(!this._disposed){this._options.debug&&this._logger.debug("Activating entity types subscription");var t=this._options.searchTimeoutInMillis,r={target:this._options.target};t&&(r.waitTimeoutMs=t),this._agm.subscribe(p.EntityTypesSubStreamName,r).then(function(t){e._entityTypesSubscription=t,t.onData(function(t){if(!e._disposed){e._options.debug&&e._logger.debug("EntityTypes subscription <|: ".concat((0,f.str)(t,!0))),e._entityTypes=undefined;try{var r=(0,f.generalConvertEntityTypes)(t.data,e._logger);if(!r)return;e._entityTypes=r,e._fireEntityCallbacks(null,r,"Got entity types")}catch(r){e._options.debug&&(e._logger.error("Failed to handle entity types stream data ".concat((0,f.str)(t,!0))),e._logger.error(r)),e._fireEntityCallbacks(r,e._entityTypes,"Failed handling entity types stream data")}}}),t.onClosed(function(t){if(!e._disposed){e._options.debug&&e._logger.error("Entity types stream subscription unexpectedly closed - ".concat(null===t||void 0===t?void 0:t.message));var r=new Error("subscription unexpectedly closed - ".concat(null===t||void 0===t?void 0:t.message));e._entityTypes=undefined,e._isPendingEntityTypeSubscription=!0,e._fireEntityCallbacks(r,e._entityTypes,"Subscription closed"),e._rescheduleEntityTypesSubscriptionIfDisconnected()}}),t.onFailed(function(t){if(!e._disposed){e._options.debug&&e._logger.error("Entity types stream subscription unexpectedly failed - ".concat(t));var r=new Error("subscription unexpectedly failed - ".concat(t));e._entityTypes=undefined,e._isPendingEntityTypeSubscription=!0,e._fireEntityCallbacks(r,e._entityTypes,"Subscription failed"),e._rescheduleEntityTypesSubscriptionIfDisconnected()}})})["catch"](function(t){e._options.debug&&(e._logger.error("Failed to open stream subscription on ".concat(p.EntityTypesSubStreamName," for entity types")),e._logger.error(t)),e._entityTypes=undefined,e._isPendingEntityTypeSubscription=!0,e._fireEntityCallbacks(t,e._entityTypes,"Failed opening stream subscription"),e._rescheduleEntityTypesSubscriptionIfDisconnected()})}},GlueSearchService.prototype._fireEntityCallbacks=function(e,t,r){var n=this;this._logger&&this._options.debug&&this._logger.debug("".concat(this._id,": Firing ").concat(this._entityTypeCallbacks.length," onEntityTypes callbacks - ").concat(r||"N/A")),this._entityTypeCallbacks.forEach(function(r){return(0,f.safeCall)(function(){return r(e,t)},n._logger)})},GlueSearchService.prototype._deactivateEntityTypesSubscription=function(){if(!this._disposed&&this._entityTypesSubscription){try{this._entityTypesSubscription.close()}catch(e){this._options.debug&&(this._logger.warn("Failed to close entity types stream subscription"),this._logger.error(e))}this._entityTypes=undefined,this._isPendingEntityTypeSubscription=!0,this._entityTypesSubscription=undefined}},GlueSearchService.prototype._rescheduleEntityTypesSubscriptionIfDisconnected=function(){this._disposed||(this._deactivateEntityTypesSubscription(),this._isConnected||(this._isPendingEntityTypeSubscription=!0))},GlueSearchService.prototype._activateProvidersSubscription=function(){var e=this;if(!this._disposed){this._options.debug&&this._logger.debug("Activating providers subscription");var t=this._options.searchTimeoutInMillis,r={target:this._options.target};t&&(r.waitTimeoutMs=t),this._agm.subscribe(p.ProvidersSubStreamName,r).then(function(t){e._providersSubscription=t,t.onData(function(t){if(!e._disposed){e._options.debug&&e._logger.debug("Providers subscription <|: ".concat((0,f.str)(t,!0))),e._providers=undefined;try{var r=(0,d._convertProviders)(t.data,e._logger);if(!r)return;e._providers=r,e._fireProvidersCallbacks(null,r,"Got providers")}catch(r){e._options.debug&&(e._logger.error("Failed to handle providers stream data ".concat((0,f.str)(t,!0))),e._logger.error(r)),e._fireProvidersCallbacks(r,e._providers,"Failed handling providers stream data")}}}),t.onClosed(function(t){if(!e._disposed){e._options.debug&&e._logger.error("Providers stream subscription unexpectedly closed - ".concat(null===t||void 0===t?void 0:t.message));var r=new Error("subscription unexpectedly closed - ".concat(null===t||void 0===t?void 0:t.message));e._providers=undefined,e._isPendingProvidersSubscription=!0,e._fireProvidersCallbacks(r,e._providers,"Subscription closed"),e._rescheduleProvidersSubscriptionIfDisconnected()}}),t.onFailed(function(t){if(!e._disposed){e._options.debug&&e._logger.error("Providers stream subscription unexpectedly failed - ".concat(t));var r=new Error("subscription unexpectedly failed - ".concat(t));e._providers=undefined,e._isPendingProvidersSubscription=!0,e._fireProvidersCallbacks(r,e._providers,"Subscription failed"),e._rescheduleProvidersSubscriptionIfDisconnected()}})})["catch"](function(t){e._options.debug&&(e._logger.error("Failed to open stream subscription on ".concat(p.ProvidersSubStreamName," for providers")),e._logger.error(t)),e._providers=undefined,e._isPendingProvidersSubscription=!0,e._fireProvidersCallbacks(t,e._providers,"Failed opening stream subscription"),e._rescheduleProvidersSubscriptionIfDisconnected()})}},GlueSearchService.prototype._fireProvidersCallbacks=function(e,t,r){var n=this;this._logger&&this._options.debug&&this._logger.debug("".concat(this._id,": Firing ").concat(this._providersCallbacks.length," onProviders callbacks - ").concat(r||"N/A")),this._providersCallbacks.forEach(function(r){return(0,f.safeCall)(function(){return r(e,t)},n._logger)})},GlueSearchService.prototype._deactivateProvidersSubscription=function(){if(!this._disposed&&this._providersSubscription){try{this._providersSubscription.close()}catch(e){this._options.debug&&(this._logger.warn("Failed to close providers stream subscription"),this._logger.error(e))}this._providers=undefined,this._isPendingProvidersSubscription=!0,this._providersSubscription=undefined}},GlueSearchService.prototype._rescheduleProvidersSubscriptionIfDisconnected=function(){this._disposed||(this._deactivateProvidersSubscription(),this._isConnected||(this._isPendingProvidersSubscription=!0))},Object.defineProperty(GlueSearchService.prototype,"_providerAliases",{get:function(){return(0,f.spread)(this._aliases.entries())},enumerable:!1,configurable:!0}),GlueSearchService.prototype._checkIfProviderNameIsAlias=function(e){if("string"!=typeof e||""===e)throw TypeError("the provider nameOrAlias must be a non-empty string");return this._aliases instanceof Map&&this._aliases.has(e)?this._aliases.get(e):e},GlueSearchService.prototype._deactivateQuery=function(e){if(!this._disposed){var t=e._subscription;if(e._meta=undefined,e._subscription=undefined,t)try{t.close()}catch(e){this._logger.error("Failed to close subscription ".concat(t.stream.name)+e.stack)}}},GlueSearchService.prototype._activateQuery=function(e){var t,r=this;if(!this._disposed){var n,i=!1,o=!1;this._options.measureLatency&&(n=Date.now()),this._options.debug&&this._logger.debug("Activating query, filter: ".concat((0,f.str)(e.filter,!0),", props: ").concat((0,f.str)(e.options.properties,!0)));var s=(null===(t=null===e||void 0===e?void 0:e.options)||void 0===t?void 0:t.timeoutInMillis)||this._options.searchTimeoutInMillis,c={target:this._options.target,arguments:{entityType:e.entityType.name,filter:e.filter.map(function(e){return{name:e.name,value:e.value,searchType:e.searchType.name}}),limit:undefined,properties:undefined,providers:undefined}};s&&(c.waitTimeoutMs=s);var l=(e.options||{}).limit;l&&(c.arguments.limit=l),e.options&&e.options.properties&&(c.arguments.properties=e.options.properties),e.options&&e.options.providers&&(c.arguments.providers=e.options.providers.map(function(e){return r._checkIfProviderNameIsAlias(e)}));var h=a.cloneDeep(e);this._agm.subscribe(p.SearchSubStreamName,c).then(function(t){if(r._options.measureLatency){var s=Date.now()-n;console.log("PERF: Took ".concat(s," ms to SUBSCRIBE for ").concat((0,f.str)(e.filter)))}e._subscription=t,r._pendingQueries["delete"](e),e._setStatus(u["default"].Active),t.onData(function(t){if(!r._disposed){if(!i&&r._options.measureLatency){i=!0;var s=Date.now()-n;console.log("PERF: Took ".concat(s," ms to GET FIRST RESULT for ").concat((0,f.str)(e.filter)))}r._options.debug&&r._logger.debug("Received for query ".concat((0,f.str)(c,!0)," data ").concat((0,f.str)(t,!0)));var l=e.status.state;if(e._subscription===undefined||l!==u["default"].Active&&l!==u["default"].PartiallyFailed)return void(r._options.debug&&r._logger.debug("Discarding late update for query ".concat((0,f.str)(c,!0)," (in state ").concat(l,") - ").concat((0,f.str)(t,!0))));try{var p=void 0;r._options.measureLatency&&(p=Date.now());var y=t.data;if(!y)return void(r._options.debug&&r._logger.debug("Received empty result for entity type ".concat(e.entityType.name)));var g=y.provider||"N/A",b=(0,f.tryGetError)(y,r._logger),_=!a.isUndefined(b),v=y.pendingProviders||[];a.isUndefined(e._meta)&&(e._meta={providerCount:1+v.length,errorCount:0}),e._meta.errorCount+=_?1:0;var m=e._meta.errorCount===e._meta.providerCount,S=Boolean(a.get(y,"result.isFromCache",!1));if(o=0===v.length&&!S,_)e._failedProviders.push(g),e._setStatus(m?u["default"].Failed:u["default"].PartiallyFailed,b);else{var T=y.result||{},w=(0,d._convertResult)(g,e.entityType,T,r._logger);if(r._options.measureLatency){var E=Date.now()-p,P=w&&w.entities?w.entities.length:0;console.log("PERF: Took ".concat(E," ms to CONVERT ").concat(P," entities for ").concat((0,f.str)(e.filter)))}e._handleData(w,h)}}catch(n){r._options.debug&&(r._logger.error("Failed to handle data update for query ".concat((0,f.str)(c,!0),", data - ").concat((0,f.str)(t,!0))),r._logger.error(n)),o=!0,e._setStatus(u["default"].Failed,"unexpected error - ".concat(n))}finally{o&&r._completeQuery(e)}}}),t.onClosed(function(t){r._disposed||(r._options.debug&&r._logger.debug("Subscription for query ".concat((0,f.str)(c,!0)," closed with reason ").concat(null===t||void 0===t?void 0:t.message)),e.status.state!==u["default"].Canceled&&e.status.state!==u["default"].Pending&&(e._setStatus(u["default"].Closed,null===t||void 0===t?void 0:t.message),r._completeQuery(e)))}),t.onFailed(function(t){r._disposed||(r._options.debug&&r._logger.error("Subscription for query ".concat((0,f.str)(c,!0)," failed with reason ").concat(t)),e._setStatus(u["default"].Failed,t),r._completeQuery(e))})})["catch"](function(t){r._options.debug&&(r._logger.error("Failed to open stream subscription on ".concat(p.SearchSubStreamName," for query ").concat((0,f.str)(c,!0))),r._logger.error(t)),e._setStatus(u["default"].Failed,t.message),r._completeQuery(e)})}},GlueSearchService.prototype._completeQuery=function(e){this._disposed||(e._handleComplete(),this._deactivateQuery(e))},GlueSearchService.prototype._connect=function(){var e=this;if(!this._disposed){if(this._options._testNoAgm)return void setTimeout(function(){e._options._testFailReady?e._isReady.reject(new Error("Unexpected")):e._isReady.resolve(e)},0);this._options.connectTimeoutInMillis&&setTimeout(function(){e._isReady.reject(new Error("timed out"))},this._options.connectTimeoutInMillis),this._agm.serverMethodAdded(function(t){if(!e._disposed){e._options.debug&&e._logger.debug("AGM server method added: ".concat((0,f.str)(t)));var r=t.method,n=t.server;e._entityTypeMethodAvailable&&e._searchMethodAvailable||n.application===e._options.target.application&&(r.name===p.EntityTypesSubStreamName?e._entityTypeMethodAvailable=!0:r.name===p.SearchSubStreamName&&(e._searchMethodAvailable=!0),e._entityTypeMethodAvailable&&e._searchMethodAvailable&&e._handleReconnect())}}),this._agm.serverMethodRemoved(function(t){if(!e._disposed){e._options.debug&&e._logger.debug("AGM server method removed:  ".concat((0,f.str)(t)));var r=t.method,n=t.server;(e._entityTypeMethodAvailable||e._searchMethodAvailable)&&n&&n.application===e._options.target.application&&(r.name===p.EntityTypesSubStreamName?e._entityTypeMethodAvailable=!1:r.name===p.SearchSubStreamName&&(e._searchMethodAvailable=!1),(!e._entityTypeMethodAvailable&&e._searchMethodAvailable||!e._searchMethodAvailable&&e._entityTypeMethodAvailable)&&e._handleDisconnect())}})}},GlueSearchService.prototype._handleReconnect=function(){var e,t,r=this;if(!this._disposed&&!this._isConnected){this._isConnected=!0,this._isReady.fulfilled||this._isReady.resolve(this),this._connectionStatusCallbacks.forEach(function(e){return(0,f.safeCall)(function(){return e(!0)},r._logger)}),this._isPendingEntityTypeSubscription&&this._activateEntityTypesSubscription();try{for(var i=n(this._pendingQueries.values()),o=i.next();!o.done;o=i.next()){var a=o.value;a._setStatus(u["default"].Pending,"Reconnected"),this._activateQuery(a)}}catch(t){e={error:t}}finally{try{o&&!o.done&&(t=i["return"])&&t.call(i)}finally{if(e)throw e.error}}}},GlueSearchService.prototype._handleDisconnect=function(){var e=this;if(!this._disposed&&this._isConnected){this._isConnected=!1,this._entityTypes=undefined,this._isPendingEntityTypeSubscription=!0,this._connectionStatusCallbacks.forEach(function(t){return(0,f.safeCall)(function(){return t(!1)},e._logger)});var t=new Error("Disconnected");this._fireEntityCallbacks(t,this._entityTypes,"Disconnected")}},GlueSearchService}();t["default"]=h},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function GssProviderQuery(e,t,r,n,i){this._entityTypeName=e,this._filter=t,this._properties=r,this._limit=n,this._providers=i}return Object.defineProperty(GssProviderQuery.prototype,"entityTypeName",{get:function(){return this._entityTypeName},enumerable:!1,configurable:!0}),Object.defineProperty(GssProviderQuery.prototype,"filter",{get:function(){return this._filter},enumerable:!1,configurable:!0}),Object.defineProperty(GssProviderQuery.prototype,"properties",{get:function(){return this._properties},enumerable:!1,configurable:!0}),Object.defineProperty(GssProviderQuery.prototype,"limit",{get:function(){return this._limit},enumerable:!1,configurable:!0}),Object.defineProperty(GssProviderQuery.prototype,"providers",{get:function(){return this._providers},enumerable:!1,configurable:!0}),GssProviderQuery}();t["default"]=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),i=function(){function GssEntityTypes(e){var t=this;if(e===undefined||!Array.isArray(e))throw new Error("Expected an array of entity types");this._entityTypes=new Map,e.forEach(function(e){t._entityTypes.set(e.name,e)}),Object.freeze(this)}return GssEntityTypes.prototype.keys=function(){return(0,n.spread)(this._entityTypes.keys())},GssEntityTypes.prototype.values=function(){return(0,n.spread)(this._entityTypes.values())},GssEntityTypes.prototype.entries=function(){return(0,n.spread)(this._entityTypes.entries())},GssEntityTypes.prototype.get=function(e){return this._entityTypes.get(e)},GssEntityTypes.prototype.has=function(e){return this._entityTypes.has(e)},GssEntityTypes.prototype.forEach=function(e){return this._entityTypes.forEach(e)},Object.defineProperty(GssEntityTypes.prototype,"size",{get:function(){return this._entityTypes.size},enumerable:!1,configurable:!0}),GssEntityTypes}();t["default"]=i},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(4),i=r(8),o=function(){function GssQuery(){}return Object.defineProperty(GssQuery.prototype,"entityType",{get:function(){throw new Error("Not implemented")},enumerable:!1,configurable:!0}),Object.defineProperty(GssQuery.prototype,"options",{get:function(){throw new Error("Not implemented")},enumerable:!1,configurable:!0}),Object.defineProperty(GssQuery.prototype,"status",{get:function(){throw new Error("Not implemented")},enumerable:!1,configurable:!0}),GssQuery.prototype.onStatus=function(e){throw new Error("Not implemented")},GssQuery.prototype.onData=function(e){throw new Error("Not implemented")},GssQuery.prototype.onComplete=function(e){throw new Error("Not implemented")},GssQuery.prototype.search=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];throw new Error("Not implemented")},GssQuery.prototype.fullTextSearch=function(e){return this.search(new i["default"](i["default"].fullTextSearchFieldName,e,n["default"].Both))},Object.defineProperty(GssQuery.prototype,"filter",{get:function(){throw new Error("Not implemented")},enumerable:!1,configurable:!0}),GssQuery.prototype.clearCallbacks=function(){throw new Error("Not implemented")},GssQuery.prototype.cancel=function(){throw new Error("Not implemented")},GssQuery}();t["default"]=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function GssQueryStatus(e,t){this._state=e,this._statusText=t||""}return Object.defineProperty(GssQueryStatus.prototype,"state",{get:function(){return this._state},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryStatus.prototype,"statusText",{get:function(){return this._statusText},enumerable:!1,configurable:!0}),GssQueryStatus}();t["default"]=n},function(e,t,r){"use strict";function _validateQueryOptions(e,t){if(t.limit!==undefined){if(!n.isNumber(t.limit))throw new TypeError("expected an integer value for limit");if(t.limit<1||t.limit>=c)throw new RangeError("limit must be in the range [1, ".concat(c,")"))}if(t.properties!==undefined){if(!n.isArray(t.properties))throw new TypeError("expected an array of property names");t.properties.forEach(function(t){if(!e.properties.has(t))throw new Error("Invalid options, property ".concat(t," is not defined in ").concat(e.name))})}if(t.providers!==undefined){if(!n.isArray(t.providers))throw new TypeError("expected an array of provider names");t.providers.forEach(function(e){if("string"!=typeof e)throw new TypeError("expected provider name to be a string")})}}function _throwNotReady(){throw new Error('You must call "ready()" first')}function _convertProviders(e,t){if(!e)return t&&t.debug&&t.debug("Received empty data on subscription to providers"),undefined;(0,i.throwOnDataError)(e);var r=e.result;if(r===undefined)return new o["default"]([]);if(!n.isArray(r))throw new Error("providers is not an array");var s=r.map(function(e){return new a["default"](e.name,e.type)});return new o["default"](s)}function _convertResult(e,t,r,n){var i=r.data||[],o=Boolean(r.isLast),a=Boolean(r.isFromCache),u=t.properties;return new s["default"](e,convertGssEntitiesToJsObjects(i,u,n),o,a)}function convertGssEntitiesToJsObjects(e,t,r){return e.map(function(e){return _convertEntity(e,t,r)})}function _convertEntity(e,t,r){return e.properties.reduce(function(e,n){var i=n.name,o=t.get(i);if(o===undefined)return e;var a=n.value;if(a===undefined)return e;var s=_convertValue(a,o,r);return s===undefined?e:(e[i]=s,e)},{})}function g(e,t){var r=n.get(e,t);return undefined,r}function _parseDate(e){return n.isNumber(e)?new Date(Math.trunc(Number(e))):Date.parse(String(e))}function _convertValue(e,t,r){if(!t)throw new TypeError("expected mandatory parameter descriptor");var n,i=t.isArray;switch(t.type){case u["default"].Bool:return i?(n=g(e,"bools"),n!==undefined?n.map(function(e){return Boolean(e)}):undefined):(n=g(e,"bool"),n!==undefined?Boolean(n):undefined);case u["default"].Int:return i?(n=g(e,"ints"),n!==undefined?n.map(function(e){return Math.trunc(Number(e))}):undefined):(n=g(e,"int"),n!==undefined?Math.trunc(Number(n)):undefined);case u["default"].Long:return i?(n=g(e,"longs"),n!==undefined?n.map(function(e){return Math.trunc(Number(e))}):undefined):(n=g(e,"long"),n!==undefined?Math.trunc(Number(n)):undefined);case u["default"].Double:return i?(n=g(e,"doubles"),n!==undefined?n.map(function(e){return Number(e)}):undefined):(n=g(e,"double"),n!==undefined?Number(n):undefined);case u["default"].DateTime:return i?(n=g(e,"timestamps"),n!==undefined?n.map(function(e){return _parseDate(e)}):undefined):(n=g(e,"timestamp"),n!==undefined?_parseDate(n):undefined);case u["default"].String:return i?(n=g(e,"strings"),n!==undefined?n.map(function(e){return String(e)}):undefined):(n=g(e,"string"),n!==undefined?String(n):undefined);case u["default"].Composite:return i?(n=g(e,"composites"),n!==undefined?n.map(function(e){return _composite(e,t,r)}):undefined):(n=g(e,"composite"),n!==undefined?_composite(n,t,r):undefined);default:throw new TypeError("cannot convert value ".concat(e," using descriptor ").concat(t.name," of type ").concat(t.type).concat(i?"(array)":""))}}function _composite(e,t,r){if(!n.isObjectLike(e))throw new TypeError("cannot convert value of type ".concat(typeof e," (").concat((0,i.str)(e,!0),") to a composite"));var o=t.properties;if(!o)throw new TypeError("GSS field ".concat(t.name," is missing inner field properties (for ").concat((0,i.str)(e,!0),")"));return _convertEntity(e,o,r)}Object.defineProperty(t,"__esModule",{value:!0}),t._composite=t._convertValue=t._parseDate=t.g=t._convertEntity=t.convertGssEntitiesToJsObjects=t._convertResult=t._convertProviders=t._throwNotReady=t._validateQueryOptions=void 0;var n=r(1),i=r(0),o=r(38),a=r(39),s=r(23),u=r(3),c=1<<30;t._validateQueryOptions=_validateQueryOptions,t._throwNotReady=_throwNotReady,t._convertProviders=_convertProviders,t._convertResult=_convertResult,t.convertGssEntitiesToJsObjects=convertGssEntitiesToJsObjects,t._convertEntity=_convertEntity,t.g=g,t._parseDate=_parseDate,t._convertValue=_convertValue,t._composite=_composite},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function GssResult(e,t,r,n){this._provider=e,this._entities=t,this._isLast=Boolean(r),this._isFromCache=Boolean(n)}return Object.defineProperty(GssResult.prototype,"provider",{get:function(){return this._provider},enumerable:!1,configurable:!0}),Object.defineProperty(GssResult.prototype,"entities",{get:function(){return this._entities},enumerable:!1,configurable:!0}),Object.defineProperty(GssResult.prototype,"isLast",{get:function(){return this._isLast},enumerable:!1,configurable:!0}),Object.defineProperty(GssResult.prototype,"isFromCache",{get:function(){return this._isFromCache},enumerable:!1,configurable:!0}),GssResult}();t["default"]=n},function(e,t,r){"use strict";e.exports=function(e,t){return function(){for(var r=new Array(arguments.length),n=0;n<r.length;n++)r[n]=arguments[n];return e.apply(t,r)}}},function(e,t,r){"use strict";var n=r(2),i=r(58),o=r(60),a=r(61),s=r(62),u=r(26),c="undefined"!=typeof window&&window.btoa&&window.btoa.bind(window)||r(63);e.exports=function(e){return new Promise(function(t,l){var p=e.data,f=e.headers;n.isFormData(p)&&delete f["Content-Type"];var d=new XMLHttpRequest,h="onreadystatechange",y=!1;if("undefined"==typeof window||!window.XDomainRequest||"withCredentials"in d||s(e.url)||(d=new window.XDomainRequest,h="onload",y=!0,d.onprogress=function(){},d.ontimeout=function(){}),e.auth){var g=e.auth.username||"",b=e.auth.password||"";f.Authorization="Basic "+c(g+":"+b)}if(d.open(e.method.toUpperCase(),o(e.url,e.params,e.paramsSerializer),!0),d.timeout=e.timeout,d[h]=function(){if(d&&(4===d.readyState||y)&&(0!==d.status||d.responseURL&&0===d.responseURL.indexOf("file:"))){var r="getAllResponseHeaders"in d?a(d.getAllResponseHeaders()):null,n=e.responseType&&"text"!==e.responseType?d.response:d.responseText,o={data:n,status:1223===d.status?204:d.status,statusText:1223===d.status?"No Content":d.statusText,headers:r,config:e,request:d};i(t,l,o),d=null}},d.onerror=function(){l(u("Network Error",e,null,d)),d=null},d.ontimeout=function(){l(u("timeout of "+e.timeout+"ms exceeded",e,"ECONNABORTED",d)),d=null},n.isStandardBrowserEnv()){var _=r(64),v=(e.withCredentials||s(e.url))&&e.xsrfCookieName?_.read(e.xsrfCookieName):undefined;v&&(f[e.xsrfHeaderName]=v)}if("setRequestHeader"in d&&n.forEach(f,function(e,t){void 0===p&&"content-type"===t.toLowerCase()?delete f[t]:d.setRequestHeader(t,e)}),e.withCredentials&&(d.withCredentials=!0),e.responseType)try{d.responseType=e.responseType}catch(t){if("json"!==e.responseType)throw t}"function"==typeof e.onDownloadProgress&&d.addEventListener("progress",e.onDownloadProgress),"function"==typeof e.onUploadProgress&&d.upload&&d.upload.addEventListener("progress",e.onUploadProgress),e.cancelToken&&e.cancelToken.promise.then(function(e){d&&(d.abort(),l(e),d=null)}),p===undefined&&(p=null),d.send(p)})}},function(e,t,r){"use strict";var n=r(59);e.exports=function(e,t,r,i,o){var a=new Error(e);return n(a,t,r,i,o)}},function(e,t,r){"use strict";e.exports=function(e){return!(!e||!e.__CANCEL__)}},function(e,t,r){"use strict";function Cancel(e){this.message=e}Cancel.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},Cancel.prototype.__CANCEL__=!0,e.exports=Cancel},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProviderState=void 0;!function(e){e.Stopped="ps_stopped",e.Connected="ps_connected",e.Failed="ps_failed"}(t.ProviderState||(t.ProviderState={}))},function(e,t,r){"use strict";function merge(e,t,r){var u={};return e.forEach(function(e){u[e.name]=e}),t.forEach(function(e){var t=u[e.name];if(!t)return void(u[e.name]=e);var c;if(e.properties&&t.properties){var l=merge(t.properties.values(),e.properties.values(),r);c=new(a["default"].bind.apply(a["default"],i([void 0],n(Object.values(l)),!1)))}else e.properties?c=e.properties:t.properties&&(c=t.properties);var p=c instanceof a["default"]&&c.size>0?new(a["default"].bind.apply(a["default"],i([void 0],n(c.values()),!1))):undefined;u[e.name]=new o["default"](e.name,e.type,e.isArray,e.searchType,e.displayName,e.description,e.metaData,p);var f=getSearchTypeOrDefault(t),d=getSearchTypeOrDefault(e),h=s.lookup.get(f+d),y=new o["default"](e.name,e.type,e.isArray,h,e.displayName,e.description,e.metaData,u[e.name].properties);u[y.name]=y}),u}function getSearchTypeOrDefault(e){return e.searchType.name?e.searchType.name:"NONE"}function sameEntityTypes(e,t){if(e.size!==t.size)return!1;var r=!0;return t.forEach(function(t,n){if(r){var i=e.get(n);if(!i)return void(r=!1);t.sameAs(i)||(r=!1)}}),r}var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o["return"])&&r.call(o)}finally{if(i)throw i.error}}return a},i=this&&this.__spreadArray||function(e,t,r){if(r||2===arguments.length)for(var n,i=0,o=t.length;i<o;i++)!n&&i in t||(n||(n=Array.prototype.slice.call(t,0,i)),n[i]=t[i]);return e.concat(n||Array.prototype.slice.call(t))};Object.defineProperty(t,"__esModule",{value:!0}),t.sameEntityTypes=t.merge=void 0;var o=r(10),a=r(6),s=r(12);t.merge=merge,t.sameEntityTypes=sameEntityTypes},function(e,t,r){"use strict";function createRegistry(e){function add(e,t){var n=r[e];return n||(n=[],r[e]=n),n.push(t),function(){var n=r[e];n&&(n=n.reduce(function(e,r,n){return r===t&&e.length===n||e.push(r),e},[]),r[e]=n)}}function execute(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];var i=r[e];if(!i||0===i.length)return[];var o=[];return i.forEach(function(r){try{var n=r.apply(undefined,t);o.push(n)}catch(t){o.push(undefined),_handleError(t,e)}}),o}function _handleError(r,n){var i=r instanceof Error?r:new Error(r);if(t)return void t(i);var o='[ERROR] callback-registry: User callback for key "'+n+'" failed: '+i.stack;if(e)switch(e.errorHandling){case"log":return console.error(o);case"silent":return;case"throw":throw new Error(o)}console.error(o)}function clear(){r={}}function clearKey(e){r[e]&&delete r[e]}if(e&&e.errorHandling&&"function"!=typeof e.errorHandling&&"log"!==e.errorHandling&&"silent"!==e.errorHandling&&"throw"!==e.errorHandling)throw new Error('Invalid options passed to createRegistry. Prop errorHandling should be ["log" | "silent" | "throw" | (err) => void], but '+typeof e.errorHandling+" was passed");var t=e&&"function"==typeof e.errorHandling&&e.errorHandling,r={};return{add:add,execute:execute,clear:clear,clearKey:clearKey}}createRegistry["default"]=createRegistry,e.exports=createRegistry},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0});var n,i=r(17),o=r(19),a=r(5),s=r(6),u=r(10),c=r(14),l=r(8),p=r(20),f=r(40),d=r(13),h=r(21),y=r(23),g=r(4),b=r(3),_=r(41),v=r(18),m=r(7),S=r(9),T=r(44),w=r(22),E=r(48),P=r(73);!function(){var t=e.gss;n={version:P.version,GlueSearchService:i["default"],GssEntityTypes:o["default"],GssEntityType:a["default"],GssFields:s["default"],GssField:u["default"],GssOptions:c["default"],GssFieldFilter:l["default"],GssQuery:p["default"],GssQueryOptions:f["default"],GssQueryState:d["default"],GssQueryStatus:h["default"],GssResult:y["default"],GssSearchType:g["default"],GssType:b["default"],GlueSearchProvider:_["default"],GssProviderQuery:v["default"],ConsoleLogger:m["default"],Promised:S["default"],convertJsObjectsToGssEntities:function(e){return a["default"].fromJS(e)},convertGssEntitiesToJsObjects:w.convertGssEntitiesToJsObjects,createDesktopManager:E["default"],parseConfigText:T.parse,parseConfigUserProps:T.parseUserProps,noConflict:function(){return e.gss=t,this}},e.gss=n}(),t["default"]=n}).call(t,r(16))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t,r){function v4(e,t,r){var o=t&&r||0;"string"==typeof e&&(t="binary"===e?new Array(16):null,e=null),e=e||{};var a=e.random||(e.rng||n)();if(a[6]=15&a[6]|64,a[8]=63&a[8]|128,t)for(var s=0;s<16;++s)t[o+s]=a[s];return t||i(a)}var n=r(35),i=r(36);e.exports=v4},function(e,t){var r="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);if(r){var n=new Uint8Array(16);e.exports=function(){return r(n),n}}else{var i=new Array(16);e.exports=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),i[t]=e>>>((3&t)<<3)&255;return i}}},function(e,t){function bytesToUuid(e,t){var n=t||0,i=r;return[i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]]].join("")}for(var r=[],n=0;n<256;++n)r[n]=(n+256).toString(16).substr(1);e.exports=bytesToUuid},function(e,t,r){"use strict";function _validateFilter(e,t){return t.map(function(t){if(!t)throw new TypeError("Invalid filter - contains undefined GssFieldFilter instance");var r=t.name;if(!r)throw new TypeError("Invalid GssFieldFilter, property name is required");var n=t.value,o=t.searchType||d["default"].None;if(r!==f["default"].fullTextSearchFieldName){var s=e.properties.get(r)||e.properties.deepGet(r);if(s===undefined)throw new TypeError("Invalid filter, property ".concat(r," is not defined in ").concat(e.name));var u=s.type;if(u===a["default"].Bool&&!i.isBoolean(n)||u===a["default"].Int&&!i.isInteger(n)||u===a["default"].Long&&!i.isInteger(n)||u===a["default"].Double&&!i.isNumber(n)||u===a["default"].DateTime&&!i.isDate(n)||u===a["default"].String&&!i.isString(n))throw new TypeError("Invalid value type '".concat(typeof n,"' passed for ").concat(r," of type '").concat(u.name,"'"));i.isString(o)&&(o=d["default"].valueOf(o)),o===d["default"].None&&(o=s.searchType)}else if(n===undefined)throw new TypeError("Invalid value (undefined) passed for ".concat(r));return new f["default"](r,n,o)})}var n=this&&this.__extends||function(){var e=function(t,r){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])})(t,r)};return function(t,r){function __(){this.constructor=t}if("function"!=typeof r&&null!==r)throw new TypeError("Class extends value "+String(r)+" is not a constructor or null");e(t,r),t.prototype=null===r?Object.create(r):(__.prototype=r.prototype,new __)}}();Object.defineProperty(t,"__esModule",{value:!0});var i=r(1),o=r(5),a=r(3),s=r(17),u=r(20),c=r(13),l=r(21),p=r(0),f=r(8),d=r(4),h=function(e){function GssQueryImpl(t,r,n,i){var a=e.call(this)||this;if(!(t&&t instanceof s["default"]))throw new TypeError("Expected gss of type GlueSearchService");if(!(r&&r instanceof o["default"]))throw new TypeError("Expected entityType of type GssEntityType");return a._gss=t,a._entityType=r,a._options=n,a._subscription=undefined,a._status=new l["default"](c["default"].Created),a._statusCallbacks=[],a._dataCallbacks=[],a._completionCallbacks=[],a._id=GssQueryImpl._NextId,GssQueryImpl._NextId++,a._logger=i,a._failedProviders=[],a._nodataProviders=[],a}return n(GssQueryImpl,e),Object.defineProperty(GssQueryImpl.prototype,"entityType",{get:function(){return this._entityType},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryImpl.prototype,"options",{get:function(){return this._options},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryImpl.prototype,"status",{get:function(){return this._status},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryImpl.prototype,"filter",{get:function(){return i.cloneDeep(this._filter)},enumerable:!1,configurable:!0}),GssQueryImpl.prototype.onStatus=function(e){var t=this;if(!e)throw new TypeError("Expected mandatory parameter callback");return this._statusCallbacks.push(e),(0,p.safeCall)(function(){return e(t._status,undefined,t._id)},this._logger),this},GssQueryImpl.prototype.onData=function(e){if(!e)throw new TypeError("Expected mandatory parameter callback");return this._dataCallbacks.push(e),this},GssQueryImpl.prototype.onComplete=function(e){if(!e)throw new TypeError("Expected mandatory parameter callback");return this._completionCallbacks.push(e),this},GssQueryImpl.prototype.search=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];if(e===undefined||!e||!Array.isArray(e)||0===e.length)throw new Error("Expected 1 or more field criteria");var r=_validateFilter(this._entityType,e);this._filter=r,this._gss._startSearch(this)},GssQueryImpl.prototype.cancel=function(){this._gss._cancelSearch(this)},GssQueryImpl.prototype.clearCallbacks=function(){this._statusCallbacks=[],this._dataCallbacks=[],this._completionCallbacks=[]},GssQueryImpl.prototype._setStatus=function(e,t){var r=this;if(this._status.state!==e||this._status.statusText!==t){var n=new l["default"](e,t),i=this._status;this._status=n;var o=(0,p.slice)(this._statusCallbacks),a=this._getFailedAndNoDataProviders();o.forEach(function(e){return(0,p.safeCall)(function(){return e(n,i,r._id,a)},r._logger)})}},GssQueryImpl.prototype._handleData=function(e,t){var r=this;(!e.entities||e.entities.length<=0)&&this._nodataProviders.push(e.provider);var n=(0,p.slice)(this._dataCallbacks),i=this._getFailedAndNoDataProviders();n.forEach(function(n){return(0,p.safeCall)(function(){return n(e,t,i)},r._logger)})},GssQueryImpl.prototype._handleComplete=function(){var e=this,t=(0,p.slice)(this._completionCallbacks);this._logger.debug("Calling onComplete on ".concat(t.length," callbacks")),t.forEach(function(t){return(0,p.safeCall)(function(){return t(e._id)},e._logger)})},GssQueryImpl.prototype._getFailedAndNoDataProviders=function(){return{nodata:this._nodataProviders.map(function(e){return e}),failed:this._failedProviders.map(function(e){return e})}},GssQueryImpl._NextId=0,GssQueryImpl}(u["default"]);t["default"]=h},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),i=function(){function GssProviders(e){var t=this;if(e===undefined||!Array.isArray(e))throw new Error("Expected an array of providers");this._providers=new Map,e.forEach(function(e){t._providers.set(e.name,e)}),Object.freeze(this)}return GssProviders.prototype.keys=function(){return(0,n.spread)(this._providers.keys())},GssProviders.prototype.values=function(){return(0,n.spread)(this._providers.values())},GssProviders.prototype.entries=function(){return(0,n.spread)(this._providers.entries())},GssProviders.prototype.get=function(e){return this._providers.get(e)},GssProviders.prototype.has=function(e){return this._providers.has(e)},GssProviders.prototype.forEach=function(e){return this._providers.forEach(e)},Object.defineProperty(GssProviders.prototype,"size",{get:function(){return this._providers.size},enumerable:!1,configurable:!0}),GssProviders}();t["default"]=i},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(1),i=function(){function GssProvider(e,t){if(!e||"string"!=typeof e)throw new Error("Expected required parameter name");if(!t||"string"!=typeof t)throw new Error("Expected required parameter type");this._name=e,this._type=t,Object.freeze(this)}return GssProvider.fromJS=function(e){if(e instanceof GssProvider)return e;if(!n.isObjectLike(e))throw new TypeError("Cannot convert argument of type '".concat(typeof e,"' to GssProvider"));return new GssProvider(e.name,e.type)},Object.defineProperty(GssProvider.prototype,"name",{get:function(){return this._name},enumerable:!1,configurable:!0}),Object.defineProperty(GssProvider.prototype,"type",{get:function(){return this._type},enumerable:!1,configurable:!0}),GssProvider.prototype.sameAs=function(e){return this._name===e._name&&this._type===e._type},GssProvider}();t["default"]=i},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function GssQueryOptions(){this._limit=undefined,this._searchTimeoutInMillis=undefined,this._properties=undefined,this._providers=undefined}return Object.defineProperty(GssQueryOptions.prototype,"limit",{get:function(){return this._limit},set:function(e){this._limit=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryOptions.prototype,"timeoutInMillis",{get:function(){return this._searchTimeoutInMillis},set:function(e){this._searchTimeoutInMillis=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryOptions.prototype,"properties",{get:function(){return this._properties},set:function(e){this._properties=e},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryOptions.prototype,"providers",{get:function(){return this._providers},set:function(e){this._providers=e},enumerable:!1,configurable:!0}),GssQueryOptions}();t["default"]=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(5),i=r(11),o=r(1),a=r(9),s=r(42),u=r(14),c=r(7),l=r(0),p=r(0),f=r(0),d=r(43),h=0,y=function(){function GlueSearchProvider(e,t){if(!e)throw new TypeError("Expected mandatory parameter agm.");this._agm=e,this._options=new u["default"](t),this._logger=this._options.logger||new c["default"]("main",{debug:this._options.debug,trace:this._options.trace}),this._entityTypes=new Map,this._state=h,this._entityTypeStream=undefined,this._searchStream=undefined}return GlueSearchProvider.prototype.addEntityType=function(e,t){if(!e)throw new TypeError("Expected mandatory parameter entityType");if(e=n["default"].fromJS(e),!o.isFunction(t))throw new TypeError("Expected searchHandler of type function(query: GssQueryRequest)");return this._entityTypes.get(e.name)&&this._options.debug&&this._logger.warn("Entity type ".concat(e.name," already registered, replacing it")),this._entityTypes.set(e.name,new d.EntityType(e,t)),1===this._state&&this._republishEntityTypes(),this},GlueSearchProvider.prototype.start=function(e){var t=this;if(1===this._state)return a["default"].rejected(new Error("Already started"),e);var r=new a["default"];return this._createStreams().then(function(){t._republishEntityTypes(),t._state=1,r.resolve(t)})["catch"](function(e){t._options.debug&&(t._logger.error("Failed to create GSS publisher streams"),t._logger.error(e)),r.reject(e)}),r.subscribe(e)},GlueSearchProvider.prototype.stop=function(){if(this._state===h)throw new Error("Already stopped");this._closeEntityTypeStream(),this._closeSearchStream(),this._state=h},GlueSearchProvider.prototype._createStreams=function(){var e=this;return this._createEntityTypeStream().then(function(){return e._createSearchStream()})},GlueSearchProvider.prototype._createSearchStream=function(){var e=this,t=new a["default"];return this._agm.createStream({name:i.SearchPubStreamName},{subscriptionRequestHandler:function(t){e._onSearchSubscriptionRequest(t)},subscriptionAddedHandler:function(t){e._onSearchSubscriptionAdded(t)},subscriptionRemovedHandler:function(t){e._onSearchSubscriptionRemoved(t)}}).then(function(r){e._searchStream=r,e._options.debug&&e._logger.debug("Stream ".concat(i.SearchPubStreamName," created successfully")),t.resolve(e)})["catch"](function(r){e._options.debug&&(e._logger.error("Failed to register ".concat(i.SearchPubStreamName)),e._logger.error(r)),e._searchStream=undefined,t.reject(r)}),t.promise},GlueSearchProvider.prototype._onSearchSubscriptionRequest=function(e){var t,r;this._options.measureLatency&&(t=Date.now());var n=e.instance.application+" - "+(0,l.str)(e.arguments);try{var i=(0,f.parseQueryFromRequest)(e.arguments),o=this._entityTypes.get(i.entityTypeName);if(!o)throw new Error("Unsupported entity type ".concat(i.entityTypeName));(0,f.validateQuery)(i,o.entityType),this._options.debug&&this._logger.debug("Accepted search request from ".concat(n)),e.accept()}catch(t){this._options.debug&&this._logger.error(t),e.reject(t.message)}finally{this._options.measureLatency&&(r=Date.now()-t,console.log("PERF: Took ".concat(r," ms to ACCEPT ").concat(n)))}},GlueSearchProvider.prototype._onSearchSubscriptionAdded=function(e){var t,r,n=this;this._options.measureLatency&&(t=Date.now());var i=e.instance.application+" - "+(0,l.str)(e.arguments);this._options.debug&&this._logger.debug("Search subscriber added ".concat(i));try{var o=(0,f.parseQueryFromRequest)(e.arguments),a=this._entityTypes.get(o.entityTypeName);if(!a)throw new Error("Unsupported entity type ".concat(o.entityTypeName));var u=new s["default"](this._logger,o,a.entityType,function(r,o){if(o&&n._options.measureLatency){var a=Date.now()-t;console.log("PERF: Took ".concat(a," ms to PUSH last result for ").concat(i))}n._options.debug&&n._logger.debug("Publishing search result: ".concat((0,l.str)(r,!0))),e.push(r)},function(t){e.push({error:t})},this._options.measureLatency);try{a.searchHandler(u)}catch(t){this._options.debug&&this._logger.error(t),e.push({error:{message:t.message}})}}catch(t){this._options.debug&&this._logger.error(t),e.push({error:{message:t.message}})}finally{this._options.measureLatency&&(r=Date.now()-t,console.log("PERF: Took ".concat(r," ms to PROCESS ").concat(i)))}},GlueSearchProvider.prototype._onSearchSubscriptionRemoved=function(e){var t=e.instance.application+" - "+(0,l.str)(e.arguments);this._options.debug&&this._logger.debug("Search subscriber removed ".concat(t))},GlueSearchProvider.prototype._closeSearchStream=function(){this._searchStream&&(this._searchStream.close(),this._searchStream=undefined)},GlueSearchProvider.prototype._createEntityTypeStream=function(){var e=this,t=new a["default"];return this._agm.createStream({name:i.EntityTypesPubStreamName},{subscriptionRequestHandler:function(t){e._onEntityTypeSubscriptionRequest(t)},subscriptionAddedHandler:function(t){e._onEntityTypeSubscriptionAdded(t)},subscriptionRemovedHandler:function(t){e._onEntityTypeSubscriptionRemoved(t)}}).then(function(r){e._entityTypeStream=r,e._options.debug&&e._logger.debug("Stream ".concat(i.EntityTypesPubStreamName," created successfully")),t.resolve(e)})["catch"](function(r){e._options.debug&&(e._logger.error("Failed to register ".concat(i.EntityTypesPubStreamName)),e._logger.error(r)),e._entityTypeStream=undefined,t.reject(r)}),t.promise},GlueSearchProvider.prototype._onEntityTypeSubscriptionRequest=function(e){this._options.debug&&this._logger.debug("Accepted entity types request from ".concat(e.instance.application)),e.accept()},GlueSearchProvider.prototype._onEntityTypeSubscriptionAdded=function(e){this._options.debug&&this._logger.debug("Entity types subscriber added ".concat(e.instance.application));var t=(0,p.providerConvertEntityTypes)(this._entityTypes);e.push(t)},GlueSearchProvider.prototype._onEntityTypeSubscriptionRemoved=function(e){this._options.debug&&this._logger.debug("Entity types subscriber removed ".concat(e.instance.application))},GlueSearchProvider.prototype._closeEntityTypeStream=function(){this._entityTypeStream&&(this._entityTypeStream.close(),this._entityTypeStream=undefined)},GlueSearchProvider.prototype._republishEntityTypes=function(){var e=(0,p.providerConvertEntityTypes)(this._entityTypes);this._options.debug&&this._logger.debug("Publishing entity types: "+JSON.stringify(e,undefined,2)),this._entityTypeStream.push(e)},GlueSearchProvider}();t["default"]=y},function(e,t,r){"use strict";function _toGssError(e){if(o.isUndefined(e))throw new TypeError(s);if(o.isError(e))return{message:e.message+"\n"+String(e.stack||"")};if(o.isString(e))return{message:e};if(!o.isObjectLike(e))throw new TypeError(s);var t=["code","mnemonic","message"].reduce(function(t,r){var n=o.get(e,r,undefined);return o.isUndefined(n)||o.set(t,r,n),t},{});if(0===Object.getOwnPropertyNames(t).length)throw new TypeError(s);return t}function _entityToGssObject(e,t,r){return{properties:Object.getOwnPropertyNames(e).map(function(n){var i=t.get(n);if(!i)return undefined;var o=e[n];return o===undefined||null===o?undefined:{name:n,value:_valueToGssValue(o,i,r)}}).filter(function(e){return e!==undefined})}}function _valueToGssValue(e,t,r){var o=t.isArray;switch(t.type){case n["default"].Bool:return o?{bools:e}:{bool:e};case n["default"].Int:return o?{ints:e}:{int:e};case n["default"].Long:return o?{longs:e}:{long:e};case n["default"].Double:return o?{doubles:e}:{double:e};case n["default"].DateTime:return o?{timestamps:e}:{timestamp:e};case n["default"].String:return o?{strings:e}:{string:e};case n["default"].Composite:return o?{composites:e.map(function(e){return _valueToGssComposite(e,t,r)})}:{composite:_valueToGssComposite(e,t,r)};default:throw new TypeError("Cannot convert value ".concat((0,i.str)(e)," using descriptor ").concat(t.name," of type ").concat(t.type).concat(o?"(array)":""))}}function _valueToGssComposite(e,t,r){return _entityToGssObject(e,t.properties,r)}Object.defineProperty(t,"__esModule",{value:!0});var n=r(3),i=r(0),o=r(1),a=function(){function GssQueryRequestImpl(e,t,r,n,i,o){this._query=t,this._entityType=r,this._pushCallback=n,this._errorCallback=i,this._logger=e,this._measureLatency=o}return Object.defineProperty(GssQueryRequestImpl.prototype,"query",{get:function(){return this._query},enumerable:!1,configurable:!0}),Object.defineProperty(GssQueryRequestImpl.prototype,"entityType",{get:function(){return this._entityType},enumerable:!1,configurable:!0}),GssQueryRequestImpl.prototype.push=function(e,t){var r=this;this._logger.debug&&this._logger.debug("Pushing ".concat((0,i.str)(e,!0)));var n,o;this._measureLatency&&(n=Date.now());var a=this._entityType.properties,s=e.map(function(e){return _entityToGssObject(e,a,r._logger)});this._measureLatency&&(o=Date.now()-n,console.log("PERF: Took ".concat(o," ms to CONVERT ").concat(s.length," entities"))),this._pushCallback({result:{data:s,isLast:t}},t)},GssQueryRequestImpl.prototype.error=function(e){var t=_toGssError(e);this._logger.debug&&this._logger.debug("Reporting error ".concat((0,i.str)(t,!0))),this._errorCallback(t)},GssQueryRequestImpl}();t["default"]=a;var s="Expected an Error, a GssError object, or a string (message)"},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EntityType=void 0;var n=function(){function EntityType(e,t){this._entityType=e,this._searchHandler=t}return Object.defineProperty(EntityType.prototype,"entityType",{get:function(){return this._entityType},enumerable:!1,configurable:!0}),Object.defineProperty(EntityType.prototype,"searchHandler",{get:function(){return this._searchHandler},enumerable:!1,configurable:!0}),EntityType}();t.EntityType=n},function(e,t,r){"use strict";function parse(e){if("string"!=typeof e)throw new TypeError("The content must be a string, but got ".concat(typeof e," instead."));var t=null,r=[],i=n.parse(e),o=Object.keys(i);if(o.filter(function(e){return"gds.providers"===e}).forEach(function(e){var r=i[e];!r||r.length<=0||(t=r.split(",").map(function(e){return e.trim()}))}),!Array.isArray(t)||t.length<=0)return emptyConfig();o.forEach(function(e){var n=i[e];if(n&&!(n.length<=0)){var o=e.split(".");if("gds"===o[0]&&3===o.length){var a=o[1];if(t.includes(a)&&!["global","providers"].includes(a)){var s,u=r.filter(function(e){return e.name===a});u.length>0?s=u[0]:(s={name:a},r.push(s));var c=o[2];"loadEntitiesOnce"===c?s[c]=stringToBoolean(n):["type","baseUrl","applicationName"].includes(c)&&(s[c]=n)}}}});var a=t.filter(function(e){return void 0===r.find(function(t){return t.name===e})});if(a.length>0)throw new Error("Missing configurations for for providers [".concat(a,"]."));return validateDefinitions(r),r}function parseUserProps(e){if("object"!=typeof e)throw new TypeError("The content must be an object map, but got ".concat(typeof e," instead."));var t=null,r=[],n=Object.keys(e);if(n.filter(function(e){return"gds.providers"===e}).forEach(function(r){var n=e[r];!n||n.length<=0||(t=n.split(",").map(function(e){return e.trim()}))}),!Array.isArray(t)||t.length<=0)return emptyConfig();n.forEach(function(n){var i=e[n];if(i&&!(i.length<=0)){var o=n.split(".");if("gds"===o[0]&&3===o.length){var a=o[1];if(t.includes(a)&&!["global","providers"].includes(a)){var s,u=r.filter(function(e){return e.name===a});u.length>0?s=u[0]:(s={name:a},r.push(s));var c=o[2];"loadEntitiesOnce"===c?s[c]=stringToBoolean(i):["type","baseUrl","applicationName"].includes(c)&&(s[c]=i)}}}});var i=t.filter(function(e){return void 0===r.find(function(t){return t.name===e})});if(i.length>0)throw new Error("Missing configurations for for providers [".concat(i,"]."));return validateDefinitions(r),r}function emptyConfig(){return[]}function stringToBoolean(e){return{false:!1,true:!0}[e.toLowerCase()]}function validateDefinitions(e){var t=e.map(function(e){if("string"!=typeof e.name||""===e.name)return"Invalid provider name";var t="(".concat(e.name,") ");if("string"!=typeof e.type||""===e.type)return t+"Invalid provider type";var r=e.type.trim().toLowerCase();return["agm","rest"].includes(r)?"agm"!==r||"string"==typeof e.applicationName&&""!==e.applicationName.trim()?"rest"===r&&("string"!=typeof e.baseUrl||""===e.baseUrl.trim())&&t+"For REST providers 'baseUrl' is a mandatory property":t+"For AGM providers 'applicationName' is a mandatory property":t+"Invalid provider type ''"}).filter(function(e){return e});if(t.length>0){var r=t.join("\n  ");throw new Error("Invalid provider definitions: \n  ".concat(r))}}Object.defineProperty(t,"__esModule",{value:!0}),t.parseUserProps=t.parse=void 0;var n=r(45);t.parse=parse,t.parseUserProps=parseUserProps},function(e,t,r){function Iterator(e){var t=0,r=e.length;this.peek=function(n){return n=n||0,t+n>=r?null:e.charAt(t+n)},this.next=function(n){return n=n||1,t>=r?null:e.charAt((t+=n)-n)},this.pos=function(){return t}}function isWhitespace(e){return i.test(e)}function consumeWhiteSpace(e){for(var t=e.pos();isWhitespace(e.peek());)e.next();return{type:"whitespace",start:t,end:e.pos()}}function startsComment(e){return"!"===e||"#"===e}function isEOL(e){return null==e||"\n"===e||"\r"===e}function consumeComment(e){for(var t=e.pos();!isEOL(e.peek());)e.next();return{type:"comment",start:t,end:e.pos()}}function startsKeyVal(e){return!isWhitespace(e)&&!startsComment(e)}function startsSeparator(e){return"="===e||":"===e||isWhitespace(e)}function startsEscapedVal(e){return"\\"===e}function consumeEscapedVal(e){var t=e.pos();return e.next(),"u"===e.next()&&e.next(4),{type:"escaped-value",start:t,end:e.pos()}}function consumeKey(e){for(var t,r=e.pos(),n=[];null!==(t=e.peek())&&!startsSeparator(t);)startsEscapedVal(t)?n.push(consumeEscapedVal(e)):e.next();return{type:"key",start:r,end:e.pos(),children:n}}function consumeKeyValSeparator(e){for(var t,r=e.pos(),n=!1;null!==(t=e.peek())&&!isEOL(t);)if(isWhitespace(t))e.next();else{if(n)break;if(!(n=":"===t||"="===t))break;e.next()}return{type:"key-value-separator",start:r,end:e.pos()}}function startsLineBreak(e){return"\\"===e.peek()&&isEOL(e.peek(1))}function consumeLineBreak(e){var t=e.pos();e.next(),"\r"===e.peek()&&e.next(),e.next();for(var r;null!==(r=e.peek())&&!isEOL(r)&&isWhitespace(r);)e.next();return{type:"line-break",start:t,end:e.pos()}}function consumeVal(e){for(var t,r=e.pos(),n=[];null!==(t=e.peek());)if(startsLineBreak(e))n.push(consumeLineBreak(e));else if(startsEscapedVal(t))n.push(consumeEscapedVal(e));else{if(isEOL(t))break;e.next()}return{type:"value",start:r,end:e.pos(),children:n}}function consumeKeyVal(e){return{type:"key-value",start:e.pos(),children:[consumeKey(e),consumeKeyValSeparator(e),consumeVal(e)],end:e.pos()}}function rangeToBuffer(e,t){for(var r=e.start,n=[],i=0;i<e.children.length;i++){var a=e.children[i];n.push(t.substring(r,a.start)),n.push(o[a.type](a,t)),r=a.end}return n.push(t.substring(r,e.end)),n}function rangesToObject(e,t){for(var r=Object.create(null),n=0;n<e.length;n++){var i=e[n];if("key-value"===i.type){var o=rangeToBuffer(i.children[0],t).join(""),a=rangeToBuffer(i.children[2],t).join("");r[o]=a}}return r}function stringToRanges(e){for(var t,r=new Iterator(e),n=[];null!==(t=r.peek());)if(isWhitespace(t))n.push(consumeWhiteSpace(r));else if(startsComment(t))n.push(consumeComment(r));else{if(!startsKeyVal(t))throw Error("Something crazy happened. text: '"+e+"'; curChar: '"+t+"'");n.push(consumeKeyVal(r))}return n}function isNewLineRange(e){return!!e&&("whitespace"===e.type||"literal"===e.type&&(isWhitespace(e.text)&&e.text.indexOf("\n")>-1))}function escapeMaker(e){return function(t){for(var r=["","0","00","000"],n=[],i=0;i<t.length;i++){var o=t.charAt(i);if(e[o])n.push(e[o]);else{var a=o.codePointAt(0);if(a<=127)n.push(o);else{var s=a.toString(16);n.push("\\u"),n.push(r[4-s.length]),n.push(s)}}}return n.join("")}}function Editor(e,t){"object"==typeof e&&(t=e,e=null),e=e||"";for(var r=t.path,i=t.separator||"=",o=stringToRanges(e),u=rangesToObject(o,e),c=Object.create(null),l=0;l<o.length;l++){var p=o[l];if("key-value"===p.type){var f=rangeToBuffer(p.children[0],e).join("");c[f]=p}}this.addHeadComment=function(e){null!=e&&o.unshift({type:"literal",text:"# "+e.replace(/\n/g,"\n# ")+"\n"})},this.get=function(e){return u[e]},this.set=function(e,t,r){if(null==t)return void this.unset(e);u[e]=t;var n=a(e),l=s(t),p=c[e];if(!p){c[e]=p={type:"literal",text:n+i+l};var f=o[o.length-1];null==f||isNewLineRange(f)||o.push({type:"literal",text:"\n"}),o.push(p)}if(r!==undefined&&(p.comment=r&&"# "+r.replace(/\n/g,"\n# ")+"\n"),"literal"===p.type)p.text=n+i+l,null!=p.comment&&(p.text=p.comment+p.text);else{if("key-value"!==p.type)throw"Unknown node type: "+p.type;p.children[2]={type:"literal",text:l}}},this.unset=function(e){if(e in u){var t=c[e],r=o.indexOf(t);o.splice(r,isNewLineRange(o[r+1])?2:1),delete c[e],delete u[e]}},this.valueOf=this.toString=function(){for(var t,r=[],n=[].concat(o);null!=(t=n.shift());)switch(t.type){case"literal":r.push(t.text);break;case"key":case"value":case"comment":case"whitespace":case"key-value-separator":case"escaped-value":case"line-break":r.push(e.substring(t.start,t.end));break;case"key-value":Array.prototype.unshift.apply(n,t.children),t.comment&&n.unshift({type:"literal",text:t.comment})}return r.join("")},this.save=function(e,t){if("function"==typeof e&&(t=e,e=r),!(e=e||r)){if(t)return t("Unknown path");throw new Error("Unknown path")}t?n.writeFile(e,this.toString(),t):n.writeFileSync(e,this.toString())}}function createEditor(){for(var e,t,r,i=Array.prototype.slice.call(arguments),o=0;o<i.length;o++){var a=i[o];e||"string"!=typeof a?t||"object"!=typeof a?r||"function"!=typeof a||(r=a):t=a:e=a}return t=t||{},e=e||t.path,r=r||t.callback,t.path=e,e?r?n.readFile(e,function(e,n){return e?r(e,null):(n=n.toString(),r(null,new Editor(n,t)))}):new Editor(n.readFileSync(e).toString(),t):new Editor(t)}function parse(e){return e=e.toString(),rangesToObject(stringToRanges(e),e)}function read(e,t){return t?n.readFile(e,function(e,r){return e?t(e,null):t(null,parse(r))}):parse(n.readFileSync(e))}r(46);var n=r(47),i=/\s/,o={"escaped-value":function(e,t){var r=t.charAt(e.start+1);return"t"===r?"\t":"r"===r?"\r":"n"===r?"\n":"f"===r?"\f":"u"!==r?r:String.fromCharCode(parseInt(t.substr(e.start+2,4),16))},"line-break":function(e,t){return""}},a=escapeMaker({" ":"\\ ","\n":"\\n",":":"\\:","=":"\\="}),s=escapeMaker({"\n":"\\n"});e.exports={parse:parse,read:read,createEditor:createEditor}},function(e,t){String.prototype.codePointAt||function(){"use strict";var e=function(){try{var e={},t=Object.defineProperty,r=t(e,e,e)&&t}catch(e){}return r}(),t=function(e){if(null==this)throw TypeError();var t=String(this),r=t.length,n=e?Number(e):0;if(n!=n&&(n=0),n<0||n>=r)return undefined;var i,o=t.charCodeAt(n);return o>=55296&&o<=56319&&r>n+1&&(i=t.charCodeAt(n+1))>=56320&&i<=57343?1024*(o-55296)+i-56320+65536:o};e?e(String.prototype,"codePointAt",{value:t,configurable:!0,writable:!0}):String.prototype.codePointAt=t}()},function(e,t){},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(49),i=function(e,t,r){return new n["default"](e,t,r)};t["default"]=i},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,o=r.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(n=o.next()).done;)a.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=o["return"])&&r.call(o)}finally{if(i)throw i.error}}return a},i=this&&this.__spreadArray||function(e,t,r){if(r||2===arguments.length)for(var n,i=0,o=t.length;i<o;i++)!n&&i in t||(n||(n=Array.prototype.slice.call(t,0,i)),n[i]=t[i]);return e.concat(n||Array.prototype.slice.call(t))};Object.defineProperty(t,"__esModule",{value:!0});var o=r(1),a=r(5),s=r(6),u=r(8),c=r(7),l=r(11),p=r(9),f=r(0),d=r(50),h=r(12),y=r(30),g=0,b=function(){function GssDesktopManager(e,t,r){var a=this;if(this._agm=e,this._requestCounter=0,this._state=h.STOPPED,this._providers=new Map,this._latestEntityTypes=new Map,this._entityTypesByProviderName=new Map,this._searchSubscriptions={},!this._agm){if("undefined"==typeof glue||!glue.agm)throw new Error("expected mandatory parameter agm");this._agm=glue.agm}var s="gss-dm_"+g.toString();g++;var u=r&&r.subLogger(s)||new c["default"](s,{debug:t.debug,trace:t.trace});u.consoleLevel&&u.publishLevel&&(t.debug?(u.consoleLevel("debug"),u.publishLevel("debug")):(u.consoleLevel("info"),u.publishLevel("info"))),this._logger=u,this._logger.log("Creating desktop manager instance ".concat(s));var l=new Map(Object.entries(t||{}));this._options=new Map(i(i([],n(h.defaultOptions),!1),n(l),!1)),this._initialProviders=this._options.get("providers"),this._initialProviders&&o.isArray(this._initialProviders)&&this._initialProviders.forEach(function(e){"agm"!==e.type.toLowerCase()&&a.add(e)}),this._listenForAgmProviders()}return Object.defineProperty(GssDesktopManager.prototype,"internals",{get:function(){return this._getInternals()},enumerable:!1,configurable:!0}),GssDesktopManager.prototype.add=function(e){"string"==typeof e.application&&"agm"===e.type.toLowerCase()&&this._logger.log('Will attempt to explicitly add AGM provider "'.concat(e.name,'" at application "').concat(e.application,'".')),this._addProvider(e)},GssDesktopManager.prototype.remove=function(e){var t=e.name,r=this._providers.get(t);if(!r)throw new Error('Provider "'.concat(t,'" does not exist'));this._providers["delete"](t),this._entityTypesByProviderName["delete"](t),this._publishProviders(),r.dispose()},GssDesktopManager.prototype.bulkRemove=function(){var e=this,t=(0,f.spread)(this._providers.keys()).filter(function(t){var r=e._providers.get(t);return"agm"!==r.config.get("type").toLowerCase()||!r.wasAutoDetected});this._logger.log("Bulk remove the following providers: [".concat(t,"]")),t.forEach(function(t){var r=e._providers.get(t);e._providers["delete"](t),e._entityTypesByProviderName["delete"](t),r.dispose()})},GssDesktopManager.prototype.start=function(e){var t=this;if(this._state===h.STARTED||this._checkIfAnotherDMisStarted())return p["default"].rejected(new Error("Already started"),e);var r=new p["default"];return this._createStreams().then(function(){t._state=h.STARTED,t._startMonitoringProviders(),r.resolve(r)})["catch"](function(e){t._logger.error("Failed to create GSS publisher streams ".concat(e)),t._stopMonitoringProviders(),r.reject(e)}),r.subscribe(e)},GssDesktopManager.prototype.stop=function(){if(this._state===h.STOPPED)throw new Error("Already stopped");this._stopMonitoringProviders(),this._closeEntityTypeStream(),this._closeSearchStream(),this._closeProvidersStream(),this._state=h.STOPPED},GssDesktopManager.prototype._addProvider=function(e,t){var r=this,o=e.name;if(this._providers.get(o)){var a='Provider "'.concat(o,'" already added');return void this._logger.error(a)}"string"===e.application&&this._isSimilarAgmProviderAlreadyAdded(e.application)&&(this._logger.log('Provider "'.concat(o,'" is being overridden at "').concat(e.application,'" will now be explicitly added.')),this.remove({name:e.application})),this._logger.log('Adding provider "'.concat(o,'": ').concat(JSON.stringify(e)));try{var s=new Map(Object.entries(e||{})),u=new Map(i(i([],n(this._options),!1),n(s),!1));u.set("wasAutoDetected",t);var c=(0,d.createGssProvider)(u,this._agm,this._logger);this._providers.set(o,c),this._publishProviders(),c.onEntities(function(e,t){r._onProviderEntityTypeAdded(e,t)}),c.onFailed(function(e,t){r._onProviderEntityTypeRemoved(e,t)}),this._state===h.STARTED&&c.start()}catch(e){this._logger.error('Unable to add provider "'.concat(o,'": ').concat(e.stack))}},GssDesktopManager.prototype._onProviderEntityTypeAdded=function(e,t){var r=t.name,n=this._entityTypesByProviderName.get(e);n||(n=new Map),n.set(r,t),this._entityTypesByProviderName.set(e,n),this._republishEntityTypes(),this._publishProviders()},GssDesktopManager.prototype._onProviderEntityTypeRemoved=function(e,t){var r=this._entityTypesByProviderName.get(e);if(!r||!t)return void(this._providers.get(e)&&(this._logger.debug('Removing provider "'.concat(e,'" because _onProviderEntityTypeRemoved')),this.remove({name:e})));var n=t.name;r["delete"](n),0===r.size?this._entityTypesByProviderName["delete"](e):this._entityTypesByProviderName.set(e,r),this._republishEntityTypes(),this._publishProviders()},GssDesktopManager.prototype._createStreams=function(){var e=this;return this._createEntityTypeStream().then(function(){return e._createSearchStream()}).then(function(){return e._createProvidersStream()})},GssDesktopManager.prototype._createSearchStream=function(){var e=this,t=new p["default"];return this._agm.createStream({name:l.SearchSubStreamName,description:"Search entities that can be served by the GDS.",accepts:"String entityType, Composite:{String name, String searchType, String value}[] filter, Int limit, String[] properties",returns:"Composite:{Int code, String message, Int mnemonic} error, Composite:{Composite:{Composite:{String name, Composite:{Bool bool, Bool[] bools, Composite:{String recursiveNotSupportedByAgm} composite, Composite:{String recursiveNotSupportedByAgm} composites, Double double, Double[] doubles, Int int, Int[] ints, Int long, Int[] longs, String string, String[] strings, String timestamp, String[] timestamps} value}[] properties}[] data, Composite:{String expiresAt, Int expiresIn} expiration, Bool isFromCache, Bool isLast, String provider} result"},{subscriptionRequestHandler:function(t){e._onSearchSubscriptionRequest(t)},subscriptionAddedHandler:function(t){e._onSearchSubscriptionAdded(t)},subscriptionRemovedHandler:function(t){e._onSearchSubscriptionRemoved(t)}}).then(function(r){e._searchStream=r,e._logger.debug('Stream "'.concat(l.SearchSubStreamName,'" created successfully')),t.resolve(t)})["catch"](function(r){e._searchStream=undefined,t.reject(r)}),t.promise},GssDesktopManager.prototype._createProvidersStream=function(){var e=this,t=new p["default"];return this._agm.createStream({name:l.ProvidersSubStreamName,description:"Returns information about the providers registered in the GSS.",accepts:"",returns:"Composite:{Int code, String message, Int mnemonic} error, Composite:{Composite:{String name, Composite:{String description, String displayName, Bool isArray, Composite:{String name, String value}[] metaData, String name, String searchType, String type}[] properties}[] entities, String name, String type}[] result"},{subscriptionAddedHandler:function(t){e._onProvidersSubscriptionAdded(t)}}).then(function(r){e._providersStream=r,e._logger.debug('Stream "'.concat(l.ProvidersSubStreamName,'" created successfully')),t.resolve(t)})["catch"](function(r){e._providersStream=undefined,t.reject(r)}),t.promise},GssDesktopManager.prototype._onProvidersSubscriptionAdded=function(e){var t=this._convertProviders();e.push({result:t})},GssDesktopManager.prototype._closeProvidersStream=function(){this._providersStream&&(this._providersStream.close(),this._providersStream=undefined)},GssDesktopManager.prototype._onSearchSubscriptionRequest=function(e){var t=e.instance.application+" - "+(0,f.str)(e.arguments);try{var r=(0,f.parseQueryFromRequest)(e.arguments);if(r.filter.filter(function(e){return!e.searchType||"None"!==e.searchType.name}).length<=0)throw new Error("There are no valid filters.");var n=this._latestEntityTypes.get(r.entityTypeName);if(!n)throw new Error("Unsupported entity type ".concat(r.entityTypeName));(0,f.validateQuery)(r,n),this._logger.debug("Accepting search request from ".concat(t)),e.accept()}catch(r){this._logger.error("Rejecting search request from ".concat(t,": ").concat(r.stack)),e.reject(r.message)}},GssDesktopManager.prototype._onSearchSubscriptionAdded=function(e){var t=this,r="reqId_"+this._requestCounter.toString();this._requestCounter++;var n=e.instance.application+" - "+(0,f.str)(e.arguments);this._searchSubscriptions[n]||(this._searchSubscriptions[n]=e),this._logger.debug("".concat(r,": Search subscriber added ").concat(e.instance.application));try{var i=(0,f.parseQueryFromRequest)(e.arguments),o=i.entityTypeName,a=i.filter.slice(),s=i.providers,u=Array.isArray(s)&&s.length>0,c={};if(this._entityTypesByProviderName.forEach(function(e,r){if((!u||s.includes(r))&&e.has(o)){var n=e.get(o).properties.values();a.every(function(e){return-1!==e.name.indexOf(".")?t._nestedEntityTypeName(e,n):Boolean(n.find(function(r){return t._compareSearchType(e,r)}))})&&(c[r]=a)}}),0===Object.keys(c).length){var l={provider:"N/A"};return this._logger.warn("".concat(r,': Pushing error "').concat(l.provider,'". No available provider could fulfill the query.')),void e.push(l)}Object.keys(c).forEach(function(n){var a=t._providers.get(n),s=c[n],u={entityType:o,properties:i.properties,limit:i.limit,filter:s.map(function(e){return{name:e.name,value:e.value,searchType:e.searchType&&e.searchType.name||"Both"}})};a.search(u,function(i){var o=i.result,a=i.error;(a||o&&o.isLast)&&(t._logger.debug("".concat(r,': Got last result from "').concat(n,'".')),delete c[n]);var s=Object.keys(c);a?(t._logger.warn("".concat(r,': Pushing error from "').concat(n,'": "').concat(a.message,'"')),e.push({error:{message:a.message},pendingProviders:s,provider:n})):o&&(i.provider=n,i.pendingProviders=s,s.length<=0&&o.isLast&&(i.isLastForQuery=!0),t._logger.debug("".concat(r,': Pushing data from provider "').concat(n,'" with ').concat(o&&o.data&&o.data.length," entities.")),e.push(i)),0===s.length&&(t._logger.debug("".concat(r,": Query is done. Closing the client's subscription.")),e.close())})})}catch(t){this._logger.error("".concat(r,": Search failed: ").concat(t.stack)),e.push({error:{message:t.message}})}},GssDesktopManager.prototype._onSearchSubscriptionRemoved=function(e){var t=e.instance.application+" - "+(0,f.str)(e.arguments);delete this._searchSubscriptions[t],this._logger.debug('Search subscriber removed "'.concat(e.instance.application,'"'))},GssDesktopManager.prototype._closeSearchStream=function(){this._searchStream&&(this._searchStream.close(),this._searchStream=undefined)},GssDesktopManager.prototype._createEntityTypeStream=function(){var e=this,t=new p["default"];return this._agm.createStream({name:l.EntityTypesSubStreamName,description:"Returns the entities that can be served by the GDS.",returns:"Composite:{Int code, String message, Int mnemonic} error, Composite:{String name, Composite:{String description, String displayName, Bool isArray, Composite:{String name, String value}[] metaData, String name, String searchType, String type}[] properties}[] result"},{subscriptionRequestHandler:function(t){e._onEntityTypeSubscriptionRequest(t)},subscriptionAddedHandler:function(t){e._onEntityTypeSubscriptionAdded(t)},subscriptionRemovedHandler:function(t){e._onEntityTypeSubscriptionRemoved(t)}}).then(function(r){e._entityTypeStream=r,e._logger.debug('Stream "'.concat(l.EntityTypesSubStreamName,'" created successfully')),t.resolve(t)})["catch"](function(r){e._logger.error('Failed to register "'.concat(l.EntityTypesSubStreamName,'"')),e._entityTypeStream=undefined,t.reject(r)}),t.promise},GssDesktopManager.prototype._onEntityTypeSubscriptionRequest=function(e){this._logger.debug('Accepting entity types request from "'.concat(e.instance.application,'"')),e.accept()},GssDesktopManager.prototype._onEntityTypeSubscriptionAdded=function(e){this._logger.debug('Entity types subscriber added "'.concat(e.instance.application,'"'));try{var t=this._convertEntityTypes(this._latestEntityTypes);e.push(t)}catch(e){this._logger.error(e)}},GssDesktopManager.prototype._onEntityTypeSubscriptionRemoved=function(e){this._logger.debug('Entity types subscriber removed "'.concat(e.instance.application,'"'))},GssDesktopManager.prototype._closeEntityTypeStream=function(){this._entityTypeStream&&(this._entityTypeStream.close(),this._entityTypeStream=undefined)},GssDesktopManager.prototype._republishEntityTypes=function(){try{this._mergeEntityTypes();var e=this._convertEntityTypes(this._latestEntityTypes),t=[];try{t=e.result.map(function(e){return e.name})}catch(e){this._logger.warn("Failed to map entityTypeList: ".concat(e.message))}this._logger.log("Publishing entity types [".concat(t,"]")),this._logger.debug((0,f.str)(e,!0)),this._entityTypeStream.push(e)}catch(e){this._logger.error("Failed to republish entity types: ".concat(e.stack))}},GssDesktopManager.prototype._startMonitoringProviders=function(){this._logger.info("Starting providers [".concat((0,f.spread)(this._providers.keys()).join(", "),"]...")),this._providers.forEach(function(e){return e.start()})},GssDesktopManager.prototype._stopMonitoringProviders=function(){this._logger.info("Stopping providers [".concat((0,f.spread)(this._providers.keys()).join(", "),"]...")),this._providers.forEach(function(e){return e.stop()})},GssDesktopManager.prototype._publishProviders=function(){if(this._providersStream){var e=this._convertProviders();this._providersStream.push({result:e})}},GssDesktopManager.prototype._checkIfAnotherDMisStarted=function(){return 0!==this._agm.methods().filter(function(e){return e.name===l.EntityTypesSubStreamName||e.name===l.SearchSubStreamName||e.name===l.ProvidersSubStreamName}).length},GssDesktopManager.prototype._nestedEntityTypeName=function(e,t){for(var r,n=e.name.split(".");0!==n.length;)r=r?r.properties.values().find(function(e){return e.name===n[0]}):t.find(function(e){return e.name===n[0]}),n.splice(0,1);return this._compareSearchType(new u["default"](r.name,e.value,e.searchType),r)},GssDesktopManager.prototype._compareSearchType=function(e,t){return"ANY"===e.name||t.name===e.name&&("Both"===t.searchType.name||"None"!==t.searchType.name&&(!e.searchType||("Partial"===t.searchType.name&&"Both"===e.searchType.name||t.searchType.name===e.searchType.name)))},GssDesktopManager.prototype._convertEntityTypes=function(e){return{result:(0,f.spread)(e.values()).map(function(e){return{name:e.name,properties:(0,f.convertProperties)(e.properties)}})}},GssDesktopManager.prototype._convertProviders=function(){var e=this;return(0,f.spread)(this._providers.values()).map(function(t){var r=e._entityTypesByProviderName.get(t.config.get("name"))||new Map,n=e._convertEntityTypes(r).result;return{name:t.config.get("name"),type:t.config.get("type"),entities:n}})},GssDesktopManager.prototype._mergeEntityTypes=function(){var e=this,t={};this._entityTypesByProviderName.forEach(function(r,n){r.forEach(function(r,n){if(t[n]){var i=t[n],o=r.properties.values(),a=(0,y.merge)(i,o,e._logger);t[n]=Object.keys(a).map(function(e){return a[e]})}else t[n]=r.properties.values()})}),this._latestEntityTypes.clear(),Object.keys(t).forEach(function(r){e._latestEntityTypes.set(r,new a["default"](r,new(s["default"].bind.apply(s["default"],i([void 0],n(t[r]),!1)))))})},GssDesktopManager.prototype._listenForAgmProviders=function(){var e=this;this._logger.log("Listening for auto discoverable search provider..."),this._agm.serverMethodAdded(function(t){if(t.method.name===l.EntityTypesPubStreamName&&e._canAddAutomatically(t)){e._logger.debug("AGM server is provider: ".concat((0,f.str)(t)));try{e._addProvider({name:t.server.application,type:"agm",application:t.server.application},!0)}catch(t){e._logger.debug("Did not add agm provider: ".concat(t.message))}}})},GssDesktopManager.prototype._canAddAutomatically=function(e){var t=e.server,r=t.application;return Boolean(this._options.get("autoDiscoverSearchProviders"))&&!this._isSimilarAgmProviderAlreadyAdded(r)},GssDesktopManager.prototype._isSimilarAgmProviderAlreadyAdded=function(e){return(0,f.spread)(this._providers.values()).filter(function(t){return"agm"===t.config.get("type").toLowerCase()&&t.config.get("application")===e}).length>0},GssDesktopManager.prototype._getInternals=function(){var e=this;return{get self(){return e},logger:e._logger,logLevel:{is:function(){return"console=_".concat(e._logger.consoleLevel(),"_, publish(file)=_").concat(e._logger.publishLevel(),"_")},info:function(){return e._logger.consoleLevel("info"),e._logger.publishLevel("info"),"info"},debug:function(){return e._logger.consoleLevel("debug"),e._logger.publishLevel("debug"),"debug"},trace:function(){return e._logger.consoleLevel("trace"),e._logger.publishLevel("trace"),"trace"}},get providers(){return e._providers},get entityTypes(){return e._latestEntityTypes},get entityTypesByProviderName(){return e._entityTypesByProviderName},get state(){return e._state},dump:function(){var t=(0,f.spread)(e._latestEntityTypes.entries()).reduce(function(e,t){var r=t[1];return e[t[0]]={name:r.name,properties:(0,f.convertProperties)(r.properties)},e},{}),r=JSON.stringify(t,null,2),n=e._convertProviders(),i=n.map(function(e){return'"'.concat(e.name,'"(').concat(e.type.toUpperCase(),")")}).join(", "),o=">> === dumpstart ===\n\n"+">> Log Levels: console=_".concat(e._logger.consoleLevel(),"_, publish(file)=_").concat(e._logger.publishLevel(),"_\n\n")+">> Config options (as applied over defaults) ".concat((0,f.mapToObject)(e._options)," \n\n")+'>> State is "'.concat(e._state,'"\n\n')+">> Provider list is: [".concat(i,"] \n\n")+">> Merged entityTypes are: \n"+r+"\n\n>> Provider details are: \n"+JSON.stringify(n,null,2)+"\n\n>> === dumpend ===";e._logger.log(o)},_convertProviders:function(){return e._convertProviders()},_convertEntityTypes:function(t){return e._convertEntityTypes(t)},options:e._options}},GssDesktopManager}();t["default"]=b},function(e,t,r){"use strict";function createGssProvider(e,t,r){var o=e.get("type"),a="string"==typeof o?o.toLowerCase():undefined;if("rest"===a)return new n["default"](e,undefined,r);if("agm"===a)return new i["default"](e,t,r);throw new Error('Unsupported provider type "'.concat(o,'". Supported types are: [rest, agm]'))}Object.defineProperty(t,"__esModule",{value:!0}),t.createGssProvider=void 0;var n=r(51),i=r(72);t.createGssProvider=createGssProvider},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(1),i=r(52),o=r(0),a=r(7),s=r(12),u=r(29),c=r(30),l=r(31),p=0,f=function(){function RestGssProvider(e,t,r){if(this._config=e,this._agm=t,this._pollState=null,this._entityTypes=new Map,!this._config.get("url"))throw new Error('Config property "url" is mandatory for gss REST providers.');var n="rest-prov_"+p.toString();p++,this._logger=r&&r.subLogger(n)||new a["default"](n,{debug:this._config.get("debug"),trace:this._config.get("trace")}),this._logger.log("Creating rest provider instance: ".concat(JSON.stringify((0,o.mapToObject)(this._config),null,2))),this._loadEntitiesOnce=!1!==this._config.get("loadEntitiesOnce"),this._callbackRegistry=(0,l["default"])(),this._state=u.ProviderState.Stopped}return Object.defineProperty(RestGssProvider.prototype,"config",{get:function(){return this._config},enumerable:!1,configurable:!0}),Object.defineProperty(RestGssProvider.prototype,"state",{get:function(){return this._state},enumerable:!1,configurable:!0}),Object.defineProperty(RestGssProvider.prototype,"wasAutoDetected",{get:function(){return!1},enumerable:!1,configurable:!0}),RestGssProvider.prototype.start=function(){var e=this;this._state=u.ProviderState.Failed;var t=this._config.get("pollIntervalInMillis")||5e3;this._logger.log("Starting to poll ".concat(this._config.get("url"),"/entityTypes every ").concat(t,"ms.")),this._timerId=window.setInterval(function(){return e._onPollTimerTick()},t),this._onPollTimerTick()},RestGssProvider.prototype.stop=function(){this._logger.log("Stopping."),clearInterval(this._timerId),this._state=u.ProviderState.Stopped},RestGssProvider.prototype.dispose=function(){this._callbackRegistry.clear(),this.stop()},RestGssProvider.prototype.search=function(e,t){this._fetch("/search",e).then(function(e){e.isLast=!0,t({result:e})})["catch"](function(e){t({error:e})})},RestGssProvider.prototype.onEntities=function(e){return this._logger.debug("Registering callbacks for ".concat(s.ON_ENTITIES,".")),this._callbackRegistry.add(s.ON_ENTITIES,e)},RestGssProvider.prototype.onFailed=function(e){return this._logger.debug("Registering callbacks for ".concat(s.ON_FAILED,".")),this._callbackRegistry.add(s.ON_FAILED,e)},RestGssProvider.prototype._onPollTimerTick=function(){var e=this;this._fetchInProgress||(this._fetchInProgress=!0);var t=this._pollState;this._fetchEntityTypes().then(function(r){e._fetchInProgress=!1,e._logger.trace("Poll Event - Successfully fetched entityTypes."),e._pollState=s.STATE_OKAY,t===s.STATE_FAILED?e._logger.debug('Recovered and successfully fetched entityTypes for "'.concat(e._config.get("name"),'".')):t||e._logger.debug('Retreived initial entityTypes for "'.concat(e._config.get("name"),'".')),e._loadEntitiesOnce&&(e._logger.debug("Will not poll anymore, clearing interval."),clearInterval(e._timerId)),e._updateEntityTypes(r)})["catch"](function(r){e._fetchInProgress=!1,e._logger.trace("Poll Event - Failed to fetch entityTypes."),e._pollState=s.STATE_FAILED,t!==s.STATE_FAILED&&(e._logger.warn("Failed to fetched entityTypes."),e._handleEntityTypesError(r))})},RestGssProvider.prototype._fetchEntityTypes=function(){return this._fetch("/entityTypes")},RestGssProvider.prototype._fetch=function(e,t){var r=this,o=this._config.get("auth");return new Promise(function(a,u){var c=r._config.get("url")+e,l=(0,n.assign)(t?{url:c,auth:o,data:t}:{url:c,auth:o},s.defaultFetchOptions);r._logger.trace("Fetching ".concat(e,"...\n").concat(JSON.stringify(l,null,2))),(0,i["default"])(l).then(function(e){a(e.data)})["catch"](function(e){u(e)})})},RestGssProvider.prototype._updateEntityTypes=function(e){var t=this,r=(0,o.generalConvertEntityTypes)({result:e},this._logger),n=new Map(r.values().map(function(e){return[e.name,e]}));(0,c.sameEntityTypes)(this._entityTypes,n)||(this._entityTypes=n,this._state=u.ProviderState.Connected,this._logger.debug("Entity types for this provider have changed."),this._entityTypes.forEach(function(e){t._callbackRegistry.execute(s.ON_ENTITIES,t._config.get("name"),e)}))},RestGssProvider.prototype._handleEntityTypesError=function(e){var t=this;this._state=u.ProviderState.Failed,this._logger.error("Failed to get entity types for REST provider ".concat(this._config.get("name")," at ").concat(this._config.get("url"),": ").concat(e.stack)),this._entityTypes.forEach(function(e){t._callbackRegistry.execute(s.ON_FAILED,t._config.get("name"),e)}),this._entityTypes=new Map},RestGssProvider}();t["default"]=f},function(e,t,r){e.exports=r(53)},function(e,t,r){"use strict";function createInstance(e){var t=new o(e),r=i(o.prototype.request,t);return n.extend(r,o.prototype,t),n.extend(r,t),r}var n=r(2),i=r(24),o=r(55),a=r(15),s=createInstance(a);s.Axios=o,s.create=function(e){return createInstance(n.merge(a,e))},s.Cancel=r(28),s.CancelToken=r(70),s.isCancel=r(27),s.all=function(e){return Promise.all(e)},s.spread=r(71),e.exports=s,e.exports["default"]=s},function(e,t){function isBuffer(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}function isSlowBuffer(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&isBuffer(e.slice(0,0))}e.exports=function(e){return null!=e&&(isBuffer(e)||isSlowBuffer(e)||!!e._isBuffer)}},function(e,t,r){"use strict";function Axios(e){this.defaults=e,this.interceptors={request:new o,response:new o}}var n=r(15),i=r(2),o=r(65),a=r(66),s=r(68),u=r(69);Axios.prototype.request=function(e){"string"==typeof e&&(e=i.merge({url:arguments[0]},arguments[1])),e=i.merge(n,this.defaults,{method:"get"},e),e.method=e.method.toLowerCase(),e.baseURL&&!s(e.url)&&(e.url=u(e.baseURL,e.url));var t=[a,undefined],r=Promise.resolve(e);for(this.interceptors.request.forEach(function(e){t.unshift(e.fulfilled,e.rejected)}),this.interceptors.response.forEach(function(e){t.push(e.fulfilled,e.rejected)});t.length;)r=r.then(t.shift(),t.shift());return r},i.forEach(["delete","get","head","options"],function(e){Axios.prototype[e]=function(t,r){return this.request(i.merge(r||{},{method:e,url:t}))}}),i.forEach(["post","put","patch"],function(e){Axios.prototype[e]=function(t,r,n){return this.request(i.merge(n||{},{method:e,url:t,data:r}))}}),e.exports=Axios},function(e,t){function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(e){if(r===setTimeout)return setTimeout(e,0);if((r===defaultSetTimout||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout)return clearTimeout(e);if((n===defaultClearTimeout||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}function cleanUpNextTick(){s&&o&&(s=!1,o.length?a=o.concat(a):u=-1,a.length&&drainQueue())}function drainQueue(){if(!s){var e=runTimeout(cleanUpNextTick);s=!0;for(var t=a.length;t;){for(o=a,a=[];++u<t;)o&&o[u].run();u=-1,t=a.length}o=null,s=!1,runClearTimeout(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}var r,n,i=e.exports={};!function(){try{r="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){r=defaultSetTimout}try{n="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){n=defaultClearTimeout}}();var o,a=[],s=!1,u=-1;i.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];a.push(new Item(e,t)),1!==a.length||s||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=noop,i.addListener=noop,i.once=noop,i.off=noop,i.removeListener=noop,i.removeAllListeners=noop,i.emit=noop,i.prependListener=noop,i.prependOnceListener=noop,i.listeners=function(e){return[]},i.binding=function(e){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(e){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(e,t,r){"use strict";var n=r(2);e.exports=function(e,t){n.forEach(e,function(r,n){n!==t&&n.toUpperCase()===t.toUpperCase()&&(e[t]=r,delete e[n])})}},function(e,t,r){"use strict";var n=r(26);e.exports=function(e,t,r){var i=r.config.validateStatus;r.status&&i&&!i(r.status)?t(n("Request failed with status code "+r.status,r.config,null,r.request,r)):e(r)}},function(e,t,r){"use strict";e.exports=function(e,t,r,n,i){return e.config=t,r&&(e.code=r),e.request=n,e.response=i,e}},function(e,t,r){"use strict";function encode(e){return encodeURIComponent(e).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}var n=r(2);e.exports=function(e,t,r){if(!t)return e;var i;if(r)i=r(t);else if(n.isURLSearchParams(t))i=t.toString();else{var o=[];n.forEach(t,function(e,t){null!==e&&void 0!==e&&(n.isArray(e)&&(t+="[]"),n.isArray(e)||(e=[e]),n.forEach(e,function(e){n.isDate(e)?e=e.toISOString():n.isObject(e)&&(e=JSON.stringify(e)),o.push(encode(t)+"="+encode(e))}))}),i=o.join("&")}return i&&(e+=(-1===e.indexOf("?")?"?":"&")+i),e}},function(e,t,r){"use strict";var n=r(2);e.exports=function(e){var t,r,i,o={};return e?(n.forEach(e.split("\n"),function(e){i=e.indexOf(":"),t=n.trim(e.substr(0,i)).toLowerCase(),r=n.trim(e.substr(i+1)),t&&(o[t]=o[t]?o[t]+", "+r:r)}),o):o}},function(e,t,r){"use strict";var n=r(2);e.exports=n.isStandardBrowserEnv()?function(){function resolveURL(e){var n=e;return t&&(r.setAttribute("href",n),n=r.href),r.setAttribute("href",n),{href:r.href,protocol:r.protocol?r.protocol.replace(/:$/,""):"",host:r.host,search:r.search?r.search.replace(/^\?/,""):"",hash:r.hash?r.hash.replace(/^#/,""):"",hostname:r.hostname,port:r.port,pathname:"/"===r.pathname.charAt(0)?r.pathname:"/"+r.pathname}}var e,t=/(msie|trident)/i.test(navigator.userAgent),r=document.createElement("a");return e=resolveURL(window.location.href),function(t){var r=n.isString(t)?resolveURL(t):t;return r.protocol===e.protocol&&r.host===e.host}}():function(){return function(){return!0}}()},function(e,t,r){"use strict";function E(){this.message="String contains an invalid character"}function btoa(e){for(var t,r,i=String(e),o="",a=0,s=n;i.charAt(0|a)||(s="=",a%1);o+=s.charAt(63&t>>8-a%1*8)){if((r=i.charCodeAt(a+=.75))>255)throw new E;t=t<<8|r}return o}var n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";E.prototype=new Error,E.prototype.code=5,E.prototype.name="InvalidCharacterError",e.exports=btoa},function(e,t,r){"use strict";var n=r(2);e.exports=n.isStandardBrowserEnv()?function(){return{write:function(e,t,r,i,o,a){var s=[];s.push(e+"="+encodeURIComponent(t)),n.isNumber(r)&&s.push("expires="+new Date(r).toGMTString()),n.isString(i)&&s.push("path="+i),n.isString(o)&&s.push("domain="+o),!0===a&&s.push("secure"),document.cookie=s.join("; ")},read:function(e){var t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}()},function(e,t,r){"use strict";function InterceptorManager(){this.handlers=[]}var n=r(2);InterceptorManager.prototype.use=function(e,t){return this.handlers.push({fulfilled:e,rejected:t}),this.handlers.length-1},InterceptorManager.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null)},InterceptorManager.prototype.forEach=function(e){n.forEach(this.handlers,function(t){null!==t&&e(t)})},e.exports=InterceptorManager},function(e,t,r){"use strict";function throwIfCancellationRequested(e){e.cancelToken&&e.cancelToken.throwIfRequested()}var n=r(2),i=r(67),o=r(27),a=r(15);e.exports=function(e){return throwIfCancellationRequested(e),e.headers=e.headers||{},e.data=i(e.data,e.headers,e.transformRequest),e.headers=n.merge(e.headers.common||{},e.headers[e.method]||{},e.headers||{}),n.forEach(["delete","get","head","post","put","patch","common"],function(t){delete e.headers[t]}),(e.adapter||a.adapter)(e).then(function(t){return throwIfCancellationRequested(e),t.data=i(t.data,t.headers,e.transformResponse),t},function(t){return o(t)||(throwIfCancellationRequested(e),t&&t.response&&(t.response.data=i(t.response.data,t.response.headers,e.transformResponse))),Promise.reject(t)})}},function(e,t,r){"use strict";var n=r(2);e.exports=function(e,t,r){return n.forEach(r,function(r){e=r(e,t)}),e}},function(e,t,r){"use strict";e.exports=function(e){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e)}},function(e,t,r){"use strict";e.exports=function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}},function(e,t,r){"use strict";function CancelToken(e){if("function"!=typeof e)throw new TypeError("executor must be a function.");var t;this.promise=new Promise(function(e){t=e});var r=this;e(function(e){r.reason||(r.reason=new n(e),t(r.reason))})}var n=r(28);CancelToken.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},CancelToken.source=function(){var e;return{token:new CancelToken(function(t){e=t}),cancel:e}},e.exports=CancelToken},function(e,t,r){"use strict";e.exports=function(e){return function(t){return e.apply(null,t)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(1),i=r(11),o=r(29),a=r(0),s=r(7),u=r(31),c=r(12),l=0,p=function(){function AgmGssProvider(e,t,r){if(this._config=e,this._agm=t,this._entityTypes=new Map,this._entityTypesSubscription=null,!this._config.get("application"))throw new Error('Config property "application" is mandatory for gss AGM providers.');var n="agm-prov_"+l.toString();l++,this._logger=r&&r.subLogger(n)||new s["default"](n,{debug:this._config.get("debug"),trace:this._config.get("trace")}),this._logger.log("Creating agm provider instance: ".concat(JSON.stringify((0,a.mapToObject)(this._config),null,2))),this._callbackRegistry=(0,u["default"])()}return Object.defineProperty(AgmGssProvider.prototype,"config",{get:function(){return this._config},enumerable:!1,configurable:!0}),Object.defineProperty(AgmGssProvider.prototype,"state",{get:function(){return this._state},enumerable:!1,configurable:!0}),Object.defineProperty(AgmGssProvider.prototype,"wasAutoDetected",{get:function(){return Boolean(this._config.get("wasAutoDetected"))},enumerable:!1,configurable:!0}),AgmGssProvider.prototype.start=function(){this._logger.log('Starting agm gss provider "'.concat(this._config.get("name"),'". Listening for the server.')),this._listenForServer()},AgmGssProvider.prototype.stop=function(){this._logger.log('Stopping agm gss provider "'.concat(this._config.get("name"),'".')),this._unlistenFunc&&(this._logger.debug("UN-listening for the server."),this._unlistenFunc()),this._entityTypesSubscription&&(this._logger.debug("Closing entityTypes subscription."),this._entityTypesSubscription.close(),this._entityTypesSubscription=null),this._state=o.ProviderState.Stopped},AgmGssProvider.prototype.dispose=function(){this._logger.log('Disposing "'.concat(this._config.get("name"),'"')),this._callbackRegistry.clear(),this.stop()},AgmGssProvider.prototype.search=function(e,t){var r=this;this._agm.subscribe(i.SearchPubStreamName,{target:{application:this._config.get("application")},arguments:e,waitTimeoutMs:1e4}).then(function(e){e.onData(function(n){r._handleSearchStreamOnData(n,t,e)}),e.onClosed(function(e){r._logger.debug("".concat(i.SearchPubStreamName," was closed - ").concat((0,a.str)(e)))}),e.onFailed(function(e){r._logger.debug("".concat(i.SearchPubStreamName," subscription unexpectedly failed - ").concat((0,a.str)(e)))})})["catch"](function(e){r._logger.debug("".concat(i.SearchPubStreamName," subscription unexpectedly failed - ").concat((0,a.str)(e)))})},AgmGssProvider.prototype.onEntities=function(e){return this._logger.debug("Registering callbacks for ".concat(c.ON_ENTITIES,".")),this._callbackRegistry.add(c.ON_ENTITIES,e)},AgmGssProvider.prototype.onFailed=function(e){return this._logger.debug("Registering callbacks for ".concat(c.ON_FAILED,".")),this._callbackRegistry.add(c.ON_FAILED,e)},AgmGssProvider.prototype._listenForServer=function(){var e=this;this._unlistenFunc=this._agm.serverMethodAdded(function(t){var r=t.server,n=t.method;r.application===e._config.get("application")&&n.name===i.EntityTypesPubStreamName&&e._establishConnection()})},AgmGssProvider.prototype._establishConnection=function(){var e=this;if(this._entityTypesSubscription)return void this._logger.debug("Existing entityTypes subscription. No need to resubscribe.");this._logger.debug("Subscribing for entityTypes."),this._agm.subscribe(i.EntityTypesPubStreamName,{target:{application:this._config.get("application")},waitTimeoutMs:1e4}).then(function(t){e._logger.debug("Successfully subscribed for entityTypes."),t.onData(function(t){e._entityTypesStreamOnData(t)}),t.onClosed(function(t){e._entityTypesStreamOnClosed(t)}),t.onFailed(function(t){e._entityTypesStreamOnFailed(t)}),e._entityTypesSubscription=t,e._logger.log('Started agm gss provider "'.concat(e._config.get("name"),'"'))})["catch"](function(t){e._logger.error("Failed to start agm gss provider ".concat(e._config.get("name")," due: ").concat((0,a.str)(t))),e._entityTypesSubscription=null,e._handleEntityTypesError("Failed to subscribe to entityTypes stream for provider - ".concat((0,a.str)(t)))})},AgmGssProvider.prototype._entityTypesStreamOnData=function(e){var t=e.data;this._logger.debug('Received entityTypes data from "'.concat(this._config.get("name"),'".')),console.log("data",t);var r;try{r=(0,a.generalConvertEntityTypes)(t,this._logger),console.log("convertedEntityTypes",r),this._updateEntityTypes(r)}catch(e){this._logger.error("Failed to handle entity types stream data - message: ".concat(e," stack: ").concat(e.stack)),this._updateEntityTypes(r)}},AgmGssProvider.prototype._updateEntityTypes=function(e){var t=this;this._state=o.ProviderState.Connected;var r=e.values().map(function(e){return[e.name,e]});this._entityTypes=new Map(r),e.forEach(function(e){t._callbackRegistry.execute(c.ON_ENTITIES,t._config.get("name"),e)})},AgmGssProvider.prototype._entityTypesStreamOnClosed=function(e,t){this._handleEntityTypesError("".concat(i.EntityTypesPubStreamName," subscription was closed - ").concat((0,a.str)(e))),this._entityTypesSubscription=null},AgmGssProvider.prototype._entityTypesStreamOnFailed=function(e,t){this._handleEntityTypesError("".concat(i.EntityTypesPubStreamName," subscription unexpectedly failed - ").concat((0,a.str)(e))),this._entityTypesSubscription=null},AgmGssProvider.prototype._handleSearchStreamOnData=function(e,t,r){var i="object"==typeof(0,n.get)(e,"data.error"),o="object"==typeof(0,n.get)(e,"data.result"),a=i||!0===(0,n.get)(e,"data.result.isLast",!1),s=i?"error":o?"data":"EMPTY",u="Received ".concat(s,' response from the server "').concat(this._config.get("name"),'".');"EMPTY"===s?this._logger.warn(u+" This may cause the search to hang in client."):this._logger.debug(u),a&&(this._logger.debug("Expecting no more responses. Closing search subscription to provider."),r.close());try{t(e.data)}catch(e){this._logger.error("Search callback failed - message: ".concat(e," stack: ").concat(e.stack))}},AgmGssProvider.prototype._handleEntityTypesError=function(e){var t=this;this._logger.error("Handling entityTypes Error: ".concat(e)),0===this._entityTypes.size?this._callbackRegistry.execute(c.ON_FAILED,this._config.get("name")):this._entityTypes.forEach(function(e){t._callbackRegistry.execute(c.ON_FAILED,t._config.get("name"),e)})},AgmGssProvider}();t["default"]=p},function(e,t){e.exports={name:"@glue42/gss",version:"1.46.3",description:"Glue42 Search Service (GSS) JavaScript API",main:"dist/node/@glue42/gss.min.js",browser:"dist/web/@glue42/gss.min.js",keywords:["glue","glue42","desktop","interop","context"],author:{name:"Glue42",url:"http://www.glue42.com"},homepage:"https://glue42.com/",license:"SEE LICENSE in LICENSE",types:"./types/index.d.ts",devDependencies:{"@glue42/desktop":"^5.0.1","@types/lodash":"^4.14.150","@types/uuid":"^3.4.3","babel-core":"^6.26.0","babel-loader":"^7.1.2","babel-plugin-lodash":"^3.3.2","babel-preset-env":"^1.6.1",chai:"^3.5.0",esdoc:"^1.1.0",fs:"0.0.1-security",mocha:"^7.1.2",onchange:"^4.1.0",shelljs:"^0.8.2","tick42-webpack-config":"^4.1.6",tslint:"^5.11.0",typedoc:"^0.17.6",typescript:"^4.9.5",watchify:"^3.9.0",webpack:"^3.11.0","webpack-bundle-analyzer":"^2.10.0"},scripts:{"faux-fs":"node ./scripts/faux-fs.js",test:"mocha --require babel-core/register --recursive --full-trace --timeout 500",clean:"node ./scripts/clean.js",tslint:"tslint -t codeFrame ./src/**.ts","pre:build":"npm run clean && npm run faux-fs && npm run tslint && tsc && set NODE_ENV=development","file-versionify":"node ./scripts/file-versionify.js","build:dev":"npm run pre:build && set NODE_ENV=development && webpack && npm run file-versionify && npm run host-app","build:prod":"npm run pre:build && set NODE_ENV=development && webpack && set NODE_ENV=production && webpack && npm run file-versionify && npm run host-app","host-app":"node ./scripts/host-app.js",prepublishOnly:"npm run build:prod && npm run test","generate-docs":"glue-js-documentation-builder build-reference --project gss --modules ./types/index.d.ts,node_modules/tick42-glue-core/glue.d.ts -d ./dist/docs","watch-docs":'onchange "types/index.d.ts" -i -- npm run generate-docs',serve:"http-server ./dist-host-app -p 8047 -a 127.0.0.1"},dependencies:{axios:"^0.16.1","callback-registry":"^2.3.3",lodash:"^4.6.1","properties-parser":"^0.3.1",uuid:"^3.2.1"}}}])});
//# sourceMappingURL=gss.min.js.map

/***/ }),

/***/ "./node_modules/@glue42/web/dist/web.es.js":
/*!*************************************************!*\
  !*** ./node_modules/@glue42/web/dist/web.es.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, Buffer, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return glueWebFactory; });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest$1(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter$1(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const defaultConfig = {
    logger: "info",
    gateway: { webPlatform: {} },
    libraries: [],
    exposeGlue: true
};
const parseConfig = (config) => {
    var _a, _b, _c;
    const isPlatformInternal = !!((_b = (_a = config === null || config === void 0 ? void 0 : config.gateway) === null || _a === void 0 ? void 0 : _a.webPlatform) === null || _b === void 0 ? void 0 : _b.port);
    const combined = Object.assign({}, defaultConfig, config, { isPlatformInternal });
    if (combined.systemLogger) {
        combined.logger = (_c = combined.systemLogger.level) !== null && _c !== void 0 ? _c : "info";
    }
    return combined;
};

const checkSingleton = () => {
    const glue42CoreNamespace = window.glue42core;
    if (glue42CoreNamespace && glue42CoreNamespace.webStarted) {
        throw new Error("The Glue42 Core Web has already been started for this application.");
    }
    if (!glue42CoreNamespace) {
        window.glue42core = { webStarted: true };
        return;
    }
    glue42CoreNamespace.webStarted = true;
};

const enterprise = (config) => {
    var _a, _b, _c;
    const enterpriseConfig = {
        windows: true,
        layouts: "full",
        appManager: "full",
        channels: true,
        libraries: (_a = config === null || config === void 0 ? void 0 : config.libraries) !== null && _a !== void 0 ? _a : [],
        logger: (_c = (_b = config === null || config === void 0 ? void 0 : config.systemLogger) === null || _b === void 0 ? void 0 : _b.level) !== null && _c !== void 0 ? _c : "warn"
    };
    return window.Glue(enterpriseConfig);
};

/**
 * Wraps values in an `Ok` type.
 *
 * Example: `ok(5) // => {ok: true, result: 5}`
 */
var ok = function (result) { return ({ ok: true, result: result }); };
/**
 * Wraps errors in an `Err` type.
 *
 * Example: `err('on fire') // => {ok: false, error: 'on fire'}`
 */
var err = function (error) { return ({ ok: false, error: error }); };
/**
 * Create a `Promise` that either resolves with the result of `Ok` or rejects
 * with the error of `Err`.
 */
var asPromise = function (r) {
    return r.ok === true ? Promise.resolve(r.result) : Promise.reject(r.error);
};
/**
 * Unwraps a `Result` and returns either the result of an `Ok`, or
 * `defaultValue`.
 *
 * Example:
 * ```
 * Result.withDefault(5, number().run(json))
 * ```
 *
 * It would be nice if `Decoder` had an instance method that mirrored this
 * function. Such a method would look something like this:
 * ```
 * class Decoder<A> {
 *   runWithDefault = (defaultValue: A, json: any): A =>
 *     Result.withDefault(defaultValue, this.run(json));
 * }
 *
 * number().runWithDefault(5, json)
 * ```
 * Unfortunately, the type of `defaultValue: A` on the method causes issues
 * with type inference on  the `object` decoder in some situations. While these
 * inference issues can be solved by providing the optional type argument for
 * `object`s, the extra trouble and confusion doesn't seem worth it.
 */
var withDefault = function (defaultValue, r) {
    return r.ok === true ? r.result : defaultValue;
};
/**
 * Return the successful result, or throw an error.
 */
var withException = function (r) {
    if (r.ok === true) {
        return r.result;
    }
    else {
        throw r.error;
    }
};
/**
 * Apply `f` to the result of an `Ok`, or pass the error through.
 */
var map = function (f, r) {
    return r.ok === true ? ok(f(r.result)) : r;
};
/**
 * Apply `f` to the result of two `Ok`s, or pass an error through. If both
 * `Result`s are errors then the first one is returned.
 */
var map2 = function (f, ar, br) {
    return ar.ok === false ? ar :
        br.ok === false ? br :
            ok(f(ar.result, br.result));
};
/**
 * Apply `f` to the error of an `Err`, or pass the success through.
 */
var mapError = function (f, r) {
    return r.ok === true ? r : err(f(r.error));
};
/**
 * Chain together a sequence of computations that may fail, similar to a
 * `Promise`. If the first computation fails then the error will propagate
 * through. If it succeeds, then `f` will be applied to the value, returning a
 * new `Result`.
 */
var andThen = function (f, r) {
    return r.ok === true ? f(r.result) : r;
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */



var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function isEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (a === null && b === null) {
        return true;
    }
    if (typeof (a) !== typeof (b)) {
        return false;
    }
    if (typeof (a) === 'object') {
        // Array
        if (Array.isArray(a)) {
            if (!Array.isArray(b)) {
                return false;
            }
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i++) {
                if (!isEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        // Hash table
        var keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) {
            return false;
        }
        for (var i = 0; i < keys.length; i++) {
            if (!b.hasOwnProperty(keys[i])) {
                return false;
            }
            if (!isEqual(a[keys[i]], b[keys[i]])) {
                return false;
            }
        }
        return true;
    }
}
/*
 * Helpers
 */
var isJsonArray = function (json) { return Array.isArray(json); };
var isJsonObject = function (json) {
    return typeof json === 'object' && json !== null && !isJsonArray(json);
};
var typeString = function (json) {
    switch (typeof json) {
        case 'string':
            return 'a string';
        case 'number':
            return 'a number';
        case 'boolean':
            return 'a boolean';
        case 'undefined':
            return 'undefined';
        case 'object':
            if (json instanceof Array) {
                return 'an array';
            }
            else if (json === null) {
                return 'null';
            }
            else {
                return 'an object';
            }
        default:
            return JSON.stringify(json);
    }
};
var expectedGot = function (expected, got) {
    return "expected " + expected + ", got " + typeString(got);
};
var printPath = function (paths) {
    return paths.map(function (path) { return (typeof path === 'string' ? "." + path : "[" + path + "]"); }).join('');
};
var prependAt = function (newAt, _a) {
    var at = _a.at, rest = __rest(_a, ["at"]);
    return (__assign$1({ at: newAt + (at || '') }, rest));
};
/**
 * Decoders transform json objects with unknown structure into known and
 * verified forms. You can create objects of type `Decoder<A>` with either the
 * primitive decoder functions, such as `boolean()` and `string()`, or by
 * applying higher-order decoders to the primitives, such as `array(boolean())`
 * or `dict(string())`.
 *
 * Each of the decoder functions are available both as a static method on
 * `Decoder` and as a function alias -- for example the string decoder is
 * defined at `Decoder.string()`, but is also aliased to `string()`. Using the
 * function aliases exported with the library is recommended.
 *
 * `Decoder` exposes a number of 'run' methods, which all decode json in the
 * same way, but communicate success and failure in different ways. The `map`
 * and `andThen` methods modify decoders without having to call a 'run' method.
 *
 * Alternatively, the main decoder `run()` method returns an object of type
 * `Result<A, DecoderError>`. This library provides a number of helper
 * functions for dealing with the `Result` type, so you can do all the same
 * things with a `Result` as with the decoder methods.
 */
var Decoder = /** @class */ (function () {
    /**
     * The Decoder class constructor is kept private to separate the internal
     * `decode` function from the external `run` function. The distinction
     * between the two functions is that `decode` returns a
     * `Partial<DecoderError>` on failure, which contains an unfinished error
     * report. When `run` is called on a decoder, the relevant series of `decode`
     * calls is made, and then on failure the resulting `Partial<DecoderError>`
     * is turned into a `DecoderError` by filling in the missing information.
     *
     * While hiding the constructor may seem restrictive, leveraging the
     * provided decoder combinators and helper functions such as
     * `andThen` and `map` should be enough to build specialized decoders as
     * needed.
     */
    function Decoder(decode) {
        var _this = this;
        this.decode = decode;
        /**
         * Run the decoder and return a `Result` with either the decoded value or a
         * `DecoderError` containing the json input, the location of the error, and
         * the error message.
         *
         * Examples:
         * ```
         * number().run(12)
         * // => {ok: true, result: 12}
         *
         * string().run(9001)
         * // =>
         * // {
         * //   ok: false,
         * //   error: {
         * //     kind: 'DecoderError',
         * //     input: 9001,
         * //     at: 'input',
         * //     message: 'expected a string, got 9001'
         * //   }
         * // }
         * ```
         */
        this.run = function (json) {
            return mapError(function (error) { return ({
                kind: 'DecoderError',
                input: json,
                at: 'input' + (error.at || ''),
                message: error.message || ''
            }); }, _this.decode(json));
        };
        /**
         * Run the decoder as a `Promise`.
         */
        this.runPromise = function (json) { return asPromise(_this.run(json)); };
        /**
         * Run the decoder and return the value on success, or throw an exception
         * with a formatted error string.
         */
        this.runWithException = function (json) { return withException(_this.run(json)); };
        /**
         * Construct a new decoder that applies a transformation to the decoded
         * result. If the decoder succeeds then `f` will be applied to the value. If
         * it fails the error will propagated through.
         *
         * Example:
         * ```
         * number().map(x => x * 5).run(10)
         * // => {ok: true, result: 50}
         * ```
         */
        this.map = function (f) {
            return new Decoder(function (json) { return map(f, _this.decode(json)); });
        };
        /**
         * Chain together a sequence of decoders. The first decoder will run, and
         * then the function will determine what decoder to run second. If the result
         * of the first decoder succeeds then `f` will be applied to the decoded
         * value. If it fails the error will propagate through.
         *
         * This is a very powerful method -- it can act as both the `map` and `where`
         * methods, can improve error messages for edge cases, and can be used to
         * make a decoder for custom types.
         *
         * Example of adding an error message:
         * ```
         * const versionDecoder = valueAt(['version'], number());
         * const infoDecoder3 = object({a: boolean()});
         *
         * const decoder = versionDecoder.andThen(version => {
         *   switch (version) {
         *     case 3:
         *       return infoDecoder3;
         *     default:
         *       return fail(`Unable to decode info, version ${version} is not supported.`);
         *   }
         * });
         *
         * decoder.run({version: 3, a: true})
         * // => {ok: true, result: {a: true}}
         *
         * decoder.run({version: 5, x: 'abc'})
         * // =>
         * // {
         * //   ok: false,
         * //   error: {... message: 'Unable to decode info, version 5 is not supported.'}
         * // }
         * ```
         *
         * Example of decoding a custom type:
         * ```
         * // nominal type for arrays with a length of at least one
         * type NonEmptyArray<T> = T[] & { __nonEmptyArrayBrand__: void };
         *
         * const nonEmptyArrayDecoder = <T>(values: Decoder<T>): Decoder<NonEmptyArray<T>> =>
         *   array(values).andThen(arr =>
         *     arr.length > 0
         *       ? succeed(createNonEmptyArray(arr))
         *       : fail(`expected a non-empty array, got an empty array`)
         *   );
         * ```
         */
        this.andThen = function (f) {
            return new Decoder(function (json) {
                return andThen(function (value) { return f(value).decode(json); }, _this.decode(json));
            });
        };
        /**
         * Add constraints to a decoder _without_ changing the resulting type. The
         * `test` argument is a predicate function which returns true for valid
         * inputs. When `test` fails on an input, the decoder fails with the given
         * `errorMessage`.
         *
         * ```
         * const chars = (length: number): Decoder<string> =>
         *   string().where(
         *     (s: string) => s.length === length,
         *     `expected a string of length ${length}`
         *   );
         *
         * chars(5).run('12345')
         * // => {ok: true, result: '12345'}
         *
         * chars(2).run('HELLO')
         * // => {ok: false, error: {... message: 'expected a string of length 2'}}
         *
         * chars(12).run(true)
         * // => {ok: false, error: {... message: 'expected a string, got a boolean'}}
         * ```
         */
        this.where = function (test, errorMessage) {
            return _this.andThen(function (value) { return (test(value) ? Decoder.succeed(value) : Decoder.fail(errorMessage)); });
        };
    }
    /**
     * Decoder primitive that validates strings, and fails on all other input.
     */
    Decoder.string = function () {
        return new Decoder(function (json) {
            return typeof json === 'string'
                ? ok(json)
                : err({ message: expectedGot('a string', json) });
        });
    };
    /**
     * Decoder primitive that validates numbers, and fails on all other input.
     */
    Decoder.number = function () {
        return new Decoder(function (json) {
            return typeof json === 'number'
                ? ok(json)
                : err({ message: expectedGot('a number', json) });
        });
    };
    /**
     * Decoder primitive that validates booleans, and fails on all other input.
     */
    Decoder.boolean = function () {
        return new Decoder(function (json) {
            return typeof json === 'boolean'
                ? ok(json)
                : err({ message: expectedGot('a boolean', json) });
        });
    };
    Decoder.constant = function (value) {
        return new Decoder(function (json) {
            return isEqual(json, value)
                ? ok(value)
                : err({ message: "expected " + JSON.stringify(value) + ", got " + JSON.stringify(json) });
        });
    };
    Decoder.object = function (decoders) {
        return new Decoder(function (json) {
            if (isJsonObject(json) && decoders) {
                var obj = {};
                for (var key in decoders) {
                    if (decoders.hasOwnProperty(key)) {
                        var r = decoders[key].decode(json[key]);
                        if (r.ok === true) {
                            // tslint:disable-next-line:strict-type-predicates
                            if (r.result !== undefined) {
                                obj[key] = r.result;
                            }
                        }
                        else if (json[key] === undefined) {
                            return err({ message: "the key '" + key + "' is required but was not present" });
                        }
                        else {
                            return err(prependAt("." + key, r.error));
                        }
                    }
                }
                return ok(obj);
            }
            else if (isJsonObject(json)) {
                return ok(json);
            }
            else {
                return err({ message: expectedGot('an object', json) });
            }
        });
    };
    Decoder.array = function (decoder) {
        return new Decoder(function (json) {
            if (isJsonArray(json) && decoder) {
                var decodeValue_1 = function (v, i) {
                    return mapError(function (err$$1) { return prependAt("[" + i + "]", err$$1); }, decoder.decode(v));
                };
                return json.reduce(function (acc, v, i) {
                    return map2(function (arr, result) { return arr.concat([result]); }, acc, decodeValue_1(v, i));
                }, ok([]));
            }
            else if (isJsonArray(json)) {
                return ok(json);
            }
            else {
                return err({ message: expectedGot('an array', json) });
            }
        });
    };
    Decoder.tuple = function (decoders) {
        return new Decoder(function (json) {
            if (isJsonArray(json)) {
                if (json.length !== decoders.length) {
                    return err({
                        message: "expected a tuple of length " + decoders.length + ", got one of length " + json.length
                    });
                }
                var result = [];
                for (var i = 0; i < decoders.length; i++) {
                    var nth = decoders[i].decode(json[i]);
                    if (nth.ok) {
                        result[i] = nth.result;
                    }
                    else {
                        return err(prependAt("[" + i + "]", nth.error));
                    }
                }
                return ok(result);
            }
            else {
                return err({ message: expectedGot("a tuple of length " + decoders.length, json) });
            }
        });
    };
    Decoder.union = function (ad, bd) {
        var decoders = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            decoders[_i - 2] = arguments[_i];
        }
        return Decoder.oneOf.apply(Decoder, [ad, bd].concat(decoders));
    };
    Decoder.intersection = function (ad, bd) {
        var ds = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            ds[_i - 2] = arguments[_i];
        }
        return new Decoder(function (json) {
            return [ad, bd].concat(ds).reduce(function (acc, decoder) { return map2(Object.assign, acc, decoder.decode(json)); }, ok({}));
        });
    };
    /**
     * Escape hatch to bypass validation. Always succeeds and types the result as
     * `any`. Useful for defining decoders incrementally, particularly for
     * complex objects.
     *
     * Example:
     * ```
     * interface User {
     *   name: string;
     *   complexUserData: ComplexType;
     * }
     *
     * const userDecoder: Decoder<User> = object({
     *   name: string(),
     *   complexUserData: anyJson()
     * });
     * ```
     */
    Decoder.anyJson = function () { return new Decoder(function (json) { return ok(json); }); };
    /**
     * Decoder identity function which always succeeds and types the result as
     * `unknown`.
     */
    Decoder.unknownJson = function () {
        return new Decoder(function (json) { return ok(json); });
    };
    /**
     * Decoder for json objects where the keys are unknown strings, but the values
     * should all be of the same type.
     *
     * Example:
     * ```
     * dict(number()).run({chocolate: 12, vanilla: 10, mint: 37});
     * // => {ok: true, result: {chocolate: 12, vanilla: 10, mint: 37}}
     * ```
     */
    Decoder.dict = function (decoder) {
        return new Decoder(function (json) {
            if (isJsonObject(json)) {
                var obj = {};
                for (var key in json) {
                    if (json.hasOwnProperty(key)) {
                        var r = decoder.decode(json[key]);
                        if (r.ok === true) {
                            obj[key] = r.result;
                        }
                        else {
                            return err(prependAt("." + key, r.error));
                        }
                    }
                }
                return ok(obj);
            }
            else {
                return err({ message: expectedGot('an object', json) });
            }
        });
    };
    /**
     * Decoder for values that may be `undefined`. This is primarily helpful for
     * decoding interfaces with optional fields.
     *
     * Example:
     * ```
     * interface User {
     *   id: number;
     *   isOwner?: boolean;
     * }
     *
     * const decoder: Decoder<User> = object({
     *   id: number(),
     *   isOwner: optional(boolean())
     * });
     * ```
     */
    Decoder.optional = function (decoder) {
        return new Decoder(function (json) { return (json === undefined || json === null ? ok(undefined) : decoder.decode(json)); });
    };
    /**
     * Decoder that attempts to run each decoder in `decoders` and either succeeds
     * with the first successful decoder, or fails after all decoders have failed.
     *
     * Note that `oneOf` expects the decoders to all have the same return type,
     * while `union` creates a decoder for the union type of all the input
     * decoders.
     *
     * Examples:
     * ```
     * oneOf(string(), number().map(String))
     * oneOf(constant('start'), constant('stop'), succeed('unknown'))
     * ```
     */
    Decoder.oneOf = function () {
        var decoders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            decoders[_i] = arguments[_i];
        }
        return new Decoder(function (json) {
            var errors = [];
            for (var i = 0; i < decoders.length; i++) {
                var r = decoders[i].decode(json);
                if (r.ok === true) {
                    return r;
                }
                else {
                    errors[i] = r.error;
                }
            }
            var errorsList = errors
                .map(function (error) { return "at error" + (error.at || '') + ": " + error.message; })
                .join('", "');
            return err({
                message: "expected a value matching one of the decoders, got the errors [\"" + errorsList + "\"]"
            });
        });
    };
    /**
     * Decoder that always succeeds with either the decoded value, or a fallback
     * default value.
     */
    Decoder.withDefault = function (defaultValue, decoder) {
        return new Decoder(function (json) {
            return ok(withDefault(defaultValue, decoder.decode(json)));
        });
    };
    /**
     * Decoder that pulls a specific field out of a json structure, instead of
     * decoding and returning the full structure. The `paths` array describes the
     * object keys and array indices to traverse, so that values can be pulled out
     * of a nested structure.
     *
     * Example:
     * ```
     * const decoder = valueAt(['a', 'b', 0], string());
     *
     * decoder.run({a: {b: ['surprise!']}})
     * // => {ok: true, result: 'surprise!'}
     *
     * decoder.run({a: {x: 'cats'}})
     * // => {ok: false, error: {... at: 'input.a.b[0]' message: 'path does not exist'}}
     * ```
     *
     * Note that the `decoder` is ran on the value found at the last key in the
     * path, even if the last key is not found. This allows the `optional`
     * decoder to succeed when appropriate.
     * ```
     * const optionalDecoder = valueAt(['a', 'b', 'c'], optional(string()));
     *
     * optionalDecoder.run({a: {b: {c: 'surprise!'}}})
     * // => {ok: true, result: 'surprise!'}
     *
     * optionalDecoder.run({a: {b: 'cats'}})
     * // => {ok: false, error: {... at: 'input.a.b.c' message: 'expected an object, got "cats"'}
     *
     * optionalDecoder.run({a: {b: {z: 1}}})
     * // => {ok: true, result: undefined}
     * ```
     */
    Decoder.valueAt = function (paths, decoder) {
        return new Decoder(function (json) {
            var jsonAtPath = json;
            for (var i = 0; i < paths.length; i++) {
                if (jsonAtPath === undefined) {
                    return err({
                        at: printPath(paths.slice(0, i + 1)),
                        message: 'path does not exist'
                    });
                }
                else if (typeof paths[i] === 'string' && !isJsonObject(jsonAtPath)) {
                    return err({
                        at: printPath(paths.slice(0, i + 1)),
                        message: expectedGot('an object', jsonAtPath)
                    });
                }
                else if (typeof paths[i] === 'number' && !isJsonArray(jsonAtPath)) {
                    return err({
                        at: printPath(paths.slice(0, i + 1)),
                        message: expectedGot('an array', jsonAtPath)
                    });
                }
                else {
                    jsonAtPath = jsonAtPath[paths[i]];
                }
            }
            return mapError(function (error) {
                return jsonAtPath === undefined
                    ? { at: printPath(paths), message: 'path does not exist' }
                    : prependAt(printPath(paths), error);
            }, decoder.decode(jsonAtPath));
        });
    };
    /**
     * Decoder that ignores the input json and always succeeds with `fixedValue`.
     */
    Decoder.succeed = function (fixedValue) {
        return new Decoder(function (json) { return ok(fixedValue); });
    };
    /**
     * Decoder that ignores the input json and always fails with `errorMessage`.
     */
    Decoder.fail = function (errorMessage) {
        return new Decoder(function (json) { return err({ message: errorMessage }); });
    };
    /**
     * Decoder that allows for validating recursive data structures. Unlike with
     * functions, decoders assigned to variables can't reference themselves
     * before they are fully defined. We can avoid prematurely referencing the
     * decoder by wrapping it in a function that won't be called until use, at
     * which point the decoder has been defined.
     *
     * Example:
     * ```
     * interface Comment {
     *   msg: string;
     *   replies: Comment[];
     * }
     *
     * const decoder: Decoder<Comment> = object({
     *   msg: string(),
     *   replies: lazy(() => array(decoder))
     * });
     * ```
     */
    Decoder.lazy = function (mkDecoder) {
        return new Decoder(function (json) { return mkDecoder().decode(json); });
    };
    return Decoder;
}());

/* tslint:disable:variable-name */
/** See `Decoder.string` */
var string = Decoder.string;
/** See `Decoder.number` */
var number = Decoder.number;
/** See `Decoder.boolean` */
var boolean = Decoder.boolean;
/** See `Decoder.anyJson` */
var anyJson = Decoder.anyJson;
/** See `Decoder.unknownJson` */
Decoder.unknownJson;
/** See `Decoder.constant` */
var constant = Decoder.constant;
/** See `Decoder.object` */
var object = Decoder.object;
/** See `Decoder.array` */
var array = Decoder.array;
/** See `Decoder.tuple` */
Decoder.tuple;
/** See `Decoder.dict` */
Decoder.dict;
/** See `Decoder.optional` */
var optional = Decoder.optional;
/** See `Decoder.oneOf` */
var oneOf = Decoder.oneOf;
/** See `Decoder.union` */
Decoder.union;
/** See `Decoder.intersection` */
Decoder.intersection;
/** See `Decoder.withDefault` */
Decoder.withDefault;
/** See `Decoder.valueAt` */
Decoder.valueAt;
/** See `Decoder.succeed` */
Decoder.succeed;
/** See `Decoder.fail` */
Decoder.fail;
/** See `Decoder.lazy` */
var lazy = Decoder.lazy;

const nonEmptyStringDecoder = string().where((s) => s.length > 0, "Expected a non-empty string");
const nonNegativeNumberDecoder = number().where((num) => num >= 0, "Expected a non-negative number");
const libDomainDecoder = oneOf(constant("system"), constant("windows"), constant("appManager"), constant("layouts"), constant("intents"), constant("notifications"), constant("channels"), constant("extension"), constant("themes"));
const windowOperationTypesDecoder = oneOf(constant("openWindow"), constant("windowHello"), constant("windowAdded"), constant("windowRemoved"), constant("getBounds"), constant("getFrameBounds"), constant("getUrl"), constant("moveResize"), constant("focus"), constant("close"), constant("getTitle"), constant("setTitle"), constant("focusChange"));
const appManagerOperationTypesDecoder = oneOf(constant("appHello"), constant("appDirectoryStateChange"), constant("instanceStarted"), constant("instanceStopped"), constant("applicationStart"), constant("instanceStop"), constant("clear"));
const layoutsOperationTypesDecoder = oneOf(constant("layoutAdded"), constant("layoutChanged"), constant("layoutRemoved"), constant("get"), constant("getAll"), constant("export"), constant("import"), constant("remove"), constant("clientSaveRequest"), constant("getGlobalPermissionState"), constant("checkGlobalActivated"), constant("requestGlobalPermission"));
const notificationsOperationTypesDecoder = oneOf(constant("raiseNotification"), constant("requestPermission"), constant("notificationShow"), constant("notificationClick"), constant("getPermission"), constant("list"), constant("notificationRaised"), constant("notificationClosed"), constant("click"), constant("clear"), constant("clearAll"));
const systemOperationTypesDecoder = oneOf(constant("getEnvironment"), constant("getBase"), constant("platformShutdown"));
const windowRelativeDirectionDecoder = oneOf(constant("top"), constant("left"), constant("right"), constant("bottom"));
const windowBoundsDecoder = object({
    top: number(),
    left: number(),
    width: nonNegativeNumberDecoder,
    height: nonNegativeNumberDecoder
});
const windowOpenSettingsDecoder = optional(object({
    top: optional(number()),
    left: optional(number()),
    width: optional(nonNegativeNumberDecoder),
    height: optional(nonNegativeNumberDecoder),
    context: optional(anyJson()),
    relativeTo: optional(nonEmptyStringDecoder),
    relativeDirection: optional(windowRelativeDirectionDecoder),
    windowId: optional(nonEmptyStringDecoder),
    layoutComponentId: optional(nonEmptyStringDecoder)
}));
const openWindowConfigDecoder = object({
    name: nonEmptyStringDecoder,
    url: nonEmptyStringDecoder,
    options: windowOpenSettingsDecoder
});
const windowHelloDecoder = object({
    windowId: optional(nonEmptyStringDecoder)
});
const coreWindowDataDecoder = object({
    windowId: nonEmptyStringDecoder,
    name: nonEmptyStringDecoder
});
const simpleWindowDecoder = object({
    windowId: nonEmptyStringDecoder
});
const helloSuccessDecoder = object({
    windows: array(coreWindowDataDecoder),
    isWorkspaceFrame: boolean()
});
const windowTitleConfigDecoder = object({
    windowId: nonEmptyStringDecoder,
    title: string()
});
const focusEventDataDecoder = object({
    windowId: nonEmptyStringDecoder,
    hasFocus: boolean()
});
const windowMoveResizeConfigDecoder = object({
    windowId: nonEmptyStringDecoder,
    top: optional(number()),
    left: optional(number()),
    width: optional(nonNegativeNumberDecoder),
    height: optional(nonNegativeNumberDecoder),
    relative: optional(boolean())
});
const windowBoundsResultDecoder = object({
    windowId: nonEmptyStringDecoder,
    bounds: object({
        top: number(),
        left: number(),
        width: nonNegativeNumberDecoder,
        height: nonNegativeNumberDecoder
    })
});
const frameWindowBoundsResultDecoder = object({
    bounds: object({
        top: number(),
        left: number(),
        width: nonNegativeNumberDecoder,
        height: nonNegativeNumberDecoder
    })
});
const windowUrlResultDecoder = object({
    windowId: nonEmptyStringDecoder,
    url: nonEmptyStringDecoder
});
const anyDecoder = anyJson();
const boundsDecoder = object({
    top: optional(number()),
    left: optional(number()),
    width: optional(nonNegativeNumberDecoder),
    height: optional(nonNegativeNumberDecoder)
});
const instanceDataDecoder = object({
    id: nonEmptyStringDecoder,
    applicationName: nonEmptyStringDecoder
});
const applicationDetailsDecoder = object({
    url: nonEmptyStringDecoder,
    top: optional(number()),
    left: optional(number()),
    width: optional(nonNegativeNumberDecoder),
    height: optional(nonNegativeNumberDecoder)
});
const intentDefinitionDecoder = object({
    name: nonEmptyStringDecoder,
    displayName: optional(string()),
    contexts: optional(array(string())),
    customConfig: optional(object())
});
const fdc3AppDefinitionDecoder = object({
    name: nonEmptyStringDecoder,
    title: optional(nonEmptyStringDecoder),
    version: optional(nonEmptyStringDecoder),
    appId: optional(nonEmptyStringDecoder),
    manifest: nonEmptyStringDecoder,
    manifestType: nonEmptyStringDecoder,
    tooltip: optional(nonEmptyStringDecoder),
    description: optional(nonEmptyStringDecoder),
    contactEmail: optional(nonEmptyStringDecoder),
    supportEmail: optional(nonEmptyStringDecoder),
    publisher: optional(nonEmptyStringDecoder),
    images: optional(array(object({ url: optional(nonEmptyStringDecoder) }))),
    icons: optional(array(object({ icon: optional(nonEmptyStringDecoder) }))),
    customConfig: anyJson(),
    intents: optional(array(intentDefinitionDecoder))
});
const applicationDefinitionDecoder = object({
    name: nonEmptyStringDecoder,
    type: nonEmptyStringDecoder.where((s) => s === "window", "Expected a value of window"),
    title: optional(nonEmptyStringDecoder),
    version: optional(nonEmptyStringDecoder),
    customProperties: optional(anyJson()),
    icon: optional(string()),
    caption: optional(string()),
    details: applicationDetailsDecoder,
    intents: optional(array(intentDefinitionDecoder)),
    hidden: optional(boolean())
});
const allApplicationDefinitionsDecoder = oneOf(applicationDefinitionDecoder, fdc3AppDefinitionDecoder);
object({
    definitions: array(allApplicationDefinitionsDecoder),
    mode: oneOf(constant("replace"), constant("merge"))
});
const appRemoveConfigDecoder = object({
    name: nonEmptyStringDecoder
});
const appsExportOperationDecoder = object({
    definitions: array(applicationDefinitionDecoder)
});
const applicationDataDecoder = object({
    name: nonEmptyStringDecoder,
    type: nonEmptyStringDecoder.where((s) => s === "window", "Expected a value of window"),
    instances: array(instanceDataDecoder),
    userProperties: optional(anyJson()),
    title: optional(nonEmptyStringDecoder),
    version: optional(nonEmptyStringDecoder),
    icon: optional(nonEmptyStringDecoder),
    caption: optional(nonEmptyStringDecoder)
});
const baseApplicationDataDecoder = object({
    name: nonEmptyStringDecoder,
    type: nonEmptyStringDecoder.where((s) => s === "window", "Expected a value of window"),
    userProperties: anyJson(),
    title: optional(nonEmptyStringDecoder),
    version: optional(nonEmptyStringDecoder),
    icon: optional(nonEmptyStringDecoder),
    caption: optional(nonEmptyStringDecoder)
});
const appDirectoryStateChangeDecoder = object({
    appsAdded: array(baseApplicationDataDecoder),
    appsChanged: array(baseApplicationDataDecoder),
    appsRemoved: array(baseApplicationDataDecoder)
});
const appHelloSuccessDecoder = object({
    apps: array(applicationDataDecoder)
});
const basicInstanceDataDecoder = object({
    id: nonEmptyStringDecoder
});
const applicationStartConfigDecoder = object({
    name: nonEmptyStringDecoder,
    waitForAGMReady: boolean(),
    id: optional(nonEmptyStringDecoder),
    context: optional(anyJson()),
    top: optional(number()),
    left: optional(number()),
    width: optional(nonNegativeNumberDecoder),
    height: optional(nonNegativeNumberDecoder),
    relativeTo: optional(nonEmptyStringDecoder),
    relativeDirection: optional(oneOf(constant("top"), constant("left"), constant("right"), constant("bottom"))),
    forceChromeTab: optional(boolean()),
    layoutComponentId: optional(nonEmptyStringDecoder)
});
const layoutTypeDecoder = oneOf(constant("Global"), constant("Activity"), constant("ApplicationDefault"), constant("Swimlane"), constant("Workspace"));
const componentTypeDecoder = oneOf(constant("application"), constant("activity"));
const windowComponentStateDecoder = object({
    context: optional(anyJson()),
    bounds: windowBoundsDecoder,
    createArgs: object({
        name: optional(nonEmptyStringDecoder),
        url: optional(nonEmptyStringDecoder),
        context: optional(anyJson())
    }),
    windowState: optional(nonEmptyStringDecoder),
    restoreState: optional(nonEmptyStringDecoder),
    instanceId: nonEmptyStringDecoder,
    isCollapsed: optional(boolean()),
    isSticky: optional(boolean()),
    restoreSettings: object({
        groupId: optional(nonEmptyStringDecoder),
        groupZOrder: optional(number())
    })
});
const windowLayoutComponentDecoder = object({
    type: constant("window"),
    componentType: optional(componentTypeDecoder),
    application: nonEmptyStringDecoder,
    state: windowComponentStateDecoder
});
const windowLayoutItemDecoder = object({
    type: constant("window"),
    config: object({
        appName: nonEmptyStringDecoder,
        url: optional(nonEmptyStringDecoder),
        title: optional(string()),
        allowExtract: optional(boolean()),
        allowReorder: optional(boolean()),
        showCloseButton: optional(boolean()),
        isMaximized: optional(boolean())
    })
});
const groupLayoutItemDecoder = object({
    type: constant("group"),
    config: anyJson(),
    children: array(oneOf(windowLayoutItemDecoder))
});
const columnLayoutItemDecoder = object({
    type: constant("column"),
    config: anyJson(),
    children: array(oneOf(groupLayoutItemDecoder, windowLayoutItemDecoder, lazy(() => columnLayoutItemDecoder), lazy(() => rowLayoutItemDecoder)))
});
const rowLayoutItemDecoder = object({
    type: constant("row"),
    config: anyJson(),
    children: array(oneOf(columnLayoutItemDecoder, groupLayoutItemDecoder, windowLayoutItemDecoder, lazy(() => rowLayoutItemDecoder)))
});
const workspaceLayoutComponentStateDecoder = object({
    config: anyJson(),
    context: anyJson(),
    children: array(oneOf(rowLayoutItemDecoder, columnLayoutItemDecoder, groupLayoutItemDecoder, windowLayoutItemDecoder))
});
const workspaceLayoutComponentDecoder = object({
    type: constant("Workspace"),
    application: optional(nonEmptyStringDecoder),
    state: workspaceLayoutComponentStateDecoder
});
const workspaceFrameComponentStateDecoder = object({
    bounds: windowBoundsDecoder,
    instanceId: nonEmptyStringDecoder,
    selectedWorkspace: nonNegativeNumberDecoder,
    workspaces: array(workspaceLayoutComponentStateDecoder),
    windowState: optional(nonEmptyStringDecoder),
    restoreState: optional(nonEmptyStringDecoder),
    context: optional(anyJson())
});
const workspaceFrameComponentDecoder = object({
    type: constant("workspaceFrame"),
    application: nonEmptyStringDecoder,
    componentType: optional(componentTypeDecoder),
    state: workspaceFrameComponentStateDecoder
});
const glueLayoutDecoder = object({
    name: nonEmptyStringDecoder,
    type: layoutTypeDecoder,
    components: array(oneOf(windowLayoutComponentDecoder, workspaceLayoutComponentDecoder, workspaceFrameComponentDecoder)),
    context: optional(anyJson()),
    metadata: optional(anyJson()),
    version: optional(number())
});
const newLayoutOptionsDecoder = object({
    name: nonEmptyStringDecoder,
    context: optional(anyJson()),
    metadata: optional(anyJson()),
    instances: optional(array(nonEmptyStringDecoder)),
    ignoreInstances: optional(array(nonEmptyStringDecoder))
});
const restoreOptionsDecoder = object({
    name: nonEmptyStringDecoder,
    context: optional(anyJson()),
    closeRunningInstance: optional(boolean()),
    closeMe: optional(boolean()),
    timeout: optional(nonNegativeNumberDecoder)
});
const layoutSummaryDecoder = object({
    name: nonEmptyStringDecoder,
    type: layoutTypeDecoder,
    context: optional(anyJson()),
    metadata: optional(anyJson())
});
const simpleLayoutConfigDecoder = object({
    name: nonEmptyStringDecoder,
    type: layoutTypeDecoder
});
const saveLayoutConfigDecoder = object({
    layout: newLayoutOptionsDecoder
});
const restoreLayoutConfigDecoder = object({
    layout: restoreOptionsDecoder
});
const getAllLayoutsConfigDecoder = object({
    type: layoutTypeDecoder
});
const allLayoutsFullConfigDecoder = object({
    layouts: array(glueLayoutDecoder)
});
const importModeDecoder = oneOf(constant("replace"), constant("merge"));
const layoutsImportConfigDecoder = object({
    layouts: array(glueLayoutDecoder),
    mode: importModeDecoder
});
const allLayoutsSummariesResultDecoder = object({
    summaries: array(layoutSummaryDecoder)
});
const simpleLayoutResultDecoder = object({
    layout: glueLayoutDecoder
});
const optionalSimpleLayoutResult = object({
    layout: optional(glueLayoutDecoder)
});
const intentsOperationTypesDecoder = oneOf(constant("findIntent"), constant("getIntents"), constant("raiseIntent"), constant("raise"));
const intentHandlerDecoder = object({
    applicationName: nonEmptyStringDecoder,
    applicationTitle: string(),
    applicationDescription: optional(string()),
    applicationIcon: optional(string()),
    type: oneOf(constant("app"), constant("instance")),
    displayName: optional(string()),
    contextTypes: optional(array(nonEmptyStringDecoder)),
    instanceId: optional(string()),
    instanceTitle: optional(string()),
    resultType: optional(string())
});
object({
    applicationName: string(),
    applicationIcon: optional(string()),
    instanceId: optional(string()),
});
const intentResolverResponseDecoder = object({
    intent: nonEmptyStringDecoder,
    handler: intentHandlerDecoder
});
const intentDecoder = object({
    name: nonEmptyStringDecoder,
    handlers: array(intentHandlerDecoder)
});
const intentTargetDecoder = oneOf(constant("startNew"), constant("reuse"), object({
    app: optional(nonEmptyStringDecoder),
    instance: optional(nonEmptyStringDecoder)
}));
const intentContextDecoder = object({
    type: optional(nonEmptyStringDecoder),
    data: optional(anyJson())
});
const intentsDecoder = array(intentDecoder);
const wrappedIntentsDecoder = object({
    intents: intentsDecoder
});
const intentFilterDecoder = object({
    name: optional(nonEmptyStringDecoder),
    contextType: optional(nonEmptyStringDecoder),
    resultType: optional(nonEmptyStringDecoder)
});
const findFilterDecoder = oneOf(nonEmptyStringDecoder, intentFilterDecoder);
const wrappedIntentFilterDecoder = object({
    filter: optional(intentFilterDecoder)
});
const intentRequestDecoder = object({
    intent: nonEmptyStringDecoder,
    target: optional(intentTargetDecoder),
    context: optional(intentContextDecoder),
    options: optional(windowOpenSettingsDecoder),
    handlers: optional(array(intentHandlerDecoder))
});
const raiseRequestDecoder = oneOf(nonEmptyStringDecoder, intentRequestDecoder);
const intentRequestResolverConfigDecoder = object({
    enabled: boolean(),
    appName: nonEmptyStringDecoder,
    waitResponseTimeout: number()
});
const raiseIntentRequestDecoder = object({
    intentRequest: intentRequestDecoder,
    resolverConfig: intentRequestResolverConfigDecoder
});
const intentResultDecoder = object({
    request: intentRequestDecoder,
    handler: intentHandlerDecoder,
    result: anyJson()
});
const AddIntentListenerRequestDecoder = object({
    intent: nonEmptyStringDecoder,
    contextTypes: optional(array(nonEmptyStringDecoder)),
    displayName: optional(string()),
    icon: optional(string()),
    description: optional(string()),
    resultType: optional(string())
});
const AddIntentListenerDecoder = oneOf(nonEmptyStringDecoder, AddIntentListenerRequestDecoder);
const channelNameDecoder = (channelNames) => {
    return nonEmptyStringDecoder.where(s => channelNames.includes(s), "Expected a valid channel name");
};
const interopActionSettingsDecoder = object({
    method: nonEmptyStringDecoder,
    arguments: optional(anyJson()),
    target: optional(oneOf(constant("all"), constant("best")))
});
const glue42NotificationActionDecoder = object({
    action: string(),
    title: nonEmptyStringDecoder,
    icon: optional(string()),
    interop: optional(interopActionSettingsDecoder)
});
const notificationDefinitionDecoder = object({
    badge: optional(string()),
    body: optional(string()),
    data: optional(anyJson()),
    dir: optional(oneOf(constant("auto"), constant("ltr"), constant("rtl"))),
    icon: optional(string()),
    image: optional(string()),
    lang: optional(string()),
    renotify: optional(boolean()),
    requireInteraction: optional(boolean()),
    silent: optional(boolean()),
    tag: optional(string()),
    timestamp: optional(nonNegativeNumberDecoder),
    vibrate: optional(array(number()))
});
const glue42NotificationOptionsDecoder = object({
    title: nonEmptyStringDecoder,
    clickInterop: optional(interopActionSettingsDecoder),
    actions: optional(array(glue42NotificationActionDecoder)),
    focusPlatformOnDefaultClick: optional(boolean()),
    badge: optional(string()),
    body: optional(string()),
    data: optional(anyJson()),
    dir: optional(oneOf(constant("auto"), constant("ltr"), constant("rtl"))),
    icon: optional(string()),
    image: optional(string()),
    lang: optional(string()),
    renotify: optional(boolean()),
    requireInteraction: optional(boolean()),
    silent: optional(boolean()),
    tag: optional(string()),
    timestamp: optional(nonNegativeNumberDecoder),
    vibrate: optional(array(number())),
    severity: optional(oneOf(constant("Low"), constant("None"), constant("Medium"), constant("High"), constant("Critical"))),
    showToast: optional(boolean()),
    showInPanel: optional(boolean())
});
const channelContextDecoder = object({
    name: nonEmptyStringDecoder,
    meta: object({
        color: nonEmptyStringDecoder
    }),
    data: optional(object()),
});
const raiseNotificationDecoder = object({
    settings: glue42NotificationOptionsDecoder,
    id: nonEmptyStringDecoder
});
const permissionRequestResultDecoder = object({
    permissionGranted: boolean()
});
const permissionQueryResultDecoder = object({
    permission: oneOf(constant("default"), constant("granted"), constant("denied"))
});
const notificationEventPayloadDecoder = object({
    definition: notificationDefinitionDecoder,
    action: optional(string()),
    id: optional(nonEmptyStringDecoder)
});
const platformSaveRequestConfigDecoder = object({
    layoutType: oneOf(constant("Global"), constant("Workspace")),
    layoutName: nonEmptyStringDecoder,
    context: optional(anyJson())
});
const saveRequestClientResponseDecoder = object({
    windowContext: optional(anyJson()),
});
const permissionStateResultDecoder = object({
    state: oneOf(constant("prompt"), constant("denied"), constant("granted"))
});
const simpleAvailabilityResultDecoder = object({
    isAvailable: boolean()
});
const simpleItemIdDecoder = object({
    itemId: nonEmptyStringDecoder
});
const operationCheckResultDecoder = object({
    isSupported: boolean()
});
const operationCheckConfigDecoder = object({
    operation: nonEmptyStringDecoder
});
const workspaceFrameBoundsResultDecoder = object({
    bounds: windowBoundsDecoder
});
const themeDecoder = object({
    displayName: nonEmptyStringDecoder,
    name: nonEmptyStringDecoder
});
const simpleThemeResponseDecoder = object({
    theme: themeDecoder
});
const allThemesResponseDecoder = object({
    themes: array(themeDecoder)
});
const selectThemeConfigDecoder = object({
    name: nonEmptyStringDecoder
});
const notificationsDataDecoder = object({
    id: nonEmptyStringDecoder,
    title: nonEmptyStringDecoder,
    clickInterop: optional(interopActionSettingsDecoder),
    actions: optional(array(glue42NotificationActionDecoder)),
    focusPlatformOnDefaultClick: optional(boolean()),
    badge: optional(string()),
    body: optional(string()),
    data: optional(anyJson()),
    dir: optional(oneOf(constant("auto"), constant("ltr"), constant("rtl"))),
    icon: optional(string()),
    image: optional(string()),
    lang: optional(string()),
    renotify: optional(boolean()),
    requireInteraction: optional(boolean()),
    silent: optional(boolean()),
    tag: optional(string()),
    timestamp: optional(nonNegativeNumberDecoder),
    vibrate: optional(array(number())),
    severity: optional(oneOf(constant("Low"), constant("None"), constant("Medium"), constant("High"), constant("Critical"))),
    showToast: optional(boolean()),
    showInPanel: optional(boolean())
});
const simpleNotificationDataDecoder = object({
    notification: notificationsDataDecoder
});
const allNotificationsDataDecoder = object({
    notifications: array(notificationsDataDecoder)
});
const simpleNotificationSelectDecoder = object({
    id: nonEmptyStringDecoder
});

const operations$8 = {
    openWindow: { name: "openWindow", dataDecoder: openWindowConfigDecoder, resultDecoder: coreWindowDataDecoder },
    windowHello: { name: "windowHello", dataDecoder: windowHelloDecoder, resultDecoder: helloSuccessDecoder },
    windowAdded: { name: "windowAdded", dataDecoder: coreWindowDataDecoder },
    windowRemoved: { name: "windowRemoved", dataDecoder: simpleWindowDecoder },
    getBounds: { name: "getBounds", dataDecoder: simpleWindowDecoder, resultDecoder: windowBoundsResultDecoder },
    getFrameBounds: { name: "getFrameBounds", dataDecoder: simpleWindowDecoder, resultDecoder: frameWindowBoundsResultDecoder },
    getUrl: { name: "getUrl", dataDecoder: simpleWindowDecoder, resultDecoder: windowUrlResultDecoder },
    moveResize: { name: "moveResize", dataDecoder: windowMoveResizeConfigDecoder },
    focus: { name: "focus", dataDecoder: simpleWindowDecoder },
    close: { name: "close", dataDecoder: simpleWindowDecoder },
    getTitle: { name: "getTitle", dataDecoder: simpleWindowDecoder, resultDecoder: windowTitleConfigDecoder },
    setTitle: { name: "setTitle", dataDecoder: windowTitleConfigDecoder },
    focusChange: { name: "focusChange", dataDecoder: focusEventDataDecoder }
};

function getDefaultExportFromCjs$1 (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createRegistry$1(options) {
    if (options && options.errorHandling
        && typeof options.errorHandling !== "function"
        && options.errorHandling !== "log"
        && options.errorHandling !== "silent"
        && options.errorHandling !== "throw") {
        throw new Error("Invalid options passed to createRegistry. Prop errorHandling should be [\"log\" | \"silent\" | \"throw\" | (err) => void], but " + typeof options.errorHandling + " was passed");
    }
    var _userErrorHandler = options && typeof options.errorHandling === "function" && options.errorHandling;
    var callbacks = {};
    function add(key, callback, replayArgumentsArr) {
        var callbacksForKey = callbacks[key];
        if (!callbacksForKey) {
            callbacksForKey = [];
            callbacks[key] = callbacksForKey;
        }
        callbacksForKey.push(callback);
        if (replayArgumentsArr) {
            setTimeout(function () {
                replayArgumentsArr.forEach(function (replayArgument) {
                    var _a;
                    if ((_a = callbacks[key]) === null || _a === void 0 ? void 0 : _a.includes(callback)) {
                        try {
                            if (Array.isArray(replayArgument)) {
                                callback.apply(undefined, replayArgument);
                            }
                            else {
                                callback.apply(undefined, [replayArgument]);
                            }
                        }
                        catch (err) {
                            _handleError(err, key);
                        }
                    }
                });
            }, 0);
        }
        return function () {
            var allForKey = callbacks[key];
            if (!allForKey) {
                return;
            }
            allForKey = allForKey.reduce(function (acc, element, index) {
                if (!(element === callback && acc.length === index)) {
                    acc.push(element);
                }
                return acc;
            }, []);
            if (allForKey.length === 0) {
                delete callbacks[key];
            }
            else {
                callbacks[key] = allForKey;
            }
        };
    }
    function execute(key) {
        var argumentsArr = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            argumentsArr[_i - 1] = arguments[_i];
        }
        var callbacksForKey = callbacks[key];
        if (!callbacksForKey || callbacksForKey.length === 0) {
            return [];
        }
        var results = [];
        callbacksForKey.forEach(function (callback) {
            try {
                var result = callback.apply(undefined, argumentsArr);
                results.push(result);
            }
            catch (err) {
                results.push(undefined);
                _handleError(err, key);
            }
        });
        return results;
    }
    function _handleError(exceptionArtifact, key) {
        var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);
        if (_userErrorHandler) {
            _userErrorHandler(errParam);
            return;
        }
        var msg = "[ERROR] callback-registry: User callback for key \"" + key + "\" failed: " + errParam.stack;
        if (options) {
            switch (options.errorHandling) {
                case "log":
                    return console.error(msg);
                case "silent":
                    return;
                case "throw":
                    throw new Error(msg);
            }
        }
        console.error(msg);
    }
    function clear() {
        callbacks = {};
    }
    function clearKey(key) {
        var callbacksForKey = callbacks[key];
        if (!callbacksForKey) {
            return;
        }
        delete callbacks[key];
    }
    return {
        add: add,
        execute: execute,
        clear: clear,
        clearKey: clearKey
    };
}
createRegistry$1.default = createRegistry$1;
var lib$3 = createRegistry$1;

class WebWindowModel {
    constructor(_id, _name, _bridge) {
        this._id = _id;
        this._name = _name;
        this._bridge = _bridge;
        this.registry = lib$3();
        this.myCtxKey = `___window___${this.id}`;
    }
    get id() {
        return this._id.slice();
    }
    get name() {
        return this._name.slice();
    }
    clean() {
        if (this.ctxUnsubscribe) {
            this.ctxUnsubscribe();
        }
    }
    processSelfFocusEvent(hasFocus) {
        this.me.isFocused = hasFocus;
        this.registry.execute("focus-change", this.me);
    }
    toApi() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.ctxUnsubscribe = yield this._bridge.contextLib.subscribe(this.myCtxKey, (data) => this.registry.execute("context-updated", data));
            this.me = {
                id: this.id,
                name: this.name,
                isFocused: false,
                getURL: this.getURL.bind(this),
                moveResize: this.moveResize.bind(this),
                resizeTo: this.resizeTo.bind(this),
                moveTo: this.moveTo.bind(this),
                focus: this.focus.bind(this),
                close: this.close.bind(this),
                getTitle: this.getTitle.bind(this),
                setTitle: this.setTitle.bind(this),
                getBounds: this.getBounds.bind(this),
                getContext: this.getContext.bind(this),
                updateContext: this.updateContext.bind(this),
                setContext: this.setContext.bind(this),
                onContextUpdated: this.onContextUpdated.bind(this),
                onFocusChanged: this.onFocusChanged.bind(this)
            };
            return this.me;
        });
    }
    getURL() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const result = yield this._bridge.send("windows", operations$8.getUrl, { windowId: this.id });
            return result.url;
        });
    }
    onFocusChanged(callback) {
        if (typeof callback !== "function") {
            throw new Error("Cannot subscribe to context changes, because the provided callback is not a function!");
        }
        return this.registry.add("focus-change", callback);
    }
    moveResize(dimension) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const targetBounds = boundsDecoder.runWithException(dimension);
            const commandArgs = Object.assign({}, targetBounds, { windowId: this.id, relative: false });
            yield this._bridge.send("windows", operations$8.moveResize, commandArgs);
            return this.me;
        });
    }
    resizeTo(width, height) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (typeof width === "undefined" && typeof height === "undefined") {
                return this.me;
            }
            if (typeof width !== "undefined") {
                nonNegativeNumberDecoder.runWithException(width);
            }
            if (typeof height !== "undefined") {
                nonNegativeNumberDecoder.runWithException(height);
            }
            const commandArgs = Object.assign({}, { width, height }, { windowId: this.id, relative: true });
            yield this._bridge.send("windows", operations$8.moveResize, commandArgs);
            return this.me;
        });
    }
    moveTo(top, left) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (typeof top === "undefined" && typeof left === "undefined") {
                return this.me;
            }
            if (typeof top !== "undefined") {
                number().runWithException(top);
            }
            if (typeof left !== "undefined") {
                number().runWithException(left);
            }
            const commandArgs = Object.assign({}, { top, left }, { windowId: this.id, relative: true });
            yield this._bridge.send("windows", operations$8.moveResize, commandArgs);
            return this.me;
        });
    }
    focus() {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (this.name === "Platform") {
                window.open(undefined, this.id);
            }
            else {
                yield this._bridge.send("windows", operations$8.focus, { windowId: this.id });
            }
            return this.me;
        });
    }
    close() {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield this._bridge.send("windows", operations$8.close, { windowId: this.id });
            return this.me;
        });
    }
    getTitle() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const result = yield this._bridge.send("windows", operations$8.getTitle, { windowId: this.id });
            return result.title;
        });
    }
    setTitle(title) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const ttl = nonEmptyStringDecoder.runWithException(title);
            yield this._bridge.send("windows", operations$8.setTitle, { windowId: this.id, title: ttl });
            return this.me;
        });
    }
    getBounds() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const result = yield this._bridge.send("windows", operations$8.getBounds, { windowId: this.id });
            return result.bounds;
        });
    }
    getContext() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const ctx = yield this._bridge.contextLib.get(this.myCtxKey);
            return ctx;
        });
    }
    updateContext(context) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const ctx = anyDecoder.runWithException(context);
            yield this._bridge.contextLib.update(this.myCtxKey, ctx);
            return this.me;
        });
    }
    setContext(context) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const ctx = anyDecoder.runWithException(context);
            yield this._bridge.contextLib.set(this.myCtxKey, ctx);
            return this.me;
        });
    }
    onContextUpdated(callback) {
        if (typeof callback !== "function") {
            throw new Error("Cannot subscribe to context changes, because the provided callback is not a function!");
        }
        const wrappedCallback = (data) => {
            callback(data, this.me);
        };
        return this.registry.add("context-updated", wrappedCallback);
    }
}

const systemOperations = {
    operationCheck: { name: "operationCheck", dataDecoder: operationCheckConfigDecoder, resultDecoder: operationCheckResultDecoder },
    getWorkspaceWindowFrameBounds: { name: "getWorkspaceWindowFrameBounds", resultDecoder: workspaceFrameBoundsResultDecoder, dataDecoder: simpleItemIdDecoder }
};

const PromiseWrap = (promise, timeoutMilliseconds, timeoutMessage) => {
    return new Promise((resolve, reject) => {
        let promiseActive = true;
        const timeout = setTimeout(() => {
            if (!promiseActive) {
                return;
            }
            promiseActive = false;
            const message = timeoutMessage || `Promise timeout hit: ${timeoutMilliseconds}`;
            reject(message);
        }, timeoutMilliseconds);
        promise()
            .then((result) => {
            if (!promiseActive) {
                return;
            }
            promiseActive = false;
            clearTimeout(timeout);
            resolve(result);
        })
            .catch((error) => {
            if (!promiseActive) {
                return;
            }
            promiseActive = false;
            clearTimeout(timeout);
            reject(error);
        });
    });
};
const PromisePlus$1 = (executor, timeoutMilliseconds, timeoutMessage) => {
    return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            const message = timeoutMessage || `Promise timeout hit: ${timeoutMilliseconds}`;
            reject(message);
        }, timeoutMilliseconds);
        const providedPromise = new Promise(executor);
        providedPromise
            .then((result) => {
            clearTimeout(timeout);
            resolve(result);
        })
            .catch((error) => {
            clearTimeout(timeout);
            reject(error);
        });
    });
};

class WindowsController {
    constructor() {
        this.registry = lib$3();
        this.allWindowProjections = [];
    }
    start(coreGlue, ioc) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger = coreGlue.logger.subLogger("windows.controller.web");
            this.logger.trace("starting the web windows controller");
            this.publicWindowId = ioc.publicWindowId;
            this.addWindowOperationExecutors();
            this.ioc = ioc;
            this.bridge = ioc.bridge;
            this.instanceId = coreGlue.interop.instance.instance;
            this.logger.trace(`set the public window id: ${this.publicWindowId}, set the bridge operations and ioc, registering with the platform now`);
            this.platformRegistration = this.registerWithPlatform();
            yield this.platformRegistration;
            yield this.initializeFocusTracking();
            this.logger.trace("registration with the platform successful, attaching the windows property to glue and returning");
            const api = this.toApi();
            coreGlue.windows = api;
        });
    }
    handlePlatformShutdown() {
        this.registry.clear();
        this.allWindowProjections = [];
        if (!this.focusEventHandler) {
            return;
        }
        document.removeEventListener("visibilityChange", this.focusEventHandler);
        window.removeEventListener("focus", this.focusEventHandler);
        window.removeEventListener("blur", this.focusEventHandler);
    }
    handleBridgeMessage(args) {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield this.platformRegistration;
            const operationName = windowOperationTypesDecoder.runWithException(args.operation);
            const operation = operations$8[operationName];
            if (!operation.execute) {
                return;
            }
            let operationData = args.data;
            if (operation.dataDecoder) {
                operationData = operation.dataDecoder.runWithException(args.data);
            }
            return yield operation.execute(operationData);
        });
    }
    open(name, url, options) {
        return __awaiter$1(this, void 0, void 0, function* () {
            nonEmptyStringDecoder.runWithException(name);
            nonEmptyStringDecoder.runWithException(url);
            const settings = windowOpenSettingsDecoder.runWithException(options);
            const windowSuccess = yield this.bridge.send("windows", operations$8.openWindow, { name, url, options: settings });
            return this.waitForWindowAdded(windowSuccess.windowId);
        });
    }
    list() {
        return this.allWindowProjections.map((projection) => projection.api);
    }
    findById(id) {
        var _a;
        nonEmptyStringDecoder.runWithException(id);
        return (_a = this.allWindowProjections.find((projection) => projection.id === id)) === null || _a === void 0 ? void 0 : _a.api;
    }
    toApi() {
        return {
            open: this.open.bind(this),
            my: this.my.bind(this),
            list: this.list.bind(this),
            findById: this.findById.bind(this),
            onWindowAdded: this.onWindowAdded.bind(this),
            onWindowRemoved: this.onWindowRemoved.bind(this),
            onWindowGotFocus: this.onWindowGotFocus.bind(this),
            onWindowLostFocus: this.onWindowLostFocus.bind(this)
        };
    }
    addWindowOperationExecutors() {
        operations$8.focusChange.execute = this.handleFocusChangeEvent.bind(this);
        operations$8.windowAdded.execute = this.handleWindowAdded.bind(this);
        operations$8.windowRemoved.execute = this.handleWindowRemoved.bind(this);
        operations$8.getBounds.execute = this.handleGetBounds.bind(this);
        operations$8.getFrameBounds.execute = this.handleGetBounds.bind(this);
        operations$8.getTitle.execute = this.handleGetTitle.bind(this);
        operations$8.getUrl.execute = this.handleGetUrl.bind(this);
        operations$8.moveResize.execute = this.handleMoveResize.bind(this);
        operations$8.setTitle.execute = this.handleSetTitle.bind(this);
    }
    my() {
        return Object.assign({}, this.me);
    }
    onWindowAdded(callback) {
        if (typeof callback !== "function") {
            throw new Error("Cannot subscribe to window added, because the provided callback is not a function!");
        }
        return this.registry.add("window-added", callback);
    }
    onWindowRemoved(callback) {
        if (typeof callback !== "function") {
            throw new Error("Cannot subscribe to window removed, because the provided callback is not a function!");
        }
        return this.registry.add("window-removed", callback);
    }
    onWindowGotFocus(callback) {
        if (typeof callback !== "function") {
            throw new Error("Cannot subscribe to onWindowGotFocus, because the provided callback is not a function!");
        }
        return this.registry.add("window-got-focus", callback);
    }
    onWindowLostFocus(callback) {
        if (typeof callback !== "function") {
            throw new Error("Cannot subscribe to onWindowLostFocus, because the provided callback is not a function!");
        }
        return this.registry.add("window-lost-focus", callback);
    }
    sayHello() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const helloSuccess = yield this.bridge.send("windows", operations$8.windowHello, { windowId: this.publicWindowId });
            return helloSuccess;
        });
    }
    registerWithPlatform() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const { windows, isWorkspaceFrame } = yield this.sayHello();
            this.isWorkspaceFrame = isWorkspaceFrame;
            this.logger.trace("the platform responded to the hello message");
            if (!this.isWorkspaceFrame && this.publicWindowId) {
                this.logger.trace("i am not treated as a workspace frame, setting my window");
                const myWindow = windows.find((w) => w.windowId === this.publicWindowId);
                if (!myWindow) {
                    throw new Error("Cannot initialize the window library, because I received no information about me from the platform");
                }
                const myProjection = yield this.ioc.buildWebWindow(this.publicWindowId, myWindow.name);
                this.me = myProjection.api;
                this.allWindowProjections.push(myProjection);
            }
            const currentWindows = yield Promise.all(windows
                .filter((w) => w.windowId !== this.publicWindowId)
                .map((w) => this.ioc.buildWebWindow(w.windowId, w.name)));
            this.logger.trace("all windows projections are completed, building the list collection");
            this.allWindowProjections.push(...currentWindows);
        });
    }
    handleFocusChangeEvent(focusData) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const foundProjection = this.allWindowProjections.find((projection) => projection.id === focusData.windowId);
            if (!foundProjection) {
                return;
            }
            foundProjection.model.processSelfFocusEvent(focusData.hasFocus);
            const keyToExecute = focusData.hasFocus ? "window-got-focus" : "window-lost-focus";
            this.registry.execute(keyToExecute, foundProjection.api);
        });
    }
    handleWindowAdded(data) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (this.allWindowProjections.some((projection) => projection.id === data.windowId)) {
                return;
            }
            const webWindowProjection = yield this.ioc.buildWebWindow(data.windowId, data.name);
            this.allWindowProjections.push(webWindowProjection);
            this.registry.execute("window-added", webWindowProjection.api);
        });
    }
    handleWindowRemoved(data) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const removed = this.allWindowProjections.find((w) => w.id === data.windowId);
            if (!removed) {
                return;
            }
            this.allWindowProjections = this.allWindowProjections.filter((w) => w.id !== data.windowId);
            removed.model.clean();
            this.registry.execute("window-removed", removed.api);
        });
    }
    handleGetBounds() {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!this.me && !this.isWorkspaceFrame) {
                throw new Error("This window cannot report it's bounds, because it is not a Glue Window, most likely because it is an iframe");
            }
            return {
                windowId: this.isWorkspaceFrame ? "noop" : this.me.id,
                bounds: {
                    top: window.screenTop,
                    left: window.screenLeft,
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            };
        });
    }
    handleGetTitle() {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!this.me) {
                throw new Error("This window cannot report it's title, because it is not a Glue Window, most likely because it is an iframe");
            }
            return {
                windowId: this.me.id,
                title: document.title
            };
        });
    }
    handleGetUrl() {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!this.me) {
                throw new Error("This window cannot report it's url, because it is not a Glue Window, most likely because it is an iframe");
            }
            return {
                windowId: this.me.id,
                url: window.location.href
            };
        });
    }
    handleMoveResize(config) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const targetTop = typeof config.top === "number" ? config.top :
                config.relative ? 0 : window.screenTop;
            const targetLeft = typeof config.left === "number" ? config.left :
                config.relative ? 0 : window.screenLeft;
            const targetHeight = typeof config.height === "number" ? config.height :
                config.relative ? 0 : window.innerHeight;
            const targetWidth = typeof config.width === "number" ? config.width :
                config.relative ? 0 : window.innerWidth;
            const moveMethod = config.relative ? window.moveBy : window.moveTo;
            const resizeMethod = config.relative ? window.resizeBy : window.resizeTo;
            moveMethod(targetLeft, targetTop);
            resizeMethod(targetWidth, targetHeight);
        });
    }
    handleSetTitle(config) {
        return __awaiter$1(this, void 0, void 0, function* () {
            document.title = config.title;
        });
    }
    initializeFocusTracking() {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (this.isWorkspaceFrame) {
                this.logger.trace("Ignoring the focus tracking, because this client is a workspace frame");
                return;
            }
            try {
                yield this.bridge.send("windows", systemOperations.operationCheck, { operation: "focusChange" });
            }
            catch (error) {
                this.logger.warn("The platform of this client is outdated and does not support focus tracking, disabling focus events for this client.");
                return;
            }
            const hasFocus = document.hasFocus();
            yield this.transmitFocusChange(true);
            if (!hasFocus) {
                yield this.transmitFocusChange(false);
            }
            this.defineEventListeners();
        });
    }
    processFocusEvent() {
        const hasFocus = document.hasFocus();
        this.transmitFocusChange(hasFocus);
    }
    waitForWindowAdded(windowId) {
        const foundWindow = this.allWindowProjections.find((projection) => projection.id === windowId);
        if (foundWindow) {
            return Promise.resolve(foundWindow.api);
        }
        return PromisePlus$1((resolve) => {
            const unsubscribe = this.onWindowAdded((addedWindow) => {
                if (addedWindow.id === windowId) {
                    unsubscribe();
                    resolve(addedWindow);
                }
            });
        }, 30000, `Timed out waiting for ${windowId} to be announced`);
    }
    transmitFocusChange(hasFocus) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
            const eventData = {
                windowId: ((_a = this.me) === null || _a === void 0 ? void 0 : _a.id) || `iframe-${this.instanceId}`,
                hasFocus
            };
            if (this.me) {
                this.me.isFocused = hasFocus;
            }
            yield this.bridge.send("windows", operations$8.focusChange, eventData);
        });
    }
    defineEventListeners() {
        this.focusEventHandler = this.processFocusEvent.bind(this);
        document.addEventListener("visibilityChange", this.focusEventHandler);
        window.addEventListener("focus", this.focusEventHandler);
        window.addEventListener("blur", this.focusEventHandler);
    }
}

const GlueWebPlatformControlName = "T42.Web.Platform.Control";
const GlueWebPlatformStreamName = "T42.Web.Platform.Stream";
const GlueClientControlName = "T42.Web.Client.Control";
const GlueCorePlusThemesStream = "T42.Core.Plus.Themes.Stream";

class GlueBridge {
    constructor(coreGlue, communicationId) {
        this.coreGlue = coreGlue;
        this.communicationId = communicationId;
        this.platformMethodTimeoutMs = 10000;
    }
    get contextLib() {
        return this.coreGlue.contexts;
    }
    get interopInstance() {
        return this.coreGlue.interop.instance.instance;
    }
    stop() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.running = false;
            this.sub.close();
            yield this.coreGlue.interop.unregister(GlueClientControlName);
        });
    }
    start(controllers) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.running = true;
            this.controllers = controllers;
            yield Promise.all([
                this.checkWaitMethod(GlueWebPlatformControlName),
                this.checkWaitMethod(GlueWebPlatformStreamName)
            ]);
            const systemId = this.communicationId;
            const [sub] = yield Promise.all([
                this.coreGlue.interop.subscribe(GlueWebPlatformStreamName, systemId ? { target: { instance: this.communicationId } } : undefined),
                this.coreGlue.interop.registerAsync(GlueClientControlName, (args, _, success, error) => this.passMessageController(args, success, error))
            ]);
            this.sub = sub;
            this.sub.onData((pkg) => this.passMessageController(pkg.data));
        });
    }
    getInteropInstance(windowId) {
        const result = this.coreGlue.interop.servers().find((s) => s.windowId && s.windowId === windowId);
        return {
            application: result === null || result === void 0 ? void 0 : result.application,
            applicationName: result === null || result === void 0 ? void 0 : result.applicationName,
            peerId: result === null || result === void 0 ? void 0 : result.peerId,
            instance: result === null || result === void 0 ? void 0 : result.instance,
            windowId: result === null || result === void 0 ? void 0 : result.windowId
        };
    }
    send(domain, operation, operationData, options, webOptions) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (operation.dataDecoder) {
                try {
                    operation.dataDecoder.runWithException(operationData);
                }
                catch (error) {
                    throw new Error(`Unexpected Web->Platform outgoing validation error: ${error.message}, for operation: ${operation.name} and input: ${JSON.stringify(error.input)}`);
                }
            }
            const operationSupported = (webOptions === null || webOptions === void 0 ? void 0 : webOptions.includeOperationCheck) ?
                (yield this.checkOperationSupported(domain, operation)).isSupported :
                true;
            if (!operationSupported) {
                throw new Error(`Cannot complete operation: ${operation.name} for domain: ${domain} because this client is connected to a platform which does not support it`);
            }
            try {
                const operationResult = yield this.transmitMessage(domain, operation, operationData, options);
                if (operation.resultDecoder) {
                    operation.resultDecoder.runWithException(operationResult);
                }
                return operationResult;
            }
            catch (error) {
                if (error.kind) {
                    throw new Error(`Unexpected Web<-Platform incoming validation error: ${error.message}, for operation: ${operation.name} and input: ${JSON.stringify(error.input)}`);
                }
                throw new Error(error.message);
            }
        });
    }
    createNotificationsSteam() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const streamExists = this.coreGlue.interop.methods().some((method) => method.name === GlueCorePlusThemesStream);
            if (!streamExists) {
                throw new Error("Cannot subscribe to theme changes, because the underlying interop stream does not exist. Most likely this is the case when this client is not connected to Core Plus.");
            }
            return this.coreGlue.interop.subscribe(GlueCorePlusThemesStream, this.communicationId ? { target: { instance: this.communicationId } } : undefined);
        });
    }
    checkOperationSupported(domain, operation) {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                const result = yield this.send(domain, systemOperations.operationCheck, { operation: operation.name });
                return result;
            }
            catch (error) {
                return { isSupported: false };
            }
        });
    }
    checkWaitMethod(name) {
        return PromisePlus$1((resolve) => {
            const hasMethod = this.coreGlue.interop.methods().some((method) => {
                const nameMatch = method.name === name;
                const serverMatch = this.communicationId ?
                    method.getServers().some((server) => server.instance === this.communicationId) :
                    true;
                return nameMatch && serverMatch;
            });
            if (hasMethod) {
                return resolve();
            }
            const unSub = this.coreGlue.interop.serverMethodAdded((data) => {
                const method = data.method;
                const server = data.server;
                const serverMatch = this.communicationId ?
                    server.instance === this.communicationId :
                    true;
                if (method.name === name && serverMatch) {
                    unSub();
                    resolve();
                }
            });
        }, this.platformMethodTimeoutMs, `Cannot initiate Glue Web, because a system method's discovery timed out: ${name}`);
    }
    passMessageController(args, success, error) {
        const decodeResult = libDomainDecoder.run(args.domain);
        if (!decodeResult.ok) {
            if (error) {
                error(`Cannot execute this client control, because of domain validation error: ${JSON.stringify(decodeResult.error)}`);
            }
            return;
        }
        const domain = decodeResult.result;
        this.controllers[domain]
            .handleBridgeMessage(args)
            .then((resolutionData) => {
            if (success) {
                success(resolutionData);
            }
        })
            .catch((err) => {
            if (error) {
                error(err);
            }
            console.warn(err);
        });
    }
    transmitMessage(domain, operation, data, options) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const messageData = { domain, data, operation: operation.name };
            let invocationResult;
            const baseErrorMessage = `Internal Platform Communication Error. Attempted operation: ${JSON.stringify(operation.name)} with data: ${JSON.stringify(data)}. `;
            const systemId = this.communicationId;
            try {
                if (!this.running) {
                    throw new Error("Cannot send a control message, because the platform shut down");
                }
                invocationResult = yield this.coreGlue.interop.invoke(GlueWebPlatformControlName, messageData, systemId ? { instance: this.communicationId } : undefined, options);
                if (!invocationResult) {
                    throw new Error("Received unsupported result from the platform - empty result");
                }
                if (!Array.isArray(invocationResult.all_return_values) || invocationResult.all_return_values.length === 0) {
                    throw new Error("Received unsupported result from the platform - empty values collection");
                }
            }
            catch (error) {
                if (error && error.all_errors && error.all_errors.length) {
                    const invocationErrorMessage = error.all_errors[0].message;
                    throw new Error(`${baseErrorMessage} -> Inner message: ${invocationErrorMessage}`);
                }
                throw new Error(`${baseErrorMessage} -> Inner message: ${error.message}`);
            }
            return invocationResult.all_return_values[0].returned;
        });
    }
}

const operations$7 = {
    appHello: { name: "appHello", dataDecoder: windowHelloDecoder, resultDecoder: appHelloSuccessDecoder },
    appDirectoryStateChange: { name: "appDirectoryStateChange", dataDecoder: appDirectoryStateChangeDecoder },
    instanceStarted: { name: "instanceStarted", dataDecoder: instanceDataDecoder },
    instanceStopped: { name: "instanceStopped", dataDecoder: instanceDataDecoder },
    applicationStart: { name: "applicationStart", dataDecoder: applicationStartConfigDecoder, resultDecoder: instanceDataDecoder },
    instanceStop: { name: "instanceStop", dataDecoder: basicInstanceDataDecoder },
    import: { name: "import" },
    remove: { name: "remove", dataDecoder: appRemoveConfigDecoder },
    export: { name: "export", resultDecoder: appsExportOperationDecoder },
    clear: { name: "clear" }
};

class AppManagerController {
    constructor() {
        this.baseApplicationsTimeoutMS = 60000;
        this.appImportTimeoutMS = 20;
        this.registry = lib$3();
        this.applications = [];
        this.instances = [];
    }
    handlePlatformShutdown() {
        this.registry.clear();
        this.applications = [];
        this.instances = [];
        delete this.me;
    }
    start(coreGlue, ioc) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger = coreGlue.logger.subLogger("appManger.controller.web");
            this.logger.trace("starting the web appManager controller");
            this.publicWindowId = ioc.publicWindowId;
            this.addOperationsExecutors();
            this.ioc = ioc;
            this.bridge = ioc.bridge;
            this.platformRegistration = this.registerWithPlatform();
            yield this.platformRegistration;
            this.logger.trace("registration with the platform successful, attaching the appManager property to glue and returning");
            const api = this.toApi();
            coreGlue.appManager = api;
        });
    }
    handleBridgeMessage(args) {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield this.platformRegistration;
            const operationName = appManagerOperationTypesDecoder.runWithException(args.operation);
            const operation = operations$7[operationName];
            if (!operation.execute) {
                return;
            }
            let operationData = args.data;
            if (operation.dataDecoder) {
                operationData = operation.dataDecoder.runWithException(args.data);
            }
            return yield operation.execute(operationData);
        });
    }
    onInstanceStarted(callback) {
        if (typeof callback !== "function") {
            throw new Error("onInstanceStarted requires a single argument of type function");
        }
        return this.registry.add("instance-started", callback, this.instances);
    }
    onInstanceStopped(callback) {
        if (typeof callback !== "function") {
            throw new Error("onInstanceStopped requires a single argument of type function");
        }
        return this.registry.add("instance-stopped", callback);
    }
    startApplication(appName, context, options) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
            const startOptions = {
                name: appName,
                waitForAGMReady: (_a = options === null || options === void 0 ? void 0 : options.waitForAGMReady) !== null && _a !== void 0 ? _a : true,
                context,
                top: options === null || options === void 0 ? void 0 : options.top,
                left: options === null || options === void 0 ? void 0 : options.left,
                width: options === null || options === void 0 ? void 0 : options.width,
                height: options === null || options === void 0 ? void 0 : options.height,
                relativeTo: options === null || options === void 0 ? void 0 : options.relativeTo,
                relativeDirection: options === null || options === void 0 ? void 0 : options.relativeDirection,
                id: options === null || options === void 0 ? void 0 : options.reuseId,
                forceChromeTab: options === null || options === void 0 ? void 0 : options.forceTab,
                layoutComponentId: options === null || options === void 0 ? void 0 : options.layoutComponentId
            };
            const openResult = yield this.bridge.send("appManager", operations$7.applicationStart, startOptions);
            const app = this.applications.find((a) => a.name === openResult.applicationName);
            return this.ioc.buildInstance(openResult, app);
        });
    }
    getApplication(name) {
        const verifiedName = nonEmptyStringDecoder.runWithException(name);
        return this.applications.find((app) => app.name === verifiedName);
    }
    getInstances() {
        return this.instances.slice();
    }
    toApi() {
        const api = {
            myInstance: this.me,
            inMemory: {
                import: this.import.bind(this),
                remove: this.remove.bind(this),
                export: this.export.bind(this),
                clear: this.clear.bind(this)
            },
            application: this.getApplication.bind(this),
            applications: this.getApplications.bind(this),
            instances: this.getInstances.bind(this),
            onAppAdded: this.onAppAdded.bind(this),
            onAppChanged: this.onAppChanged.bind(this),
            onAppRemoved: this.onAppRemoved.bind(this),
            onInstanceStarted: this.onInstanceStarted.bind(this),
            onInstanceStopped: this.onInstanceStopped.bind(this)
        };
        return api;
    }
    addOperationsExecutors() {
        operations$7.appDirectoryStateChange.execute = this.handleAppDirectoryStateChange.bind(this);
        operations$7.instanceStarted.execute = this.handleInstanceStartedMessage.bind(this);
        operations$7.instanceStopped.execute = this.handleInstanceStoppedMessage.bind(this);
    }
    handleAppDirectoryStateChange(data) {
        return __awaiter$1(this, void 0, void 0, function* () {
            data.appsAdded.forEach(this.handleApplicationAddedMessage.bind(this));
            data.appsChanged.forEach(this.handleApplicationChangedMessage.bind(this));
            data.appsRemoved.forEach(this.handleApplicationRemovedMessage.bind(this));
        });
    }
    onAppAdded(callback) {
        if (typeof callback !== "function") {
            throw new Error("onAppAdded requires a single argument of type function");
        }
        return this.registry.add("application-added", callback, this.applications);
    }
    onAppRemoved(callback) {
        if (typeof callback !== "function") {
            throw new Error("onAppRemoved requires a single argument of type function");
        }
        return this.registry.add("application-removed", callback);
    }
    onAppChanged(callback) {
        if (typeof callback !== "function") {
            throw new Error("onAppChanged requires a single argument of type function");
        }
        return this.registry.add("application-changed", callback);
    }
    handleApplicationAddedMessage(appData) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (this.applications.some((app) => app.name === appData.name)) {
                return;
            }
            const app = yield this.ioc.buildApplication(appData, []);
            const instances = this.instances.filter((instance) => instance.application.name === app.name);
            app.instances.push(...instances);
            this.applications.push(app);
            this.registry.execute("application-added", app);
        });
    }
    handleApplicationRemovedMessage(appData) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const appIndex = this.applications.findIndex((app) => app.name === appData.name);
            if (appIndex < 0) {
                return;
            }
            const app = this.applications[appIndex];
            this.applications.splice(appIndex, 1);
            this.registry.execute("application-removed", app);
        });
    }
    handleApplicationChangedMessage(appData) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const app = this.applications.find((app) => app.name === appData.name);
            if (!app) {
                return this.handleApplicationAddedMessage(appData);
            }
            app.title = appData.title;
            app.version = appData.version;
            app.icon = appData.icon;
            app.caption = appData.caption;
            app.userProperties = appData.userProperties;
            this.registry.execute("application-changed", app);
        });
    }
    handleInstanceStartedMessage(instanceData) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (this.instances.some((instance) => instance.id === instanceData.id)) {
                return;
            }
            const application = this.applications.find((app) => app.name === instanceData.applicationName);
            if (!application) {
                throw new Error(`Cannot add instance: ${instanceData.id}, because there is no application definition associated with it`);
            }
            const instance = this.ioc.buildInstance(instanceData, application);
            this.instances.push(instance);
            application.instances.push(instance);
            this.registry.execute("instance-started", instance);
        });
    }
    handleInstanceStoppedMessage(instanceData) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const instance = this.instances.find((i) => i.id === instanceData.id);
            if (instance) {
                const instIdx = this.instances.findIndex((inst) => inst.id === instanceData.id);
                this.instances.splice(instIdx, 1);
            }
            const application = this.applications.find((app) => app.instances.some((inst) => inst.id === instanceData.id));
            if (application) {
                const instIdxApps = application.instances.findIndex((inst) => inst.id === instanceData.id);
                application.instances.splice(instIdxApps, 1);
            }
            if (!instance) {
                return;
            }
            this.registry.execute("instance-stopped", instance);
        });
    }
    import(definitions, mode = "replace") {
        return __awaiter$1(this, void 0, void 0, function* () {
            importModeDecoder.runWithException(mode);
            if (!Array.isArray(definitions)) {
                throw new Error("Import must be called with an array of definitions");
            }
            if (definitions.length > 10000) {
                throw new Error("Cannot import more than 10000 app definitions in Glue42 Core.");
            }
            const parseResult = definitions.reduce((soFar, definition) => {
                const decodeResult = allApplicationDefinitionsDecoder.run(definition);
                if (!decodeResult.ok) {
                    soFar.invalid.push({ app: definition === null || definition === void 0 ? void 0 : definition.name, error: JSON.stringify(decodeResult.error) });
                }
                else {
                    soFar.valid.push(definition);
                }
                return soFar;
            }, { valid: [], invalid: [] });
            const responseTimeout = this.baseApplicationsTimeoutMS + this.appImportTimeoutMS * parseResult.valid.length;
            yield this.bridge.send("appManager", operations$7.import, { definitions: parseResult.valid, mode }, { methodResponseTimeoutMs: responseTimeout });
            return {
                imported: parseResult.valid.map((valid) => valid.name),
                errors: parseResult.invalid
            };
        });
    }
    remove(name) {
        return __awaiter$1(this, void 0, void 0, function* () {
            nonEmptyStringDecoder.runWithException(name);
            yield this.bridge.send("appManager", operations$7.remove, { name }, { methodResponseTimeoutMs: this.baseApplicationsTimeoutMS });
        });
    }
    clear() {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield this.bridge.send("appManager", operations$7.clear, undefined, { methodResponseTimeoutMs: this.baseApplicationsTimeoutMS });
        });
    }
    export() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const response = yield this.bridge.send("appManager", operations$7.export, undefined, { methodResponseTimeoutMs: this.baseApplicationsTimeoutMS });
            return response.definitions;
        });
    }
    getApplications() {
        return this.applications.slice();
    }
    registerWithPlatform() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const result = yield this.bridge.send("appManager", operations$7.appHello, { windowId: this.publicWindowId }, { methodResponseTimeoutMs: this.baseApplicationsTimeoutMS });
            this.logger.trace("the platform responded to the hello message with a full list of apps");
            this.applications = yield Promise.all(result.apps.map((app) => this.ioc.buildApplication(app, app.instances)));
            this.instances = this.applications.reduce((instancesSoFar, app) => {
                instancesSoFar.push(...app.instances);
                return instancesSoFar;
            }, []);
            this.me = this.findMyInstance();
            this.logger.trace(`all applications were parsed and saved. I am ${this.me ? "NOT a" : "a"} valid instance`);
        });
    }
    findMyInstance() {
        for (const app of this.applications) {
            const foundInstance = app.instances.find((instance) => instance.id === this.publicWindowId);
            if (foundInstance) {
                return foundInstance;
            }
        }
    }
}

class InstanceModel {
    constructor(data, bridge, application) {
        this.data = data;
        this.bridge = bridge;
        this.application = application;
        this.myCtxKey = `___instance___${this.data.id}`;
    }
    toApi() {
        const agm = this.bridge.getInteropInstance(this.data.id);
        const api = {
            id: this.data.id,
            agm,
            application: this.application,
            stop: this.stop.bind(this),
            getContext: this.getContext.bind(this)
        };
        this.me = Object.freeze(api);
        return this.me;
    }
    getContext() {
        return __awaiter$1(this, void 0, void 0, function* () {
            return this.bridge.contextLib.get(this.myCtxKey);
        });
    }
    stop() {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield this.bridge.send("appManager", operations$7.instanceStop, { id: this.data.id });
        });
    }
}

class ApplicationModel {
    constructor(data, instances, controller) {
        this.data = data;
        this.instances = instances;
        this.controller = controller;
    }
    toApi() {
        const api = {
            name: this.data.name,
            title: this.data.title,
            version: this.data.version,
            icon: this.data.icon,
            caption: this.data.caption,
            userProperties: this.data.userProperties,
            instances: this.instances,
            start: this.start.bind(this),
            onInstanceStarted: this.onInstanceStarted.bind(this),
            onInstanceStopped: this.onInstanceStopped.bind(this)
        };
        this.me = api;
        return this.me;
    }
    onInstanceStarted(callback) {
        if (typeof callback !== "function") {
            throw new Error("OnInstanceStarted requires a single argument of type function");
        }
        return this.controller.onInstanceStarted((instance) => {
            if (instance.application.name === this.data.name) {
                callback(instance);
            }
        });
    }
    onInstanceStopped(callback) {
        if (typeof callback !== "function") {
            throw new Error("OnInstanceStarted requires a single argument of type function");
        }
        return this.controller.onInstanceStopped((instance) => {
            if (instance.application.name === this.data.name) {
                callback(instance);
            }
        });
    }
    start(context, options) {
        return __awaiter$1(this, void 0, void 0, function* () {
            return this.controller.startApplication(this.data.name, context, options);
        });
    }
}

const operations$6 = {
    layoutAdded: { name: "layoutAdded", dataDecoder: glueLayoutDecoder },
    layoutChanged: { name: "layoutChanged", dataDecoder: glueLayoutDecoder },
    layoutRemoved: { name: "layoutRemoved", dataDecoder: glueLayoutDecoder },
    get: { name: "get", dataDecoder: simpleLayoutConfigDecoder, resultDecoder: optionalSimpleLayoutResult },
    getAll: { name: "getAll", dataDecoder: getAllLayoutsConfigDecoder, resultDecoder: allLayoutsSummariesResultDecoder },
    export: { name: "export", dataDecoder: getAllLayoutsConfigDecoder, resultDecoder: allLayoutsFullConfigDecoder },
    import: { name: "import", dataDecoder: layoutsImportConfigDecoder },
    remove: { name: "remove", dataDecoder: simpleLayoutConfigDecoder },
    save: { name: "save", dataDecoder: saveLayoutConfigDecoder, resultDecoder: simpleLayoutResultDecoder },
    restore: { name: "restore", dataDecoder: restoreLayoutConfigDecoder },
    clientSaveRequest: { name: "clientSaveRequest", dataDecoder: platformSaveRequestConfigDecoder, resultDecoder: saveRequestClientResponseDecoder },
    getGlobalPermissionState: { name: "getGlobalPermissionState", resultDecoder: permissionStateResultDecoder },
    requestGlobalPermission: { name: "requestGlobalPermission", resultDecoder: simpleAvailabilityResultDecoder },
    checkGlobalActivated: { name: "checkGlobalActivated", resultDecoder: simpleAvailabilityResultDecoder }
};

class LayoutsController {
    constructor() {
        this.defaultLayoutRestoreTimeoutMS = 120000;
        this.registry = lib$3();
    }
    handlePlatformShutdown() {
        this.registry.clear();
    }
    start(coreGlue, ioc) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger = coreGlue.logger.subLogger("layouts.controller.web");
            this.logger.trace("starting the web layouts controller");
            this.bridge = ioc.bridge;
            this.windowsController = ioc.windowsController;
            this.addOperationsExecutors();
            const api = this.toApi();
            this.logger.trace("no need for platform registration, attaching the layouts property to glue and returning");
            coreGlue.layouts = api;
        });
    }
    handleBridgeMessage(args) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const operationName = layoutsOperationTypesDecoder.runWithException(args.operation);
            const operation = operations$6[operationName];
            if (!operation.execute) {
                return;
            }
            let operationData = args.data;
            if (operation.dataDecoder) {
                operationData = operation.dataDecoder.runWithException(args.data);
            }
            return yield operation.execute(operationData);
        });
    }
    toApi() {
        const api = {
            get: this.get.bind(this),
            getAll: this.getAll.bind(this),
            export: this.export.bind(this),
            import: this.import.bind(this),
            save: this.save.bind(this),
            restore: this.restore.bind(this),
            remove: this.remove.bind(this),
            onAdded: this.onAdded.bind(this),
            onChanged: this.onChanged.bind(this),
            onRemoved: this.onRemoved.bind(this),
            onSaveRequested: this.subscribeOnSaveRequested.bind(this),
            getMultiScreenPermissionState: this.getGlobalPermissionState.bind(this),
            requestMultiScreenPermission: this.requestGlobalPermission.bind(this),
            getGlobalTypeState: this.checkGlobalActivated.bind(this)
        };
        return Object.freeze(api);
    }
    addOperationsExecutors() {
        operations$6.layoutAdded.execute = this.handleOnAdded.bind(this);
        operations$6.layoutChanged.execute = this.handleOnChanged.bind(this);
        operations$6.layoutRemoved.execute = this.handleOnRemoved.bind(this);
        operations$6.clientSaveRequest.execute = this.handleSaveRequest.bind(this);
    }
    get(name, type) {
        return __awaiter$1(this, void 0, void 0, function* () {
            nonEmptyStringDecoder.runWithException(name);
            layoutTypeDecoder.runWithException(type);
            const result = yield this.bridge.send("layouts", operations$6.get, { name, type });
            return result.layout;
        });
    }
    getAll(type) {
        return __awaiter$1(this, void 0, void 0, function* () {
            layoutTypeDecoder.runWithException(type);
            const result = yield this.bridge.send("layouts", operations$6.getAll, { type });
            return result.summaries;
        });
    }
    export(type) {
        return __awaiter$1(this, void 0, void 0, function* () {
            layoutTypeDecoder.runWithException(type);
            const result = yield this.bridge.send("layouts", operations$6.export, { type });
            return result.layouts;
        });
    }
    import(layouts, mode = "replace") {
        return __awaiter$1(this, void 0, void 0, function* () {
            importModeDecoder.runWithException(mode);
            if (!Array.isArray(layouts)) {
                throw new Error("Import must be called with an array of layouts");
            }
            if (layouts.length > 1000) {
                throw new Error("Cannot import more than 1000 layouts at once in Glue42 Core.");
            }
            const parseResult = layouts.reduce((soFar, layout) => {
                const decodeResult = glueLayoutDecoder.run(layout);
                if (decodeResult.ok) {
                    soFar.valid.push(layout);
                }
                else {
                    this.logger.warn(`A layout with name: ${layout.name} was not imported, because of error: ${JSON.stringify(decodeResult.error)}`);
                }
                return soFar;
            }, { valid: [] });
            const layoutsToImport = layouts.filter((layout) => parseResult.valid.some((validLayout) => validLayout.name === layout.name));
            yield this.bridge.send("layouts", operations$6.import, { layouts: layoutsToImport, mode });
        });
    }
    save(layout) {
        return __awaiter$1(this, void 0, void 0, function* () {
            newLayoutOptionsDecoder.runWithException(layout);
            const saveResult = yield this.bridge.send("layouts", operations$6.save, { layout });
            return saveResult.layout;
        });
    }
    restore(options) {
        return __awaiter$1(this, void 0, void 0, function* () {
            restoreOptionsDecoder.runWithException(options);
            const invocationTimeout = options.timeout ? options.timeout * 2 : this.defaultLayoutRestoreTimeoutMS;
            yield this.bridge.send("layouts", operations$6.restore, { layout: options }, { methodResponseTimeoutMs: invocationTimeout });
        });
    }
    remove(type, name) {
        return __awaiter$1(this, void 0, void 0, function* () {
            layoutTypeDecoder.runWithException(type);
            nonEmptyStringDecoder.runWithException(name);
            yield this.bridge.send("layouts", operations$6.remove, { type, name });
        });
    }
    handleSaveRequest(config) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const response = {};
            if (this.saveRequestSubscription) {
                try {
                    const onSaveRequestResponse = this.saveRequestSubscription(config);
                    response.windowContext = onSaveRequestResponse === null || onSaveRequestResponse === void 0 ? void 0 : onSaveRequestResponse.windowContext;
                }
                catch (error) {
                    this.logger.warn(`An error was thrown by the onSaveRequested callback, ignoring the callback: ${JSON.stringify(error)}`);
                }
            }
            return response;
        });
    }
    getGlobalPermissionState() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const requestResult = yield this.bridge.send("layouts", operations$6.getGlobalPermissionState, undefined);
            return requestResult;
        });
    }
    requestGlobalPermission() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const currentState = (yield this.getGlobalPermissionState()).state;
            if (currentState === "denied") {
                return { permissionGranted: false };
            }
            if (currentState === "granted") {
                return { permissionGranted: true };
            }
            const myWindow = this.windowsController.my();
            const amIWorkspaceFrame = window.glue42core.isPlatformFrame;
            if (myWindow.name !== "Platform" && !amIWorkspaceFrame) {
                throw new Error("Cannot request permission for multi-window placement from any app other than the Platform.");
            }
            const requestResult = yield this.bridge.send("layouts", operations$6.requestGlobalPermission, undefined, { methodResponseTimeoutMs: 180000 });
            return { permissionGranted: requestResult.isAvailable };
        });
    }
    checkGlobalActivated() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const requestResult = yield this.bridge.send("layouts", operations$6.checkGlobalActivated, undefined);
            return { activated: requestResult.isAvailable };
        });
    }
    onAdded(callback) {
        this.export("Global").then((layouts) => layouts.forEach((layout) => callback(layout))).catch(() => { });
        this.export("Workspace").then((layouts) => layouts.forEach((layout) => callback(layout))).catch(() => { });
        return this.registry.add(operations$6.layoutAdded.name, callback);
    }
    onChanged(callback) {
        return this.registry.add(operations$6.layoutChanged.name, callback);
    }
    onRemoved(callback) {
        return this.registry.add(operations$6.layoutRemoved.name, callback);
    }
    subscribeOnSaveRequested(callback) {
        if (typeof callback !== "function") {
            throw new Error("Cannot subscribe to onSaveRequested, because the provided argument is not a valid callback function.");
        }
        if (this.saveRequestSubscription) {
            throw new Error("Cannot subscribe to onSaveRequested, because this client has already subscribed and only one subscription is supported. Consider unsubscribing from the initial one.");
        }
        this.saveRequestSubscription = callback;
        return () => {
            delete this.saveRequestSubscription;
        };
    }
    handleOnAdded(layout) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.registry.execute(operations$6.layoutAdded.name, layout);
        });
    }
    handleOnChanged(layout) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.registry.execute(operations$6.layoutChanged.name, layout);
        });
    }
    handleOnRemoved(layout) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.registry.execute(operations$6.layoutRemoved.name, layout);
        });
    }
}

const operations$5 = {
    raiseNotification: { name: "raiseNotification", dataDecoder: raiseNotificationDecoder },
    requestPermission: { name: "requestPermission", resultDecoder: permissionRequestResultDecoder },
    notificationShow: { name: "notificationShow", dataDecoder: notificationEventPayloadDecoder },
    notificationClick: { name: "notificationClick", dataDecoder: notificationEventPayloadDecoder },
    getPermission: { name: "getPermission", resultDecoder: permissionQueryResultDecoder },
    list: { name: "list", resultDecoder: allNotificationsDataDecoder },
    notificationRaised: { name: "notificationRaised", dataDecoder: simpleNotificationDataDecoder },
    notificationClosed: { name: "notificationClosed", dataDecoder: simpleNotificationSelectDecoder },
    click: { name: "click" },
    clear: { name: "clear" },
    clearAll: { name: "clearAll" }
};

var shortidExports$1 = {};
var shortid$3 = {
  get exports(){ return shortidExports$1; },
  set exports(v){ shortidExports$1 = v; },
};

var libExports$1 = {};
var lib$2 = {
  get exports(){ return libExports$1; },
  set exports(v){ libExports$1 = v; },
};

// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed$1 = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue$1() {
    seed$1 = (seed$1 * 9301 + 49297) % 233280;
    return seed$1/(233280.0);
}

function setSeed$3(_seed_) {
    seed$1 = _seed_;
}

var randomFromSeed$3 = {
    nextValue: getNextValue$1,
    seed: setSeed$3
};

var randomFromSeed$2 = randomFromSeed$3;

var ORIGINAL$1 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet$5;
var previousSeed$1;

var shuffled$1;

function reset$1() {
    shuffled$1 = false;
}

function setCharacters$1(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet$5 !== ORIGINAL$1) {
            alphabet$5 = ORIGINAL$1;
            reset$1();
        }
        return;
    }

    if (_alphabet_ === alphabet$5) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL$1.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL$1.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL$1.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet$5 = _alphabet_;
    reset$1();
}

function characters$1(_alphabet_) {
    setCharacters$1(_alphabet_);
    return alphabet$5;
}

function setSeed$2(seed) {
    randomFromSeed$2.seed(seed);
    if (previousSeed$1 !== seed) {
        reset$1();
        previousSeed$1 = seed;
    }
}

function shuffle$1() {
    if (!alphabet$5) {
        setCharacters$1(ORIGINAL$1);
    }

    var sourceArray = alphabet$5.split('');
    var targetArray = [];
    var r = randomFromSeed$2.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed$2.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled$1() {
    if (shuffled$1) {
        return shuffled$1;
    }
    shuffled$1 = shuffle$1();
    return shuffled$1;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup$1(index) {
    var alphabetShuffled = getShuffled$1();
    return alphabetShuffled[index];
}

function get$1 () {
  return alphabet$5 || ORIGINAL$1;
}

var alphabet_1$1 = {
    get: get$1,
    characters: characters$1,
    seed: setSeed$2,
    lookup: lookup$1,
    shuffled: getShuffled$1
};

var crypto$1 = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

var randomByte$1;

if (!crypto$1 || !crypto$1.getRandomValues) {
    randomByte$1 = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
    };
} else {
    randomByte$1 = function(size) {
        return crypto$1.getRandomValues(new Uint8Array(size));
    };
}

var randomByteBrowser$1 = randomByte$1;

// This file replaces `format.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

var format_browser$1 = function (random, alphabet, size) {
  // We can’t use bytes bigger than the alphabet. To make bytes values closer
  // to the alphabet, we apply bitmask on them. We look for the closest
  // `2 ** x - 1` number, which will be bigger than alphabet size. If we have
  // 30 symbols in the alphabet, we will take 31 (00011111).
  // We do not use faster Math.clz32, because it is not available in browsers.
  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  // Bitmask is not a perfect solution (in our example it will pass 31 bytes,
  // which is bigger than the alphabet). As a result, we will need more bytes,
  // than ID size, because we will refuse bytes bigger than the alphabet.

  // Every hardware random generator call is costly,
  // because we need to wait for entropy collection. This is why often it will
  // be faster to ask for few extra bytes in advance, to avoid additional calls.

  // Here we calculate how many random bytes should we call in advance.
  // It depends on ID length, mask / alphabet size and magic number 1.6
  // (which was selected according benchmarks).

  // -~f => Math.ceil(f) if n is float number
  // -~i => i + 1 if n is integer number
  var step = -~(1.6 * mask * size / alphabet.length);
  var id = '';

  while (true) {
    var bytes = random(step);
    // Compact alternative for `for (var i = 0; i < step; i++)`
    var i = step;
    while (i--) {
      // If random byte is bigger than alphabet even after bitmask,
      // we refuse it by `|| ''`.
      id += alphabet[bytes[i] & mask] || '';
      // More compact than `id.length + 1 === size`
      if (id.length === +size) return id
    }
  }
};

var alphabet$4 = alphabet_1$1;
var random$1 = randomByteBrowser$1;
var format$1 = format_browser$1;

function generate$3(number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + format$1(random$1, alphabet$4.get(), 1);
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

var generate_1$1 = generate$3;

var generate$2 = generate_1$1;

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME$1 = 1567752802062;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version$3 = 7;

// Counter is used when shortid is called multiple times in one second.
var counter$1;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds$1;

/**
 * Generate unique id
 * Returns string id
 */
function build$1(clusterWorkerId) {
    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME$1) * 0.001);

    if (seconds === previousSeconds$1) {
        counter$1++;
    } else {
        counter$1 = 0;
        previousSeconds$1 = seconds;
    }

    str = str + generate$2(version$3);
    str = str + generate$2(clusterWorkerId);
    if (counter$1 > 0) {
        str = str + generate$2(counter$1);
    }
    str = str + generate$2(seconds);
    return str;
}

var build_1$1 = build$1;

var alphabet$3 = alphabet_1$1;

function isShortId$1(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var nonAlphabetic = new RegExp('[^' +
      alphabet$3.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
    return !nonAlphabetic.test(id);
}

var isValid$1 = isShortId$1;

(function (module) {

	var alphabet = alphabet_1$1;
	var build = build_1$1;
	var isValid = isValid$1;

	// if you are using cluster or multiple servers use this to make each instance
	// has a unique value for worker
	// Note: I don't know if this is automatically set when using third
	// party cluster solutions such as pm2.
	var clusterWorkerId = 0;

	/**
	 * Set the seed.
	 * Highly recommended if you don't want people to try to figure out your id schema.
	 * exposed as shortid.seed(int)
	 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
	 */
	function seed(seedValue) {
	    alphabet.seed(seedValue);
	    return module.exports;
	}

	/**
	 * Set the cluster worker or machine id
	 * exposed as shortid.worker(int)
	 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
	 * returns shortid module so it can be chained.
	 */
	function worker(workerId) {
	    clusterWorkerId = workerId;
	    return module.exports;
	}

	/**
	 *
	 * sets new characters to use in the alphabet
	 * returns the shuffled alphabet
	 */
	function characters(newCharacters) {
	    if (newCharacters !== undefined) {
	        alphabet.characters(newCharacters);
	    }

	    return alphabet.shuffled();
	}

	/**
	 * Generate unique id
	 * Returns string id
	 */
	function generate() {
	  return build(clusterWorkerId);
	}

	// Export all other functions as properties of the generate function
	module.exports = generate;
	module.exports.generate = generate;
	module.exports.seed = seed;
	module.exports.worker = worker;
	module.exports.characters = characters;
	module.exports.isValid = isValid;
} (lib$2));

(function (module) {
	module.exports = libExports$1;
} (shortid$3));

var shortid$2 = /*@__PURE__*/getDefaultExportFromCjs$1(shortidExports$1);

class NotificationsController {
    constructor() {
        this.registry = lib$3();
        this.notifications = {};
    }
    handlePlatformShutdown() {
        this.notifications = {};
        this.registry.clear();
    }
    start(coreGlue, ioc) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger = coreGlue.logger.subLogger("notifications.controller.web");
            this.logger.trace("starting the web notifications controller");
            this.bridge = ioc.bridge;
            this.coreGlue = coreGlue;
            this.notificationsSettings = ioc.config.notifications;
            this.buildNotificationFunc = ioc.buildNotification;
            const api = this.toApi();
            this.addOperationExecutors();
            coreGlue.notifications = api;
            this.logger.trace("notifications are ready");
        });
    }
    handleBridgeMessage(args) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const operationName = notificationsOperationTypesDecoder.runWithException(args.operation);
            const operation = operations$5[operationName];
            if (!operation.execute) {
                return;
            }
            let operationData = args.data;
            if (operation.dataDecoder) {
                operationData = operation.dataDecoder.runWithException(args.data);
            }
            return yield operation.execute(operationData);
        });
    }
    toApi() {
        const api = {
            raise: this.raise.bind(this),
            requestPermission: this.requestPermission.bind(this),
            getPermission: this.getPermission.bind(this),
            list: this.list.bind(this),
            onRaised: this.onRaised.bind(this),
            onClosed: this.onClosed.bind(this),
            click: this.click.bind(this),
            clear: this.clear.bind(this),
            clearAll: this.clearAll.bind(this)
        };
        return Object.freeze(api);
    }
    getPermission() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const queryResult = yield this.bridge.send("notifications", operations$5.getPermission, undefined);
            return queryResult.permission;
        });
    }
    requestPermission() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const permissionResult = yield this.bridge.send("notifications", operations$5.requestPermission, undefined);
            return permissionResult.permissionGranted;
        });
    }
    raise(options) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const settings = glue42NotificationOptionsDecoder.runWithException(options);
            settings.showToast = typeof settings.showToast === "boolean" ? settings.showToast : true;
            settings.showInPanel = typeof settings.showInPanel === "boolean" ? settings.showInPanel : true;
            const permissionGranted = yield this.requestPermission();
            if (!permissionGranted) {
                throw new Error("Cannot raise the notification, because the user has declined the permission request");
            }
            const id = shortidExports$1.generate();
            yield this.bridge.send("notifications", operations$5.raiseNotification, { settings, id });
            const notification = this.buildNotificationFunc(options, id);
            this.notifications[id] = notification;
            return notification;
        });
    }
    list() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const bridgeResponse = yield this.bridge.send("notifications", operations$5.list, undefined, undefined, { includeOperationCheck: true });
            return bridgeResponse.notifications;
        });
    }
    onRaised(callback) {
        if (typeof callback !== "function") {
            throw new Error("onRaised expects a callback of type function");
        }
        return this.registry.add("notification-raised", callback);
    }
    onClosed(callback) {
        if (typeof callback !== "function") {
            throw new Error("onRaised expects a callback of type function");
        }
        return this.registry.add("notification-closed", callback);
    }
    click(id, action) {
        return __awaiter$1(this, void 0, void 0, function* () {
            nonEmptyStringDecoder.runWithException(id);
            if (action) {
                nonEmptyStringDecoder.runWithException(action);
            }
            yield this.bridge.send("notifications", operations$5.click, { id, action }, undefined, { includeOperationCheck: true });
        });
    }
    clear(id) {
        return __awaiter$1(this, void 0, void 0, function* () {
            nonEmptyStringDecoder.runWithException(id);
            yield this.bridge.send("notifications", operations$5.clear, { id }, undefined, { includeOperationCheck: true });
        });
    }
    clearAll() {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield this.bridge.send("notifications", operations$5.clearAll, undefined, undefined, { includeOperationCheck: true });
        });
    }
    addOperationExecutors() {
        operations$5.notificationShow.execute = this.handleNotificationShow.bind(this);
        operations$5.notificationClick.execute = this.handleNotificationClick.bind(this);
        operations$5.notificationRaised.execute = this.handleNotificationRaised.bind(this);
        operations$5.notificationClosed.execute = this.handleNotificationClosed.bind(this);
    }
    handleNotificationShow(data) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!data.id) {
                return;
            }
            const notification = this.notifications[data.id];
            if (notification && notification.onshow) {
                notification.onshow();
            }
        });
    }
    handleNotificationClick(data) {
        var _a, _b, _c, _d, _e;
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!data.action && ((_a = this.notificationsSettings) === null || _a === void 0 ? void 0 : _a.defaultClick)) {
                this.notificationsSettings.defaultClick(this.coreGlue, data.definition);
            }
            if (data.action && ((_c = (_b = this.notificationsSettings) === null || _b === void 0 ? void 0 : _b.actionClicks) === null || _c === void 0 ? void 0 : _c.some((actionDef) => actionDef.action === data.action))) {
                const foundHandler = (_e = (_d = this.notificationsSettings) === null || _d === void 0 ? void 0 : _d.actionClicks) === null || _e === void 0 ? void 0 : _e.find((actionDef) => actionDef.action === data.action);
                foundHandler.handler(this.coreGlue, data.definition);
            }
            if (!data.id) {
                return;
            }
            const notification = this.notifications[data.id];
            if (notification && notification.onclick) {
                notification.onclick();
                delete this.notifications[data.id];
            }
        });
    }
    handleNotificationRaised(data) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.registry.execute("notification-raised", data.notification);
        });
    }
    handleNotificationClosed(data) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.registry.execute("notification-closed", data);
        });
    }
}

const operations$4 = {
    getIntents: { name: "getIntents", resultDecoder: wrappedIntentsDecoder },
    findIntent: { name: "findIntent", dataDecoder: wrappedIntentFilterDecoder, resultDecoder: wrappedIntentsDecoder },
    raiseIntent: { name: "raiseIntent", dataDecoder: intentRequestDecoder, resultDecoder: intentResultDecoder },
    raise: { name: "raise", dataDecoder: raiseIntentRequestDecoder, resultDecoder: intentResultDecoder },
};

const GLUE42_FDC3_INTENTS_METHOD_PREFIX = "Tick42.FDC3.Intents.";
const INTENTS_RESOLVER_INTEROP_PREFIX = "T42.Intents.Resolver.Control.";
const INTENTS_RESOLVER_APP_NAME = "intentsResolver";
const DEFAULT_RESOLVER_RESPONSE_TIMEOUT = 60000;
const ADDITIONAL_BRIDGE_OPERATION_TIMEOUT = 30000;
const INTENTS_RESOLVER_WIDTH = 400;
const INTENTS_RESOLVER_HEIGHT = 440;

class IntentsController {
    constructor() {
        this.myIntents = new Set();
        this.useIntentsResolverUI = true;
        this.unregisterIntentPromises = [];
    }
    start(coreGlue, ioc) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger = coreGlue.logger.subLogger("intents.controller.web");
            this.logger.trace("starting the web intents controller");
            this.bridge = ioc.bridge;
            this.interop = coreGlue.interop;
            this.legacyIntentsController = ioc.legacyIntentsHelper;
            this.checkIfIntentsResolverIsEnabled(ioc.config);
            const api = this.toApi();
            this.logger.trace("no need for platform registration, attaching the intents property to glue and returning");
            coreGlue.intents = api;
        });
    }
    handlePlatformShutdown() {
        this.myIntents = new Set();
        this.unregisterIntentPromises = [];
    }
    handleBridgeMessage(args) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const operationName = intentsOperationTypesDecoder.runWithException(args.operation);
            const operation = operations$4[operationName];
            if (!operation.execute) {
                return;
            }
            let operationData = args.data;
            if (operation.dataDecoder) {
                operationData = operation.dataDecoder.runWithException(args.data);
            }
            return yield operation.execute(operationData);
        });
    }
    toApi() {
        const api = {
            raise: this.raise.bind(this),
            all: this.all.bind(this),
            addIntentListener: this.addIntentListener.bind(this),
            register: this.register.bind(this),
            find: this.find.bind(this)
        };
        return api;
    }
    raise(request) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const validatedIntentRequest = raiseRequestDecoder.runWithException(request);
            const intentRequest = typeof validatedIntentRequest === "string"
                ? { intent: validatedIntentRequest }
                : validatedIntentRequest;
            yield Promise.all(this.unregisterIntentPromises);
            const requestWithResolverInfo = this.buildIntentRequestWithResolverInfo(intentRequest);
            const isRaiseOperationSupported = yield this.isRaiseOperationSupported();
            if (!isRaiseOperationSupported.supported) {
                this.logger.warn(`${isRaiseOperationSupported.reason}. Invoking legacy raise method`);
                return this.legacyIntentsController.raise(requestWithResolverInfo, this.find.bind(this));
            }
            this.logger.trace(`Sending raise request to the platform: ${JSON.stringify(request)} and method response timeout of ${this.intentResolverResponseTimeout}ms`);
            const response = yield this.bridge.send("intents", operations$4.raise, requestWithResolverInfo, { methodResponseTimeoutMs: this.intentResolverResponseTimeout + ADDITIONAL_BRIDGE_OPERATION_TIMEOUT });
            return response;
        });
    }
    buildIntentRequestWithResolverInfo(request) {
        return {
            intentRequest: request,
            resolverConfig: {
                enabled: this.useIntentsResolverUI,
                appName: this.intentsResolverAppName,
                waitResponseTimeout: this.intentResolverResponseTimeout
            }
        };
    }
    isRaiseOperationSupported() {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                const { isSupported } = yield this.bridge.send("intents", systemOperations.operationCheck, { operation: "raise" });
                return {
                    supported: isSupported,
                    reason: isSupported ? "" : "The platform of this client is outdated and does not support \"raise\" operation"
                };
            }
            catch (error) {
                return {
                    supported: false,
                    reason: "The platform of this client is outdated and does not support \"operationCheck\" command"
                };
            }
        });
    }
    all() {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield Promise.all(this.unregisterIntentPromises);
            const result = yield this.bridge.send("intents", operations$4.getIntents, undefined);
            return result.intents;
        });
    }
    addIntentListener(intent, handler) {
        AddIntentListenerDecoder.runWithException(intent);
        if (typeof handler !== "function") {
            throw new Error("Cannot add intent listener, because the provided handler is not a function!");
        }
        let registerPromise;
        const intentName = typeof intent === "string" ? intent : intent.intent;
        const methodName = this.buildInteropMethodName(intentName);
        const alreadyRegistered = this.myIntents.has(intentName);
        if (alreadyRegistered) {
            throw new Error(`Intent listener for intent ${intentName} already registered!`);
        }
        this.myIntents.add(intentName);
        const result = {
            unsubscribe: () => {
                this.myIntents.delete(intentName);
                registerPromise
                    .then(() => this.interop.unregister(methodName))
                    .catch((err) => this.logger.trace(`Unregistration of a method with name ${methodName} failed with reason: ${err}`));
            }
        };
        let intentFlag = {};
        if (typeof intent === "object") {
            const rest = __rest$1(intent, ["intent"]);
            intentFlag = rest;
        }
        registerPromise = this.interop.register({ name: methodName, flags: { intent: intentFlag } }, (args) => {
            if (this.myIntents.has(intentName)) {
                return handler(args);
            }
        });
        registerPromise.catch(err => {
            this.myIntents.delete(intentName);
            this.logger.warn(`Registration of a method with name ${methodName} failed with reason: ${err}`);
        });
        return result;
    }
    register(intent, handler) {
        return __awaiter$1(this, void 0, void 0, function* () {
            AddIntentListenerDecoder.runWithException(intent);
            if (typeof handler !== "function") {
                throw new Error("Cannot add intent listener, because the provided handler is not a function!");
            }
            yield Promise.all(this.unregisterIntentPromises);
            const intentName = typeof intent === "string" ? intent : intent.intent;
            const methodName = this.buildInteropMethodName(intentName);
            const alreadyRegistered = this.myIntents.has(intentName);
            if (alreadyRegistered) {
                throw new Error(`Intent listener for intent ${intentName} already registered!`);
            }
            this.myIntents.add(intentName);
            let intentFlag = {};
            if (typeof intent === "object") {
                const rest = __rest$1(intent, ["intent"]);
                intentFlag = rest;
            }
            try {
                yield this.interop.register({ name: methodName, flags: { intent: intentFlag } }, (args) => {
                    if (this.myIntents.has(intentName)) {
                        return handler(args);
                    }
                });
            }
            catch (err) {
                this.myIntents.delete(intentName);
                throw new Error(`Registration of a method with name ${methodName} failed with reason: ${JSON.stringify(err)}`);
            }
            return {
                unsubscribe: () => this.unsubscribeIntent(intentName)
            };
        });
    }
    find(intentFilter) {
        return __awaiter$1(this, void 0, void 0, function* () {
            let data = undefined;
            if (typeof intentFilter !== "undefined") {
                const intentFilterObj = findFilterDecoder.runWithException(intentFilter);
                if (typeof intentFilterObj === "string") {
                    data = {
                        filter: {
                            name: intentFilterObj
                        }
                    };
                }
                else if (typeof intentFilterObj === "object") {
                    data = {
                        filter: intentFilterObj
                    };
                }
            }
            yield Promise.all(this.unregisterIntentPromises);
            const result = yield this.bridge.send("intents", operations$4.findIntent, data);
            return result.intents;
        });
    }
    checkIfIntentsResolverIsEnabled(options) {
        var _a, _b, _c, _d, _e;
        this.useIntentsResolverUI = typeof ((_a = options.intents) === null || _a === void 0 ? void 0 : _a.enableIntentsResolverUI) === "boolean"
            ? options.intents.enableIntentsResolverUI
            : true;
        this.intentsResolverAppName = (_c = (_b = options.intents) === null || _b === void 0 ? void 0 : _b.intentsResolverAppName) !== null && _c !== void 0 ? _c : INTENTS_RESOLVER_APP_NAME;
        this.intentResolverResponseTimeout = (_e = (_d = options.intents) === null || _d === void 0 ? void 0 : _d.methodResponseTimeoutMs) !== null && _e !== void 0 ? _e : DEFAULT_RESOLVER_RESPONSE_TIMEOUT;
    }
    clearUnregistrationPromise(promiseToRemove) {
        this.unregisterIntentPromises = this.unregisterIntentPromises.filter(promise => promise !== promiseToRemove);
    }
    buildInteropMethodName(intentName) {
        return `${GLUE42_FDC3_INTENTS_METHOD_PREFIX}${intentName}`;
    }
    unsubscribeIntent(intentName) {
        this.myIntents.delete(intentName);
        const methodName = this.buildInteropMethodName(intentName);
        const unregisterPromise = this.interop.unregister(methodName);
        this.unregisterIntentPromises.push(unregisterPromise);
        unregisterPromise
            .then(() => {
            this.clearUnregistrationPromise(unregisterPromise);
        })
            .catch((err) => {
            this.logger.error(`Unregistration of a method with name ${methodName} failed with reason: ${err}`);
            this.clearUnregistrationPromise(unregisterPromise);
        });
    }
}

const Glue42CoreMessageTypes = {
    platformUnload: { name: "platformUnload" },
    transportSwitchRequest: { name: "transportSwitchRequest" },
    transportSwitchResponse: { name: "transportSwitchResponse" },
    getCurrentTransport: { name: "getCurrentTransport" },
    getCurrentTransportResponse: { name: "getCurrentTransportResponse" },
    checkPreferredLogic: { name: "checkPreferredLogic" },
    checkPreferredConnection: { name: "checkPreferredConnection" },
    checkPreferredLogicResponse: { name: "checkPreferredLogicResponse" },
    checkPreferredConnectionResponse: { name: "checkPreferredConnectionResponse" }
};
const webPlatformTransportName = "web-platform";
const latestFDC3Type = "latest_fdc3_type";

const operations$3 = {
    addChannel: { name: "addChannel", dataDecoder: channelContextDecoder },
};

class ChannelsController {
    constructor() {
        this.registry = lib$3();
        this.GlueWebChannelsPrefix = "___channel___";
        this.SubsKey = "subs";
        this.ChangedKey = "changed";
        this.replaySubscribe = (callback, channelId) => {
            this.get(channelId)
                .then((channelContext) => {
                if (typeof channelContext.data === "object" && Object.keys(channelContext.data).length) {
                    const contextName = this.createContextName(channelContext.name);
                    return this.contexts.subscribe(contextName, (context, _, __, ___, extraData) => {
                        callback(context.data, context, extraData === null || extraData === void 0 ? void 0 : extraData.updaterId);
                    });
                }
            })
                .then((un) => {
                if (un && typeof un === "function") {
                    un();
                }
            })
                .catch(err => this.logger.trace(err));
        };
    }
    handlePlatformShutdown() {
        this.registry.clear();
    }
    start(coreGlue, ioc) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger = coreGlue.logger.subLogger("channels.controller.web");
            this.logger.trace("starting the web channels controller");
            this.contexts = coreGlue.contexts;
            this.bridge = ioc.bridge;
            this.logger.trace("no need for platform registration, attaching the channels property to glue and returning");
            const api = this.toApi();
            coreGlue.channels = api;
        });
    }
    handleBridgeMessage() {
        return __awaiter$1(this, void 0, void 0, function* () {
        });
    }
    list() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const channelNames = this.getAllChannelNames();
            const channelContexts = yield Promise.all(channelNames.map((channelName) => this.get(channelName)));
            return channelContexts;
        });
    }
    my() {
        return this.current();
    }
    join(name) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const channelNames = this.getAllChannelNames();
            channelNameDecoder(channelNames).runWithException(name);
            yield this.switchToChannel(name);
        });
    }
    onChanged(callback) {
        return this.changed(callback);
    }
    leave() {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield this.switchToChannel();
        });
    }
    toApi() {
        const api = {
            subscribe: this.subscribe.bind(this),
            subscribeFor: this.subscribeFor.bind(this),
            publish: this.publish.bind(this),
            all: this.all.bind(this),
            list: this.list.bind(this),
            get: this.get.bind(this),
            join: this.join.bind(this),
            leave: this.leave.bind(this),
            current: this.current.bind(this),
            my: this.my.bind(this),
            changed: this.changed.bind(this),
            onChanged: this.onChanged.bind(this),
            add: this.add.bind(this)
        };
        return Object.freeze(api);
    }
    createContextName(channelName) {
        return `${this.GlueWebChannelsPrefix}${channelName}`;
    }
    getAllChannelNames() {
        const contextNames = this.contexts.all();
        const channelContextNames = contextNames.filter((contextName) => contextName.startsWith(this.GlueWebChannelsPrefix));
        const channelNames = channelContextNames.map((channelContextName) => channelContextName.replace(this.GlueWebChannelsPrefix, ""));
        return channelNames;
    }
    unsubscribe() {
        if (this.unsubscribeFunc) {
            this.unsubscribeFunc();
            this.unsubscribeFunc = undefined;
        }
    }
    switchToChannel(name) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.unsubscribe();
            this.currentChannelName = name;
            if (typeof name !== "undefined") {
                const contextName = this.createContextName(name);
                this.unsubscribeFunc = yield this.contexts.subscribe(contextName, (context, _, __, ___, extraData) => {
                    this.registry.execute(this.SubsKey, context.data, context, extraData === null || extraData === void 0 ? void 0 : extraData.updaterId);
                });
            }
            this.registry.execute(this.ChangedKey, name);
        });
    }
    updateData(name, data) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const contextName = this.createContextName(name);
            const fdc3Type = this.getFDC3Type(data);
            if (this.contexts.setPathSupported) {
                const pathValues = Object.keys(data).map((key) => {
                    return {
                        path: `data.${key}`,
                        value: data[key]
                    };
                });
                if (fdc3Type) {
                    pathValues.push({ path: latestFDC3Type, value: fdc3Type });
                }
                yield this.contexts.setPaths(contextName, pathValues);
            }
            else {
                if (fdc3Type) {
                    data[latestFDC3Type] = fdc3Type;
                }
                yield this.contexts.update(contextName, { data });
            }
        });
    }
    getFDC3Type(data) {
        const fdc3PropsArr = Object.keys(data).filter((key) => key.indexOf("fdc3_") === 0);
        if (fdc3PropsArr.length === 0) {
            return;
        }
        if (fdc3PropsArr.length > 1) {
            throw new Error("FDC3 does not support updating of multiple context keys");
        }
        return fdc3PropsArr[0].split("_").slice(1).join("_");
    }
    subscribe(callback) {
        if (typeof callback !== "function") {
            throw new Error("Cannot subscribe to channels, because the provided callback is not a function!");
        }
        const currentChannel = this.current();
        if (currentChannel) {
            this.replaySubscribe(callback, currentChannel);
        }
        return this.registry.add(this.SubsKey, callback);
    }
    subscribeFor(name, callback) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const channelNames = this.getAllChannelNames();
            channelNameDecoder(channelNames).runWithException(name);
            if (typeof callback !== "function") {
                throw new Error(`Cannot subscribe to channel ${name}, because the provided callback is not a function!`);
            }
            const contextName = this.createContextName(name);
            return this.contexts.subscribe(contextName, (context, _, __, ___, extraData) => {
                callback(context.data, context, extraData === null || extraData === void 0 ? void 0 : extraData.updaterId);
            });
        });
    }
    publish(data, name) {
        if (typeof data !== "object") {
            throw new Error("Cannot publish to channel, because the provided data is not an object!");
        }
        if (typeof name !== "undefined") {
            const channelNames = this.getAllChannelNames();
            channelNameDecoder(channelNames).runWithException(name);
            return this.updateData(name, data);
        }
        if (typeof this.currentChannelName === "undefined") {
            throw new Error("Cannot publish to channel, because not joined to a channel!");
        }
        return this.updateData(this.currentChannelName, data);
    }
    all() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const channelNames = this.getAllChannelNames();
            return channelNames;
        });
    }
    get(name) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const channelNames = this.getAllChannelNames();
            channelNameDecoder(channelNames).runWithException(name);
            const contextName = this.createContextName(name);
            const channelContext = yield this.contexts.get(contextName);
            if (channelContext.latest_fdc3_type) {
                const rest = __rest$1(channelContext, ["latest_fdc3_type"]);
                return Object.assign({}, rest);
            }
            return channelContext;
        });
    }
    current() {
        return this.currentChannelName;
    }
    changed(callback) {
        if (typeof callback !== "function") {
            throw new Error("Cannot subscribe to channel changed, because the provided callback is not a function!");
        }
        return this.registry.add(this.ChangedKey, callback);
    }
    add(info) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const channelContext = channelContextDecoder.runWithException(info);
            const channelWithSuchNameExists = this.getAllChannelNames().includes(channelContext.name);
            if (channelWithSuchNameExists) {
                throw new Error("There's an already existing channel with such name");
            }
            yield this.bridge.send("channels", operations$3.addChannel, channelContext);
            return channelContext;
        });
    }
}

const operations$2 = {
    getEnvironment: { name: "getEnvironment", resultDecoder: anyDecoder },
    getBase: { name: "getBase", resultDecoder: anyDecoder },
    platformShutdown: { name: "platformShutdown" }
};

class SystemController {
    start(coreGlue, ioc) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.bridge = ioc.bridge;
            this.ioc = ioc;
            this.addOperationsExecutors();
            yield this.setEnvironment();
        });
    }
    handleBridgeMessage(args) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const operationName = systemOperationTypesDecoder.runWithException(args.operation);
            const operation = operations$2[operationName];
            if (!operation.execute) {
                return;
            }
            let operationData = args.data;
            if (operation.dataDecoder) {
                operationData = operation.dataDecoder.runWithException(args.data);
            }
            return yield operation.execute(operationData);
        });
    }
    processPlatformShutdown() {
        return __awaiter$1(this, void 0, void 0, function* () {
            Object.values(this.ioc.controllers).forEach((controller) => controller.handlePlatformShutdown ? controller.handlePlatformShutdown() : null);
            this.ioc.preferredConnectionController.stop();
            this.ioc.eventsDispatcher.stop();
            yield this.bridge.stop();
        });
    }
    setEnvironment() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const environment = yield this.bridge.send("system", operations$2.getEnvironment, undefined);
            const base = yield this.bridge.send("system", operations$2.getBase, undefined);
            const glue42core = Object.assign({}, window.glue42core, base, { environment });
            window.glue42core = Object.freeze(glue42core);
        });
    }
    addOperationsExecutors() {
        operations$2.platformShutdown.execute = this.processPlatformShutdown.bind(this);
    }
}

class Notification {
    constructor(config, id) {
        this.onclick = () => { };
        this.onshow = () => { };
        this.id = id;
        this.badge = config.badge;
        this.body = config.body;
        this.data = config.data;
        this.dir = config.dir;
        this.icon = config.icon;
        this.image = config.image;
        this.lang = config.lang;
        this.renotify = config.renotify;
        this.requireInteraction = config.requireInteraction;
        this.silent = config.silent;
        this.tag = config.tag;
        this.timestamp = config.timestamp;
        this.vibrate = config.vibrate;
        this.title = config.title;
        this.clickInterop = config.clickInterop;
        this.actions = config.actions;
        this.focusPlatformOnDefaultClick = config.focusPlatformOnDefaultClick;
        this.severity = config.severity;
        this.showToast = config.showToast;
        this.showInPanel = config.showInPanel;
    }
}

oneOf(constant("clientHello"));
const extensionConfigDecoder = object({
    widget: object({
        inject: boolean()
    })
});

const operations$1 = {
    clientHello: { name: "clientHello", resultDecoder: extensionConfigDecoder }
};

class ExtController {
    constructor() {
        this.channels = [];
        this.unsubFuncs = [];
        this.contentCommands = {
            widgetVisualizationPermission: { name: "widgetVisualizationPermission", handle: this.handleWidgetVisualizationPermission.bind(this) },
            changeChannel: { name: "changeChannel", handle: this.handleChangeChannel.bind(this) }
        };
    }
    handlePlatformShutdown() {
        this.unsubFuncs.forEach((unsub) => unsub());
        this.channels = [];
        this.unsubFuncs = [];
    }
    start(coreGlue, ioc) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger = coreGlue.logger.subLogger("extension.controller.web");
            this.windowId = ioc.publicWindowId;
            this.logger.trace("starting the extension web controller");
            this.bridge = ioc.bridge;
            this.channelsController = ioc.channelsController;
            this.eventsDispatcher = ioc.eventsDispatcher;
            try {
                yield this.registerWithPlatform();
            }
            catch (error) {
                return;
            }
            this.channels = yield this.channelsController.list();
            const unsubDispatcher = this.eventsDispatcher.onContentMessage(this.handleContentMessage.bind(this));
            const unsubChannels = this.channelsController.onChanged((channel) => {
                this.eventsDispatcher.sendContentMessage({ command: "channelChange", newChannel: channel });
            });
            this.unsubFuncs.push(unsubDispatcher);
            this.unsubFuncs.push(unsubChannels);
        });
    }
    handleBridgeMessage(_) {
        return __awaiter$1(this, void 0, void 0, function* () {
        });
    }
    handleContentMessage(message) {
        if (!message || typeof message.command !== "string") {
            return;
        }
        const foundHandler = this.contentCommands[message.command];
        if (!foundHandler) {
            return;
        }
        foundHandler.handle(message);
    }
    registerWithPlatform() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger.trace("registering with the platform");
            this.config = yield this.bridge.send("extension", operations$1.clientHello, { windowId: this.windowId });
            this.logger.trace("the platform responded to the hello message with a valid extension config");
        });
    }
    handleWidgetVisualizationPermission() {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
            if (!((_a = this.config) === null || _a === void 0 ? void 0 : _a.widget.inject)) {
                return this.eventsDispatcher.sendContentMessage({ command: "permissionResponse", allowed: false });
            }
            const currentChannel = this.channels.find((channel) => channel.name === this.channelsController.my());
            this.eventsDispatcher.sendContentMessage({ command: "permissionResponse", allowed: true, channels: this.channels, currentChannel });
        });
    }
    handleChangeChannel(message) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (message.name === "no-channel") {
                yield this.channelsController.leave();
                return;
            }
            yield this.channelsController.join(message.name);
        });
    }
}

class EventsDispatcher {
    constructor(config) {
        this.config = config;
        this.registry = lib$3();
        this.glue42EventName = "Glue42";
        this.events = {
            notifyStarted: { name: "notifyStarted", handle: this.handleNotifyStarted.bind(this) },
            contentInc: { name: "contentInc", handle: this.handleContentInc.bind(this) },
            requestGlue: { name: "requestGlue", handle: this.handleRequestGlue.bind(this) }
        };
    }
    stop() {
        window.removeEventListener(this.glue42EventName, this._handleMessage);
    }
    start(glue) {
        this.glue = glue;
        this.wireCustomEventListener();
        this.announceStarted();
    }
    sendContentMessage(message) {
        this.send("contentOut", "glue42core", message);
    }
    onContentMessage(callback) {
        return this.registry.add("content-inc", callback);
    }
    wireCustomEventListener() {
        this._handleMessage = this.handleMessage.bind(this);
        window.addEventListener(this.glue42EventName, this._handleMessage);
    }
    handleMessage(event) {
        var _a;
        const data = event.detail;
        const namespace = (_a = data === null || data === void 0 ? void 0 : data.glue42) !== null && _a !== void 0 ? _a : data === null || data === void 0 ? void 0 : data.glue42core;
        if (!namespace) {
            return;
        }
        const glue42Event = namespace.event;
        const foundHandler = this.events[glue42Event];
        if (!foundHandler) {
            return;
        }
        foundHandler.handle(namespace.message);
    }
    announceStarted() {
        this.send("start", "glue42");
    }
    handleRequestGlue() {
        if (!this.config.exposeGlue) {
            this.send("requestGlueResponse", "glue42", { error: "Will not give access to the underlying Glue API, because it was explicitly denied upon initialization." });
            return;
        }
        this.send("requestGlueResponse", "glue42", { glue: this.glue });
    }
    handleNotifyStarted() {
        this.announceStarted();
    }
    handleContentInc(message) {
        this.registry.execute("content-inc", message);
    }
    send(eventName, namespace, message) {
        const payload = {};
        payload[namespace] = { event: eventName, message };
        const event = new CustomEvent(this.glue42EventName, { detail: payload });
        window.dispatchEvent(event);
    }
}

class PreferredConnectionController {
    constructor(coreGlue) {
        this.coreGlue = coreGlue;
        this.transactionTimeout = 15000;
        this.transactionLocks = {};
        this.reconnectCounter = 0;
        this.logger = this.coreGlue.logger.subLogger("web.preferred.connection.controller");
    }
    stop() {
        if (!this.webPlatformMessagesUnsubscribe) {
            return;
        }
        this.webPlatformMessagesUnsubscribe();
    }
    start(coreConfig) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (coreConfig.isPlatformInternal) {
                this.logger.trace("This is an internal client to the platform, skipping all client preferred communication logic.");
                return;
            }
            const isConnectedToPlatform = this.coreGlue.connection.transport.name() === webPlatformTransportName;
            if (!isConnectedToPlatform) {
                throw new Error("Cannot initiate the Glue Web Bridge, because the initial connection was not handled by a Web Platform transport.");
            }
            if (!this.coreGlue.connection.transport.isPreferredActivated) {
                this.logger.trace("The platform of this client was configured without a preferred connection, skipping the rest of the initialization.");
                return;
            }
            this.webPlatformTransport = this.coreGlue.connection.transport;
            this.webPlatformMessagesUnsubscribe = this.webPlatformTransport.onMessage(this.handleWebPlatformMessage.bind(this));
            const transportState = yield this.getCurrentPlatformTransportState();
            yield this.checkSwitchTransport(transportState);
        });
    }
    handleWebPlatformMessage(msg) {
        if (typeof msg === "string") {
            return;
        }
        const isConnectedToPlatform = this.coreGlue.connection.transport.name() === webPlatformTransportName;
        const type = msg.type;
        const args = msg.args;
        const transactionId = msg.transactionId;
        if (type === Glue42CoreMessageTypes.transportSwitchRequest.name) {
            return this.handleTransportSwitchRequest(args, transactionId);
        }
        if (type === Glue42CoreMessageTypes.platformUnload.name && !isConnectedToPlatform) {
            return this.handlePlatformUnload();
        }
        if (type === Glue42CoreMessageTypes.getCurrentTransportResponse.name) {
            return this.handleGetCurrentTransportResponse(args, transactionId);
        }
        if (type === Glue42CoreMessageTypes.checkPreferredLogic.name) {
            return this.handleCheckPreferredLogic(transactionId);
        }
        if (type === Glue42CoreMessageTypes.checkPreferredConnection.name) {
            return this.handleCheckPreferredConnection(args, transactionId);
        }
    }
    reEstablishPlatformPort() {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                yield this.webPlatformTransport.connect();
            }
            catch (error) {
                this.logger.trace(`Error when re-establishing port connection to the platform: ${JSON.stringify(error)}`);
                --this.reconnectCounter;
                if (this.reconnectCounter > 0) {
                    return this.reEstablishPlatformPort();
                }
                this.logger.warn("This client lost connection to the platform while connected to a preferred GW and was not able to re-connect to the platform.");
            }
            this.logger.trace("The connection to the platform was re-established, closing the connection to the web gateway.");
            this.reconnectCounter = 0;
            this.webPlatformTransport.close();
            const transportState = yield this.getCurrentPlatformTransportState();
            yield this.checkSwitchTransport(transportState);
        });
    }
    checkSwitchTransport(config) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const myCurrentTransportName = this.coreGlue.connection.transport.name();
            if (myCurrentTransportName === config.transportName) {
                this.logger.trace("A check switch was requested, but the platform transport and my transport are identical, no switch is necessary");
                return;
            }
            this.logger.trace(`A check switch was requested and a transport switch is necessary, because this client is now on ${myCurrentTransportName}, but it should reconnect to ${JSON.stringify(config)}`);
            const result = yield this.coreGlue.connection.switchTransport(config);
            this.setConnected();
            this.logger.trace(`The transport switch was completed with result: ${JSON.stringify(result)}`);
        });
    }
    getCurrentPlatformTransportState() {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger.trace("Requesting the current transport state of the platform.");
            const transaction = this.setTransaction(Glue42CoreMessageTypes.getCurrentTransport.name);
            this.sendPlatformMessage(Glue42CoreMessageTypes.getCurrentTransport.name, transaction.id);
            const transportState = yield transaction.lock;
            this.logger.trace(`The platform responded with transport state: ${JSON.stringify(transportState)}`);
            return transportState;
        });
    }
    setTransaction(operation) {
        const transaction = {};
        const transactionId = shortidExports$1.generate();
        const transactionLock = new Promise((resolve, reject) => {
            let transactionLive = true;
            transaction.lift = (args) => {
                transactionLive = false;
                delete this.transactionLocks[transactionId];
                resolve(args);
            };
            transaction.fail = (reason) => {
                transactionLive = false;
                delete this.transactionLocks[transactionId];
                reject(reason);
            };
            setTimeout(() => {
                if (!transactionLive) {
                    return;
                }
                transactionLive = false;
                this.logger.warn(`Transaction for operation: ${operation} timed out.`);
                delete this.transactionLocks[transactionId];
                reject(`Transaction for operation: ${operation} timed out.`);
            }, this.transactionTimeout);
        });
        transaction.lock = transactionLock;
        transaction.id = transactionId;
        this.transactionLocks[transactionId] = transaction;
        return transaction;
    }
    sendPlatformMessage(type, transactionId, args) {
        this.logger.trace(`Sending a platform message of type: ${type}, id: ${transactionId} and args: ${JSON.stringify(args)}`);
        this.webPlatformTransport.sendObject({
            glue42core: { type, args, transactionId }
        });
    }
    handleTransportSwitchRequest(args, transactionId) {
        this.logger.trace(`Received a transport switch request with id: ${transactionId} and data: ${JSON.stringify(args)}`);
        this.coreGlue.connection.switchTransport(args.switchSettings)
            .then((result) => {
            this.logger.trace(`The transport switch was completed with result: ${JSON.stringify(result)}`);
            this.setConnected();
            this.sendPlatformMessage(Glue42CoreMessageTypes.transportSwitchResponse.name, transactionId, { success: result.success });
        })
            .catch((error) => {
            this.logger.error(error);
            this.sendPlatformMessage(Glue42CoreMessageTypes.transportSwitchResponse.name, transactionId, { success: false });
        });
    }
    handlePlatformUnload() {
        this.reconnectCounter = 5;
        this.logger.trace("The platform was unloaded while I am connected to a preferred connection, re-establishing the port connection.");
        this.reEstablishPlatformPort();
    }
    handleGetCurrentTransportResponse(args, transactionId) {
        this.logger.trace(`Got a current transport response from the platform with id: ${transactionId} and data: ${JSON.stringify(args)}`);
        const transportState = args.transportState;
        const transaction = this.transactionLocks[transactionId];
        transaction === null || transaction === void 0 ? void 0 : transaction.lift(transportState);
    }
    handleCheckPreferredLogic(transactionId) {
        setTimeout(() => this.sendPlatformMessage(Glue42CoreMessageTypes.checkPreferredLogicResponse.name, transactionId), 0);
    }
    handleCheckPreferredConnection(args, transactionId) {
        const url = args.url;
        this.logger.trace(`Testing the possible connection to: ${url}`);
        this.checkPreferredConnection(url)
            .then((result) => {
            this.logger.trace(`The connection to ${url} is possible`);
            this.sendPlatformMessage(Glue42CoreMessageTypes.checkPreferredConnectionResponse.name, transactionId, result);
        })
            .catch((error) => {
            this.logger.trace(`The connection to ${url} is not possible`);
            this.sendPlatformMessage(Glue42CoreMessageTypes.checkPreferredConnectionResponse.name, transactionId, { error });
        });
    }
    checkPreferredConnection(url) {
        return new Promise((resolve) => {
            const ws = new WebSocket(url);
            ws.onerror = () => resolve({ live: false });
            ws.onopen = () => {
                ws.close();
                resolve({ live: true });
            };
        });
    }
    setConnected() {
        this.webPlatformTransport.manualSetReadyState();
    }
}

class LegacyIntentsHelper {
    constructor(logger, bridge, interop, appManagerController, windowsController) {
        this.bridge = bridge;
        this.interop = interop;
        this.appManagerController = appManagerController;
        this.windowsController = windowsController;
        this.intentsResolverResponsePromises = {};
        this.logger = this.configureLogger(logger);
    }
    raise(requestWithResolverInfo, findIntentFn) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
            const { intentRequest, resolverConfig } = requestWithResolverInfo;
            const intent = (yield findIntentFn(intentRequest.intent)).find(intent => intent.name === intentRequest.intent);
            if (!intent) {
                throw new Error(`Intent with name ${intentRequest.intent} not found`);
            }
            const { open, reason } = this.checkIfResolverShouldBeOpened(intent, intentRequest, resolverConfig);
            if (!open) {
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace(`Intent Resolver UI won't be used. Reason: ${reason}`);
                return this.invokeRaiseIntent(intentRequest);
            }
            const intentResult = yield this.raiseIntentWithResolverApp(requestWithResolverInfo);
            return intentResult;
        });
    }
    configureLogger(loggerInst) {
        return loggerInst.subLogger("intents.legacy.helper.web");
    }
    raiseIntentWithResolverApp(requestWithResolverInfo) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const { intentRequest, resolverConfig } = requestWithResolverInfo;
            this.logger.trace(`Intents Resolver UI with app name ${resolverConfig.appName} will be used`);
            const responseMethodName = yield this.registerResponseMethod();
            this.logger.trace(`Registered interop method ${responseMethodName}`);
            const resolverInstance = yield this.openIntentResolverApplication(requestWithResolverInfo, responseMethodName);
            this.logger.trace(`Intents Resolver Instance with id ${resolverInstance.id} opened`);
            const handler = yield this.handleInstanceResponse(resolverInstance.id);
            const target = handler.type === "app"
                ? { app: handler.applicationName }
                : { instance: handler.instanceId };
            this.logger.trace(`Intent handler chosen by the user: ${JSON.stringify(target)}`);
            const intentResult = yield this.invokeRaiseIntent(Object.assign(Object.assign({}, intentRequest), { target }));
            return intentResult;
        });
    }
    handleInstanceResponse(instanceId) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                const { handler, intent } = yield this.intentsResolverResponsePromises[instanceId].promise;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace(`Intent handler chosen for intent ${intent}: ${JSON.stringify(handler)}`);
                this.stopResolverInstance(instanceId);
                return handler;
            }
            catch (error) {
                this.stopResolverInstance(instanceId);
                throw new Error(error);
            }
        });
    }
    invokeRaiseIntent(requestObj) {
        return this.bridge.send("intents", operations$4.raiseIntent, requestObj);
    }
    registerResponseMethod() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const methodName = INTENTS_RESOLVER_INTEROP_PREFIX + shortid$2();
            yield this.interop.register(methodName, this.resolverResponseHandler.bind(this));
            return methodName;
        });
    }
    openIntentResolverApplication(requestWithResolverInfo, methodName) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const { intentRequest, resolverConfig } = requestWithResolverInfo;
            const startContext = this.buildStartContext(intentRequest, methodName);
            const startOptions = yield this.buildStartOptions();
            this.logger.trace(`Starting Intents Resolver UI with context: ${JSON.stringify(startContext)} and options: ${startOptions}`);
            const instance = yield this.appManagerController.getApplication(resolverConfig.appName).start(startContext, startOptions);
            this.logger.trace(`Intents Resolver instance with id ${instance.id} opened`);
            this.subscribeOnInstanceStopped(instance);
            this.createResponsePromise(intentRequest.intent, instance.id, methodName, resolverConfig.waitResponseTimeout);
            return instance;
        });
    }
    cleanUpIntentResolverPromise(instanceId) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const intentPromise = this.intentsResolverResponsePromises[instanceId];
            if (!intentPromise) {
                return;
            }
            const unregisterPromise = this.interop.unregister(intentPromise.methodName);
            unregisterPromise.catch((error) => this.logger.warn(error));
            delete this.intentsResolverResponsePromises[instanceId];
        });
    }
    buildStartContext(requestObj, methodName) {
        return {
            intent: requestObj,
            callerId: this.interop.instance.instance,
            methodName
        };
    }
    buildStartOptions() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const bounds = yield this.getTargetBounds();
            return {
                top: (bounds.height - INTENTS_RESOLVER_HEIGHT) / 2 + bounds.top,
                left: (bounds.width - INTENTS_RESOLVER_WIDTH) / 2 + bounds.left,
                width: INTENTS_RESOLVER_WIDTH,
                height: INTENTS_RESOLVER_HEIGHT
            };
        });
    }
    getTargetBounds() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const bounds = (yield this.tryGetWindowBasedBounds()) || (yield this.tryGetWorkspaceBasedBounds());
            if (bounds) {
                this.logger.trace(`Opening Intents Resolver UI with bounds: ${JSON.stringify(bounds)}`);
                return bounds;
            }
            const defaultBounds = {
                top: window.screen.availTop || 0,
                left: window.screen.availLeft || 0,
                width: window.screen.width,
                height: window.screen.height
            };
            this.logger.trace(`Opening Intents Resolver UI relative to my screen bounds: ${JSON.stringify(defaultBounds)}`);
            return defaultBounds;
        });
    }
    tryGetWindowBasedBounds() {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                const myWindowBounds = yield this.windowsController.my().getBounds();
                this.logger.trace(`Opening the resolver UI relative to my window bounds: ${JSON.stringify(myWindowBounds)}`);
                return myWindowBounds;
            }
            catch (error) {
                this.logger.trace(`Failure to get my window bounds: ${JSON.stringify(error)}`);
            }
        });
    }
    tryGetWorkspaceBasedBounds() {
        return __awaiter$1(this, void 0, void 0, function* () {
            try {
                yield this.bridge.send("workspaces", systemOperations.operationCheck, { operation: "getWorkspaceWindowFrameBounds" });
                const bridgeResponse = yield this.bridge.send("workspaces", systemOperations.getWorkspaceWindowFrameBounds, { itemId: this.windowsController.my().id });
                const myWorkspaceBounds = bridgeResponse.bounds;
                this.logger.trace(`Opening the resolver UI relative to my workspace frame window bounds: ${JSON.stringify(myWorkspaceBounds)}`);
                return myWorkspaceBounds;
            }
            catch (error) {
                this.logger.trace(`Failure to get my workspace frame window bounds: ${JSON.stringify(error)}`);
            }
        });
    }
    subscribeOnInstanceStopped(instance) {
        const { application } = instance;
        const unsub = application.onInstanceStopped((inst) => {
            if (inst.id !== instance.id) {
                return;
            }
            const intentPromise = this.intentsResolverResponsePromises[inst.id];
            if (!intentPromise) {
                return unsub();
            }
            intentPromise.reject(`Cannot resolve raised intent "${intentPromise.intent}" - User closed ${application.name} app without choosing an intent handler`);
            this.cleanUpIntentResolverPromise(inst.id);
            unsub();
        });
    }
    createResponsePromise(intent, instanceId, methodName, timeout) {
        let resolve = () => { };
        let reject = () => { };
        const promise = PromisePlus$1((res, rej) => {
            resolve = res;
            reject = rej;
        }, timeout, `Timeout of ${timeout}ms hit waiting for the user to choose a handler for intent ${intent}`);
        this.intentsResolverResponsePromises[instanceId] = { intent, resolve, reject, promise, methodName };
    }
    resolverResponseHandler(args, callerId) {
        const response = intentResolverResponseDecoder.run(args);
        const instanceId = callerId.instance;
        if (response.ok) {
            this.logger.trace(`Intent Resolver instance with id ${instanceId} send a valid response: ${JSON.stringify(response.result)}`);
            return this.intentsResolverResponsePromises[instanceId].resolve(response.result);
        }
        this.logger.trace(`Intent Resolver instance with id ${instanceId} sent an invalid response. Error: ${JSON.stringify(response.error)}`);
        this.intentsResolverResponsePromises[instanceId].reject(response.error.message);
        this.stopResolverInstance(instanceId);
    }
    stopResolverInstance(instanceId) {
        const searchedInstance = this.appManagerController.getInstances().find((inst) => inst.id === instanceId);
        if (!searchedInstance) {
            return;
        }
        searchedInstance.stop().catch(err => this.logger.error(err));
    }
    checkIfIntentHasMoreThanOneHandler(intent, request) {
        if (typeof request.target === "object") {
            return false;
        }
        return request.handlers ? request.handlers.length > 1 : intent.handlers.length > 1;
    }
    checkIfResolverShouldBeOpened(intent, intentRequest, resolverConfig) {
        if (!resolverConfig.enabled) {
            return { open: false, reason: `Intent Resolver is disabled. Raising intent to first found handler` };
        }
        const intentsResolverApp = this.appManagerController.getApplication(resolverConfig.appName);
        if (!intentsResolverApp) {
            return { open: false, reason: `Application with name ${resolverConfig.appName} not found` };
        }
        const hasMoreThanOneHandler = this.checkIfIntentHasMoreThanOneHandler(intent, intentRequest);
        if (!hasMoreThanOneHandler) {
            return { open: false, reason: `Raised intent has only one handler` };
        }
        return { open: true };
    }
}

const operations = {
    getCurrent: { name: "getCurrent", resultDecoder: simpleThemeResponseDecoder },
    list: { name: "list", resultDecoder: allThemesResponseDecoder },
    select: { name: "select", dataDecoder: selectThemeConfigDecoder }
};

class ThemesController {
    constructor() {
        this.registry = lib$3();
        this.activeThemeSubs = 0;
    }
    start(coreGlue, ioc) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.logger = coreGlue.logger.subLogger("themes.controller.web");
            this.logger.trace("starting the web themes controller");
            this.bridge = ioc.bridge;
            const api = this.toApi();
            coreGlue.themes = api;
            this.logger.trace("themes are ready");
        });
    }
    handlePlatformShutdown() {
        var _a;
        this.registry.clear();
        this.activeThemeSubs = 0;
        (_a = this.themesSubscription) === null || _a === void 0 ? void 0 : _a.close();
        delete this.themesSubscription;
    }
    handleBridgeMessage() {
        return __awaiter$1(this, void 0, void 0, function* () {
        });
    }
    toApi() {
        const api = {
            getCurrent: this.getCurrent.bind(this),
            list: this.list.bind(this),
            select: this.select.bind(this),
            onChanged: this.onChanged.bind(this)
        };
        return Object.freeze(api);
    }
    getCurrent() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const bridgeResponse = yield this.bridge.send("themes", operations.getCurrent, undefined, undefined, { includeOperationCheck: true });
            return bridgeResponse.theme;
        });
    }
    list() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const bridgeResponse = yield this.bridge.send("themes", operations.list, undefined, undefined, { includeOperationCheck: true });
            return bridgeResponse.themes;
        });
    }
    select(name) {
        return __awaiter$1(this, void 0, void 0, function* () {
            nonEmptyStringDecoder.runWithException(name);
            yield this.bridge.send("themes", operations.select, { name }, undefined, { includeOperationCheck: true });
        });
    }
    onChanged(callback) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (typeof callback !== "function") {
                throw new Error("onChanged requires a callback of type function");
            }
            const subReady = this.themesSubscription ?
                Promise.resolve() :
                this.configureThemeSubscription();
            yield subReady;
            ++this.activeThemeSubs;
            const unsubFunc = this.registry.add("on-theme-change", callback);
            return () => this.themeUnsub(unsubFunc);
        });
    }
    configureThemeSubscription() {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (this.themesSubscription) {
                return;
            }
            this.themesSubscription = yield this.bridge.createNotificationsSteam();
            this.themesSubscription.onData((data) => {
                const eventData = data.data;
                const validation = simpleThemeResponseDecoder.run(eventData);
                if (!validation.ok) {
                    this.logger.warn(`Received invalid theme data on the theme event stream: ${JSON.stringify(validation.error)}`);
                    return;
                }
                const themeChanged = validation.result;
                this.registry.execute("on-theme-change", themeChanged.theme);
            });
            this.themesSubscription.onClosed(() => {
                this.logger.warn("The Themes interop stream was closed, no theme changes notifications will be received");
                this.registry.clear();
                this.activeThemeSubs = 0;
                delete this.themesSubscription;
            });
        });
    }
    themeUnsub(registryUnsub) {
        var _a;
        registryUnsub();
        --this.activeThemeSubs;
        if (this.activeThemeSubs) {
            return;
        }
        (_a = this.themesSubscription) === null || _a === void 0 ? void 0 : _a.close();
        delete this.themesSubscription;
    }
}

class IoC {
    constructor() {
        this.controllers = {
            windows: this.windowsController,
            appManager: this.appManagerController,
            layouts: this.layoutsController,
            notifications: this.notificationsController,
            intents: this.intentsController,
            channels: this.channelsController,
            system: this.systemController,
            extension: this.extensionController,
            themes: this.themesController
        };
    }
    get communicationId() {
        return this._communicationId;
    }
    get publicWindowId() {
        return this._publicWindowId;
    }
    get windowsController() {
        if (!this._windowsControllerInstance) {
            this._windowsControllerInstance = new WindowsController();
        }
        return this._windowsControllerInstance;
    }
    get appManagerController() {
        if (!this._appManagerControllerInstance) {
            this._appManagerControllerInstance = new AppManagerController();
        }
        return this._appManagerControllerInstance;
    }
    get layoutsController() {
        if (!this._layoutsControllerInstance) {
            this._layoutsControllerInstance = new LayoutsController();
        }
        return this._layoutsControllerInstance;
    }
    get themesController() {
        if (!this._themesControllerInstance) {
            this._themesControllerInstance = new ThemesController();
        }
        return this._themesControllerInstance;
    }
    get notificationsController() {
        if (!this._notificationsControllerInstance) {
            this._notificationsControllerInstance = new NotificationsController();
        }
        return this._notificationsControllerInstance;
    }
    get intentsController() {
        if (!this._intentsControllerInstance) {
            this._intentsControllerInstance = new IntentsController();
        }
        return this._intentsControllerInstance;
    }
    get legacyIntentsHelper() {
        if (!this._legacyIntentsHelperInstance) {
            this._legacyIntentsHelperInstance = new LegacyIntentsHelper(this._coreGlue.logger, this.bridge, this._coreGlue.interop, this.appManagerController, this.windowsController);
        }
        return this._legacyIntentsHelperInstance;
    }
    get systemController() {
        if (!this._systemControllerInstance) {
            this._systemControllerInstance = new SystemController();
        }
        return this._systemControllerInstance;
    }
    get channelsController() {
        if (!this._channelsControllerInstance) {
            this._channelsControllerInstance = new ChannelsController();
        }
        return this._channelsControllerInstance;
    }
    get extensionController() {
        if (!this._extensionController) {
            this._extensionController = new ExtController();
        }
        return this._extensionController;
    }
    get eventsDispatcher() {
        if (!this._eventsDispatcher) {
            this._eventsDispatcher = new EventsDispatcher(this.config);
        }
        return this._eventsDispatcher;
    }
    get bridge() {
        if (!this._bridgeInstance) {
            this._bridgeInstance = new GlueBridge(this._coreGlue, this.communicationId);
        }
        return this._bridgeInstance;
    }
    get preferredConnectionController() {
        if (!this._preferredConnectionController) {
            this._preferredConnectionController = new PreferredConnectionController(this._coreGlue);
        }
        return this._preferredConnectionController;
    }
    get config() {
        return this._webConfig;
    }
    defineGlue(coreGlue) {
        this._coreGlue = coreGlue;
        this._publicWindowId = coreGlue.connection.transport.publicWindowId;
        this._communicationId = coreGlue.connection.transport.communicationId || window.glue42core.communicationId;
    }
    defineConfig(config) {
        this._webConfig = config;
    }
    buildWebWindow(id, name) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const model = new WebWindowModel(id, name, this.bridge);
            const api = yield model.toApi();
            return { id, model, api };
        });
    }
    buildNotification(config, id) {
        return new Notification(config, id);
    }
    buildApplication(app, applicationInstances) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const application = (new ApplicationModel(app, [], this.appManagerController)).toApi();
            const instances = applicationInstances.map((instanceData) => this.buildInstance(instanceData, application));
            application.instances.push(...instances);
            return application;
        });
    }
    buildInstance(instanceData, app) {
        return (new InstanceModel(instanceData, this.bridge, app)).toApi();
    }
}

var version$2 = "2.19.1";

const createFactoryFunction = (coreFactoryFunction) => {
    return (userConfig) => __awaiter$1(void 0, void 0, void 0, function* () {
        if (window.glue42gd) {
            return enterprise(userConfig);
        }
        const ioc = new IoC();
        const config = parseConfig(userConfig);
        checkSingleton();
        const glue = yield PromiseWrap(() => coreFactoryFunction(config, { version: version$2 }), 30000, "Glue Web initialization timed out, because core didn't resolve");
        const logger = glue.logger.subLogger("web.main.controller");
        ioc.defineGlue(glue);
        yield ioc.preferredConnectionController.start(config);
        yield ioc.bridge.start(ioc.controllers);
        ioc.defineConfig(config);
        logger.trace("the bridge has been started, initializing all controllers");
        yield Promise.all(Object.values(ioc.controllers).map((controller) => controller.start(glue, ioc)));
        logger.trace("all controllers reported started, starting all additional libraries");
        yield Promise.all(config.libraries.map((lib) => lib(glue, config)));
        logger.trace("all libraries were started");
        ioc.eventsDispatcher.start(glue);
        logger.trace("start event dispatched, glue is ready, returning it");
        return glue;
    });
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var MetricTypes = {
    STRING: 1,
    NUMBER: 2,
    TIMESTAMP: 3,
    OBJECT: 4
};

function getMetricTypeByValue(metric) {
    if (metric.type === MetricTypes.TIMESTAMP) {
        return "timestamp";
    }
    else if (metric.type === MetricTypes.NUMBER) {
        return "number";
    }
    else if (metric.type === MetricTypes.STRING) {
        return "string";
    }
    else if (metric.type === MetricTypes.OBJECT) {
        return "object";
    }
    return "unknown";
}
function getTypeByValue(value) {
    if (value.constructor === Date) {
        return "timestamp";
    }
    else if (typeof value === "number") {
        return "number";
    }
    else if (typeof value === "string") {
        return "string";
    }
    else if (typeof value === "object") {
        return "object";
    }
    else {
        return "string";
    }
}
function serializeMetric(metric) {
    var serializedMetrics = {};
    var type = getMetricTypeByValue(metric);
    if (type === "object") {
        var values = Object.keys(metric.value).reduce(function (memo, key) {
            var innerType = getTypeByValue(metric.value[key]);
            if (innerType === "object") {
                var composite = defineNestedComposite(metric.value[key]);
                memo[key] = {
                    type: "object",
                    description: "",
                    context: {},
                    composite: composite,
                };
            }
            else {
                memo[key] = {
                    type: innerType,
                    description: "",
                    context: {},
                };
            }
            return memo;
        }, {});
        serializedMetrics.composite = values;
    }
    serializedMetrics.name = normalizeMetricName(metric.path.join("/") + "/" + metric.name);
    serializedMetrics.type = type;
    serializedMetrics.description = metric.description;
    serializedMetrics.context = {};
    return serializedMetrics;
}
function defineNestedComposite(values) {
    return Object.keys(values).reduce(function (memo, key) {
        var type = getTypeByValue(values[key]);
        if (type === "object") {
            memo[key] = {
                type: "object",
                description: "",
                context: {},
                composite: defineNestedComposite(values[key]),
            };
        }
        else {
            memo[key] = {
                type: type,
                description: "",
                context: {},
            };
        }
        return memo;
    }, {});
}
function normalizeMetricName(name) {
    if (typeof name !== "undefined" && name.length > 0 && name[0] !== "/") {
        return "/" + name;
    }
    else {
        return name;
    }
}
function getMetricValueByType(metric) {
    var type = getMetricTypeByValue(metric);
    if (type === "timestamp") {
        return Date.now();
    }
    else {
        return publishNestedComposite(metric.value);
    }
}
function publishNestedComposite(values) {
    if (typeof values !== "object") {
        return values;
    }
    return Object.keys(values).reduce(function (memo, key) {
        var value = values[key];
        if (typeof value === "object" && value.constructor !== Date) {
            memo[key] = publishNestedComposite(value);
        }
        else if (value.constructor === Date) {
            memo[key] = new Date(value).getTime();
        }
        else if (value.constructor === Boolean) {
            memo[key] = value.toString();
        }
        else {
            memo[key] = value;
        }
        return memo;
    }, {});
}
function flatten(arr) {
    return arr.reduce(function (flat, toFlatten) {
        return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
    }, []);
}
function getHighestState(arr) {
    return arr.sort(function (a, b) {
        if (!a.state) {
            return 1;
        }
        if (!b.state) {
            return -1;
        }
        return b.state - a.state;
    })[0];
}
function aggregateDescription(arr) {
    var msg = "";
    arr.forEach(function (m, idx, a) {
        var path = m.path.join(".");
        if (idx === a.length - 1) {
            msg += path + "." + m.name + ": " + m.description;
        }
        else {
            msg += path + "." + m.name + ": " + m.description + ",";
        }
    });
    if (msg.length > 100) {
        return msg.slice(0, 100) + "...";
    }
    else {
        return msg;
    }
}
function composeMsgForRootStateMetric(system) {
    var aggregatedState = system.root.getAggregateState();
    var merged = flatten(aggregatedState);
    var highestState = getHighestState(merged);
    var aggregateDesc = aggregateDescription(merged);
    return {
        description: aggregateDesc,
        value: highestState.state,
    };
}

function gw3 (connection, config) {
    var _this = this;
    if (!connection || typeof connection !== "object") {
        throw new Error("Connection is required parameter");
    }
    var joinPromise;
    var session;
    var init = function (repo) {
        var resolveReadyPromise;
        joinPromise = new Promise(function (resolve) {
            resolveReadyPromise = resolve;
        });
        session = connection.domain("metrics");
        session.onJoined(function (reconnect) {
            if (!reconnect && resolveReadyPromise) {
                resolveReadyPromise();
                resolveReadyPromise = undefined;
            }
            var rootStateMetric = {
                name: "/State",
                type: "object",
                composite: {
                    Description: {
                        type: "string",
                        description: "",
                    },
                    Value: {
                        type: "number",
                        description: "",
                    },
                },
                description: "System state",
                context: {},
            };
            var defineRootMetricsMsg = {
                type: "define",
                metrics: [rootStateMetric],
            };
            session.send(defineRootMetricsMsg);
            if (reconnect) {
                replayRepo(repo);
            }
        });
        session.join({
            system: config.system,
            service: config.service,
            instance: config.instance
        });
    };
    var replayRepo = function (repo) {
        replaySystem(repo.root);
    };
    var replaySystem = function (system) {
        createSystem(system);
        system.metrics.forEach(function (m) {
            createMetric(m);
        });
        system.subSystems.forEach(function (ss) {
            replaySystem(ss);
        });
    };
    var createSystem = function (system) { return __awaiter(_this, void 0, void 0, function () {
        var metric, createMetricsMsg;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (system.parent === undefined) {
                        return [2];
                    }
                    return [4, joinPromise];
                case 1:
                    _a.sent();
                    metric = {
                        name: normalizeMetricName(system.path.join("/") + "/" + system.name + "/State"),
                        type: "object",
                        composite: {
                            Description: {
                                type: "string",
                                description: "",
                            },
                            Value: {
                                type: "number",
                                description: "",
                            },
                        },
                        description: "System state",
                        context: {},
                    };
                    createMetricsMsg = {
                        type: "define",
                        metrics: [metric],
                    };
                    session.send(createMetricsMsg);
                    return [2];
            }
        });
    }); };
    var updateSystem = function (system, state) { return __awaiter(_this, void 0, void 0, function () {
        var shadowedUpdateMetric, stateObj, rootMetric;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, joinPromise];
                case 1:
                    _a.sent();
                    shadowedUpdateMetric = {
                        type: "publish",
                        values: [{
                                name: normalizeMetricName(system.path.join("/") + "/" + system.name + "/State"),
                                value: {
                                    Description: state.description,
                                    Value: state.state,
                                },
                                timestamp: Date.now(),
                            }],
                    };
                    session.send(shadowedUpdateMetric);
                    stateObj = composeMsgForRootStateMetric(system);
                    rootMetric = {
                        type: "publish",
                        peer_id: connection.peerId,
                        values: [{
                                name: "/State",
                                value: {
                                    Description: stateObj.description,
                                    Value: stateObj.value,
                                },
                                timestamp: Date.now(),
                            }],
                    };
                    session.send(rootMetric);
                    return [2];
            }
        });
    }); };
    var createMetric = function (metric) { return __awaiter(_this, void 0, void 0, function () {
        var metricClone, m, createMetricsMsg;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    metricClone = cloneMetric(metric);
                    return [4, joinPromise];
                case 1:
                    _a.sent();
                    m = serializeMetric(metricClone);
                    createMetricsMsg = {
                        type: "define",
                        metrics: [m],
                    };
                    session.send(createMetricsMsg);
                    if (typeof metricClone.value !== "undefined") {
                        updateMetricCore(metricClone);
                    }
                    return [2];
            }
        });
    }); };
    var updateMetric = function (metric) { return __awaiter(_this, void 0, void 0, function () {
        var metricClone;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    metricClone = cloneMetric(metric);
                    return [4, joinPromise];
                case 1:
                    _a.sent();
                    updateMetricCore(metricClone);
                    return [2];
            }
        });
    }); };
    var updateMetricCore = function (metric) {
        if (canUpdate()) {
            var value = getMetricValueByType(metric);
            var publishMetricsMsg = {
                type: "publish",
                values: [{
                        name: normalizeMetricName(metric.path.join("/") + "/" + metric.name),
                        value: value,
                        timestamp: Date.now(),
                    }],
            };
            return session.sendFireAndForget(publishMetricsMsg);
        }
        return Promise.resolve();
    };
    var cloneMetric = function (metric) {
        var metricClone = __assign({}, metric);
        if (typeof metric.value === "object" && metric.value !== null) {
            metricClone.value = __assign({}, metric.value);
        }
        return metricClone;
    };
    var canUpdate = function () {
        var _a;
        try {
            var func = (_a = config.canUpdateMetric) !== null && _a !== void 0 ? _a : (function () { return true; });
            return func();
        }
        catch (_b) {
            return true;
        }
    };
    return {
        init: init,
        createSystem: createSystem,
        updateSystem: updateSystem,
        createMetric: createMetric,
        updateMetric: updateMetric,
    };
}

var Helpers = {
    validate: function (definition, parent, transport) {
        if (definition === null || typeof definition !== "object") {
            throw new Error("Missing definition");
        }
        if (parent === null || typeof parent !== "object") {
            throw new Error("Missing parent");
        }
        if (transport === null || typeof transport !== "object") {
            throw new Error("Missing transport");
        }
    },
};

var BaseMetric = (function () {
    function BaseMetric(definition, system, transport, value, type) {
        this.definition = definition;
        this.system = system;
        this.transport = transport;
        this.value = value;
        this.type = type;
        this.path = [];
        Helpers.validate(definition, system, transport);
        this.path = system.path.slice(0);
        this.path.push(system.name);
        this.name = definition.name;
        this.description = definition.description;
        transport.createMetric(this);
    }
    Object.defineProperty(BaseMetric.prototype, "repo", {
        get: function () {
            var _a;
            return (_a = this.system) === null || _a === void 0 ? void 0 : _a.repo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseMetric.prototype, "id", {
        get: function () { return "".concat(this.system.path, "/").concat(name); },
        enumerable: false,
        configurable: true
    });
    BaseMetric.prototype.update = function (newValue) {
        this.value = newValue;
        return this.transport.updateMetric(this);
    };
    return BaseMetric;
}());

var NumberMetric = (function (_super) {
    __extends(NumberMetric, _super);
    function NumberMetric(definition, system, transport, value) {
        return _super.call(this, definition, system, transport, value, MetricTypes.NUMBER) || this;
    }
    NumberMetric.prototype.incrementBy = function (num) {
        this.update(this.value + num);
    };
    NumberMetric.prototype.increment = function () {
        this.incrementBy(1);
    };
    NumberMetric.prototype.decrement = function () {
        this.incrementBy(-1);
    };
    NumberMetric.prototype.decrementBy = function (num) {
        this.incrementBy(num * -1);
    };
    return NumberMetric;
}(BaseMetric));

var ObjectMetric = (function (_super) {
    __extends(ObjectMetric, _super);
    function ObjectMetric(definition, system, transport, value) {
        return _super.call(this, definition, system, transport, value, MetricTypes.OBJECT) || this;
    }
    ObjectMetric.prototype.update = function (newValue) {
        this.mergeValues(newValue);
        return this.transport.updateMetric(this);
    };
    ObjectMetric.prototype.mergeValues = function (values) {
        var _this = this;
        return Object.keys(this.value).forEach(function (k) {
            if (typeof values[k] !== "undefined") {
                _this.value[k] = values[k];
            }
        });
    };
    return ObjectMetric;
}(BaseMetric));

var StringMetric = (function (_super) {
    __extends(StringMetric, _super);
    function StringMetric(definition, system, transport, value) {
        return _super.call(this, definition, system, transport, value, MetricTypes.STRING) || this;
    }
    return StringMetric;
}(BaseMetric));

var TimestampMetric = (function (_super) {
    __extends(TimestampMetric, _super);
    function TimestampMetric(definition, system, transport, value) {
        return _super.call(this, definition, system, transport, value, MetricTypes.TIMESTAMP) || this;
    }
    TimestampMetric.prototype.now = function () {
        this.update(new Date());
    };
    return TimestampMetric;
}(BaseMetric));

function system(name, repo, protocol, parent, description) {
    if (!repo) {
        throw new Error("Repository is required");
    }
    if (!protocol) {
        throw new Error("Transport is required");
    }
    var _transport = protocol;
    var _name = name;
    var _description = description || "";
    var _repo = repo;
    var _parent = parent;
    var _path = _buildPath(parent);
    var _state = {};
    var id = _arrayToString(_path, "/") + name;
    var root = repo.root;
    var _subSystems = [];
    var _metrics = [];
    function subSystem(nameSystem, descriptionSystem) {
        if (!nameSystem || nameSystem.length === 0) {
            throw new Error("name is required");
        }
        var match = _subSystems.filter(function (s) { return s.name === nameSystem; });
        if (match.length > 0) {
            return match[0];
        }
        var _system = system(nameSystem, _repo, _transport, me, descriptionSystem);
        _subSystems.push(_system);
        return _system;
    }
    function setState(state, stateDescription) {
        _state = { state: state, description: stateDescription };
        _transport.updateSystem(me, _state);
    }
    function stringMetric(definition, value) {
        return _getOrCreateMetric(definition, MetricTypes.STRING, value, function (metricDef) { return new StringMetric(metricDef, me, _transport, value); });
    }
    function numberMetric(definition, value) {
        return _getOrCreateMetric(definition, MetricTypes.NUMBER, value, function (metricDef) { return new NumberMetric(metricDef, me, _transport, value); });
    }
    function objectMetric(definition, value) {
        return _getOrCreateMetric(definition, MetricTypes.OBJECT, value, function (metricDef) { return new ObjectMetric(metricDef, me, _transport, value); });
    }
    function timestampMetric(definition, value) {
        return _getOrCreateMetric(definition, MetricTypes.TIMESTAMP, value, function (metricDef) { return new TimestampMetric(metricDef, me, _transport, value); });
    }
    function _getOrCreateMetric(metricObject, expectedType, value, createMetric) {
        var metricDef = { name: "" };
        if (typeof metricObject === "string") {
            metricDef = { name: metricObject };
        }
        else {
            metricDef = metricObject;
        }
        var matching = _metrics.filter(function (shadowedMetric) { return shadowedMetric.name === metricDef.name; });
        if (matching.length > 0) {
            var existing = matching[0];
            if (existing.type !== expectedType) {
                throw new Error("A metric named ".concat(metricDef.name, " is already defined with different type."));
            }
            if (typeof value !== "undefined") {
                existing
                    .update(value)
                    .catch(function () { });
            }
            return existing;
        }
        var metric = createMetric(metricDef);
        _metrics.push(metric);
        return metric;
    }
    function _buildPath(shadowedSystem) {
        if (!shadowedSystem || !shadowedSystem.parent) {
            return [];
        }
        var path = _buildPath(shadowedSystem.parent);
        path.push(shadowedSystem.name);
        return path;
    }
    function _arrayToString(path, separator) {
        return ((path && path.length > 0) ? path.join(separator) : "");
    }
    function getAggregateState() {
        var aggState = [];
        if (Object.keys(_state).length > 0) {
            aggState.push({
                name: _name,
                path: _path,
                state: _state.state,
                description: _state.description,
            });
        }
        _subSystems.forEach(function (shadowedSubSystem) {
            var result = shadowedSubSystem.getAggregateState();
            if (result.length > 0) {
                aggState.push.apply(aggState, result);
            }
        });
        return aggState;
    }
    var me = {
        get name() {
            return _name;
        },
        get description() {
            return _description;
        },
        get repo() {
            return _repo;
        },
        get parent() {
            return _parent;
        },
        path: _path,
        id: id,
        root: root,
        get subSystems() {
            return _subSystems;
        },
        get metrics() {
            return _metrics;
        },
        subSystem: subSystem,
        getState: function () {
            return _state;
        },
        setState: setState,
        stringMetric: stringMetric,
        timestampMetric: timestampMetric,
        objectMetric: objectMetric,
        numberMetric: numberMetric,
        getAggregateState: getAggregateState,
    };
    _transport.createSystem(me);
    return me;
}

var Repository = (function () {
    function Repository(options, protocol) {
        protocol.init(this);
        this.root = system("", this, protocol);
        this.addSystemMetrics(this.root, options.clickStream || options.clickStream === undefined);
    }
    Repository.prototype.addSystemMetrics = function (rootSystem, useClickStream) {
        if (typeof navigator !== "undefined") {
            rootSystem.stringMetric("UserAgent", navigator.userAgent);
        }
        if (useClickStream && typeof document !== "undefined") {
            var clickStream_1 = rootSystem.subSystem("ClickStream");
            var documentClickHandler = function (e) {
                var _a;
                if (!e.target) {
                    return;
                }
                var target = e.target;
                var className = target ? (_a = target.getAttribute("class")) !== null && _a !== void 0 ? _a : "" : "";
                clickStream_1.objectMetric("LastBrowserEvent", {
                    type: "click",
                    timestamp: new Date(),
                    target: {
                        className: className,
                        id: target.id,
                        type: "<" + target.tagName.toLowerCase() + ">",
                        href: target.href || "",
                    },
                });
            };
            clickStream_1.objectMetric("Page", {
                title: document.title,
                page: window.location.href,
            });
            if (document.addEventListener) {
                document.addEventListener("click", documentClickHandler);
            }
            else {
                document.attachEvent("onclick", documentClickHandler);
            }
        }
        rootSystem.stringMetric("StartTime", (new Date()).toString());
        var urlMetric = rootSystem.stringMetric("StartURL", "");
        var appNameMetric = rootSystem.stringMetric("AppName", "");
        if (typeof window !== "undefined") {
            if (typeof window.location !== "undefined") {
                var startUrl = window.location.href;
                urlMetric.update(startUrl);
            }
            if (typeof window.glue42gd !== "undefined") {
                appNameMetric.update(window.glue42gd.appName);
            }
        }
    };
    return Repository;
}());

var NullProtocol = (function () {
    function NullProtocol() {
    }
    NullProtocol.prototype.init = function (repo) {
    };
    NullProtocol.prototype.createSystem = function (system) {
        return Promise.resolve();
    };
    NullProtocol.prototype.updateSystem = function (metric, state) {
        return Promise.resolve();
    };
    NullProtocol.prototype.createMetric = function (metric) {
        return Promise.resolve();
    };
    NullProtocol.prototype.updateMetric = function (metric) {
        return Promise.resolve();
    };
    return NullProtocol;
}());

var PerfTracker = (function () {
    function PerfTracker(api, initialPublishTimeout, publishInterval) {
        this.api = api;
        this.lastCount = 0;
        this.initialPublishTimeout = 10 * 1000;
        this.publishInterval = 60 * 1000;
        this.initialPublishTimeout = initialPublishTimeout !== null && initialPublishTimeout !== void 0 ? initialPublishTimeout : this.initialPublishTimeout;
        this.publishInterval = publishInterval !== null && publishInterval !== void 0 ? publishInterval : this.publishInterval;
        this.scheduleCollection();
        this.system = this.api.subSystem("performance", "Performance data published by the web application");
    }
    PerfTracker.prototype.scheduleCollection = function () {
        var _this = this;
        setTimeout(function () {
            _this.collect();
            setInterval(function () {
                _this.collect();
            }, _this.publishInterval);
        }, this.initialPublishTimeout);
    };
    PerfTracker.prototype.collect = function () {
        try {
            this.collectMemory();
            this.collectEntries();
        }
        catch (_a) {
        }
    };
    PerfTracker.prototype.collectMemory = function () {
        var memory = window.performance.memory;
        this.system.stringMetric("memory", JSON.stringify({
            totalJSHeapSize: memory.totalJSHeapSize,
            usedJSHeapSize: memory.usedJSHeapSize
        }));
    };
    PerfTracker.prototype.collectEntries = function () {
        var allEntries = window.performance.getEntries();
        if (allEntries.length <= this.lastCount) {
            return;
        }
        this.lastCount = allEntries.length;
        var jsonfiedEntries = allEntries.map(function (i) { return i.toJSON(); });
        this.system.stringMetric("entries", JSON.stringify(jsonfiedEntries));
    };
    return PerfTracker;
}());

var metrics = (function (options) {
    var protocol;
    if (!options.connection || typeof options.connection !== "object") {
        protocol = new NullProtocol();
    }
    else {
        protocol = gw3(options.connection, options);
    }
    var repo = new Repository(options, protocol);
    var rootSystem = repo.root;
    if (!options.disableAutoAppSystem) {
        rootSystem = rootSystem.subSystem("App");
    }
    var api = addFAVSupport(rootSystem);
    initPerf(api, options.pagePerformanceMetrics);
    return api;
});
function initPerf(api, config) {
    var _a, _b;
    if (typeof window === "undefined") {
        return;
    }
    var perfConfig = (_b = (_a = window === null || window === void 0 ? void 0 : window.glue42gd) === null || _a === void 0 ? void 0 : _a.metrics) === null || _b === void 0 ? void 0 : _b.pagePerformanceMetrics;
    if (perfConfig) {
        config = perfConfig;
    }
    if (config === null || config === void 0 ? void 0 : config.enabled) {
        new PerfTracker(api, config.initialPublishTimeout, config.publishInterval);
    }
}
function addFAVSupport(system) {
    var reportingSystem = system.subSystem("reporting");
    var def = {
        name: "features"
    };
    var featureMetric;
    var featureMetricFunc = function (name, action, payload) {
        if (typeof name === "undefined" || name === "") {
            throw new Error("name is mandatory");
        }
        else if (typeof action === "undefined" || action === "") {
            throw new Error("action is mandatory");
        }
        else if (typeof payload === "undefined" || payload === "") {
            throw new Error("payload is mandatory");
        }
        if (!featureMetric) {
            featureMetric = reportingSystem.objectMetric(def, { name: name, action: action, payload: payload });
        }
        else {
            featureMetric.update({
                name: name,
                action: action,
                payload: payload
            });
        }
    };
    system.featureMetric = featureMetricFunc;
    return system;
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createRegistry(options) {
    if (options && options.errorHandling
        && typeof options.errorHandling !== "function"
        && options.errorHandling !== "log"
        && options.errorHandling !== "silent"
        && options.errorHandling !== "throw") {
        throw new Error("Invalid options passed to createRegistry. Prop errorHandling should be [\"log\" | \"silent\" | \"throw\" | (err) => void], but " + typeof options.errorHandling + " was passed");
    }
    var _userErrorHandler = options && typeof options.errorHandling === "function" && options.errorHandling;
    var callbacks = {};
    function add(key, callback, replayArgumentsArr) {
        var callbacksForKey = callbacks[key];
        if (!callbacksForKey) {
            callbacksForKey = [];
            callbacks[key] = callbacksForKey;
        }
        callbacksForKey.push(callback);
        if (replayArgumentsArr) {
            setTimeout(function () {
                replayArgumentsArr.forEach(function (replayArgument) {
                    var _a;
                    if ((_a = callbacks[key]) === null || _a === void 0 ? void 0 : _a.includes(callback)) {
                        try {
                            if (Array.isArray(replayArgument)) {
                                callback.apply(undefined, replayArgument);
                            }
                            else {
                                callback.apply(undefined, [replayArgument]);
                            }
                        }
                        catch (err) {
                            _handleError(err, key);
                        }
                    }
                });
            }, 0);
        }
        return function () {
            var allForKey = callbacks[key];
            if (!allForKey) {
                return;
            }
            allForKey = allForKey.reduce(function (acc, element, index) {
                if (!(element === callback && acc.length === index)) {
                    acc.push(element);
                }
                return acc;
            }, []);
            if (allForKey.length === 0) {
                delete callbacks[key];
            }
            else {
                callbacks[key] = allForKey;
            }
        };
    }
    function execute(key) {
        var argumentsArr = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            argumentsArr[_i - 1] = arguments[_i];
        }
        var callbacksForKey = callbacks[key];
        if (!callbacksForKey || callbacksForKey.length === 0) {
            return [];
        }
        var results = [];
        callbacksForKey.forEach(function (callback) {
            try {
                var result = callback.apply(undefined, argumentsArr);
                results.push(result);
            }
            catch (err) {
                results.push(undefined);
                _handleError(err, key);
            }
        });
        return results;
    }
    function _handleError(exceptionArtifact, key) {
        var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);
        if (_userErrorHandler) {
            _userErrorHandler(errParam);
            return;
        }
        var msg = "[ERROR] callback-registry: User callback for key \"" + key + "\" failed: " + errParam.stack;
        if (options) {
            switch (options.errorHandling) {
                case "log":
                    return console.error(msg);
                case "silent":
                    return;
                case "throw":
                    throw new Error(msg);
            }
        }
        console.error(msg);
    }
    function clear() {
        callbacks = {};
    }
    function clearKey(key) {
        var callbacksForKey = callbacks[key];
        if (!callbacksForKey) {
            return;
        }
        delete callbacks[key];
    }
    return {
        add: add,
        execute: execute,
        clear: clear,
        clearKey: clearKey
    };
}
createRegistry.default = createRegistry;
var lib$1 = createRegistry;

var InProcTransport = (function () {
    function InProcTransport(settings, logger) {
        var _this = this;
        this.registry = lib$1();
        this.gw = settings.facade;
        this.gw.connect(function (_client, message) {
            _this.messageHandler(message);
        }).then(function (client) {
            _this.client = client;
        });
    }
    Object.defineProperty(InProcTransport.prototype, "isObjectBasedTransport", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    InProcTransport.prototype.sendObject = function (msg) {
        if (this.client) {
            this.client.send(msg);
            return Promise.resolve(undefined);
        }
        else {
            return Promise.reject("not connected");
        }
    };
    InProcTransport.prototype.send = function (_msg) {
        return Promise.reject("not supported");
    };
    InProcTransport.prototype.onMessage = function (callback) {
        return this.registry.add("onMessage", callback);
    };
    InProcTransport.prototype.onConnectedChanged = function (callback) {
        callback(true);
        return function () { };
    };
    InProcTransport.prototype.close = function () {
        return Promise.resolve();
    };
    InProcTransport.prototype.open = function () {
        return Promise.resolve();
    };
    InProcTransport.prototype.name = function () {
        return "in-memory";
    };
    InProcTransport.prototype.reconnect = function () {
        return Promise.resolve();
    };
    InProcTransport.prototype.messageHandler = function (msg) {
        this.registry.execute("onMessage", msg);
    };
    return InProcTransport;
}());

var SharedWorkerTransport = (function () {
    function SharedWorkerTransport(workerFile, logger) {
        var _this = this;
        this.logger = logger;
        this.registry = lib$1();
        this.worker = new SharedWorker(workerFile);
        this.worker.port.onmessage = function (e) {
            _this.messageHandler(e.data);
        };
    }
    Object.defineProperty(SharedWorkerTransport.prototype, "isObjectBasedTransport", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    SharedWorkerTransport.prototype.sendObject = function (msg) {
        this.worker.port.postMessage(msg);
        return Promise.resolve();
    };
    SharedWorkerTransport.prototype.send = function (_msg) {
        return Promise.reject("not supported");
    };
    SharedWorkerTransport.prototype.onMessage = function (callback) {
        return this.registry.add("onMessage", callback);
    };
    SharedWorkerTransport.prototype.onConnectedChanged = function (callback) {
        callback(true);
        return function () { };
    };
    SharedWorkerTransport.prototype.close = function () {
        return Promise.resolve();
    };
    SharedWorkerTransport.prototype.open = function () {
        return Promise.resolve();
    };
    SharedWorkerTransport.prototype.name = function () {
        return "shared-worker";
    };
    SharedWorkerTransport.prototype.reconnect = function () {
        return Promise.resolve();
    };
    SharedWorkerTransport.prototype.messageHandler = function (msg) {
        this.registry.execute("onMessage", msg);
    };
    return SharedWorkerTransport;
}());

var Utils = (function () {
    function Utils() {
    }
    Utils.getGDMajorVersion = function () {
        if (typeof window === "undefined") {
            return undefined;
        }
        if (!window.glueDesktop) {
            return undefined;
        }
        if (!window.glueDesktop.version) {
            return undefined;
        }
        var ver = Number(window.glueDesktop.version.substr(0, 1));
        return isNaN(ver) ? undefined : ver;
    };
    Utils.isNode = function () {
        if (typeof Utils._isNode !== "undefined") {
            return Utils._isNode;
        }
        if (typeof window !== "undefined") {
            Utils._isNode = false;
            return false;
        }
        try {
            Utils._isNode = Object.prototype.toString.call(global.process) === "[object process]";
        }
        catch (e) {
            Utils._isNode = false;
        }
        return Utils._isNode;
    };
    return Utils;
}());

var PromiseWrapper = (function () {
    function PromiseWrapper() {
        var _this = this;
        this.rejected = false;
        this.resolved = false;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = function (t) {
                _this.resolved = true;
                resolve(t);
            };
            _this.reject = function (err) {
                _this.rejected = true;
                reject(err);
            };
        });
    }
    PromiseWrapper.delay = function (time) {
        return new Promise(function (resolve) { return setTimeout(resolve, time); });
    };
    Object.defineProperty(PromiseWrapper.prototype, "ended", {
        get: function () {
            return this.rejected || this.resolved;
        },
        enumerable: false,
        configurable: true
    });
    return PromiseWrapper;
}());

var timers = {};
function getAllTimers() {
    return timers;
}
function timer (timerName) {
    var existing = timers[timerName];
    if (existing) {
        return existing;
    }
    var marks = [];
    function now() {
        return new Date().getTime();
    }
    var startTime = now();
    mark("start", startTime);
    var endTime;
    var period;
    function stop() {
        endTime = now();
        mark("end", endTime);
        period = endTime - startTime;
        return period;
    }
    function mark(name, time) {
        var currentTime = time !== null && time !== void 0 ? time : now();
        var diff = 0;
        if (marks.length > 0) {
            diff = currentTime - marks[marks.length - 1].time;
        }
        marks.push({ name: name, time: currentTime, diff: diff });
    }
    var timerObj = {
        get startTime() {
            return startTime;
        },
        get endTime() {
            return endTime;
        },
        get period() {
            return period;
        },
        stop: stop,
        mark: mark,
        marks: marks
    };
    timers[timerName] = timerObj;
    return timerObj;
}

var WebSocketConstructor = Utils.isNode() ? __webpack_require__(/*! ws */ "./node_modules/@glue42/web/node_modules/ws/browser.js") : window.WebSocket;
var WS = (function () {
    function WS(settings, logger) {
        this.startupTimer = timer("connection");
        this._running = true;
        this._registry = lib$1();
        this.wsRequests = [];
        this.settings = settings;
        this.logger = logger;
        if (!this.settings.ws) {
            throw new Error("ws is missing");
        }
    }
    WS.prototype.onMessage = function (callback) {
        return this._registry.add("onMessage", callback);
    };
    WS.prototype.send = function (msg, options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.waitForSocketConnection(function () {
                var _a;
                try {
                    (_a = _this.ws) === null || _a === void 0 ? void 0 : _a.send(msg);
                    resolve();
                }
                catch (e) {
                    reject(e);
                }
            }, reject);
        });
    };
    WS.prototype.open = function () {
        var _this = this;
        this.logger.info("opening ws...");
        this._running = true;
        return new Promise(function (resolve, reject) {
            _this.waitForSocketConnection(resolve, reject);
        });
    };
    WS.prototype.close = function () {
        this._running = false;
        if (this.ws) {
            this.ws.close();
        }
        return Promise.resolve();
    };
    WS.prototype.onConnectedChanged = function (callback) {
        return this._registry.add("onConnectedChanged", callback);
    };
    WS.prototype.name = function () {
        return this.settings.ws;
    };
    WS.prototype.reconnect = function () {
        var _a;
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();
        var pw = new PromiseWrapper();
        this.waitForSocketConnection(function () {
            pw.resolve();
        });
        return pw.promise;
    };
    WS.prototype.waitForSocketConnection = function (callback, failed) {
        var _a;
        failed = failed !== null && failed !== void 0 ? failed : (function () { });
        if (!this._running) {
            failed("wait for socket on ".concat(this.settings.ws, " failed - socket closed by user"));
            return;
        }
        if (((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) === 1) {
            callback();
            return;
        }
        this.wsRequests.push({ callback: callback, failed: failed });
        if (this.wsRequests.length > 1) {
            return;
        }
        this.openSocket();
    };
    WS.prototype.openSocket = function (retryInterval, retriesLeft) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.startupTimer.mark("opening-socket");
                        if (retryInterval === undefined) {
                            retryInterval = this.settings.reconnectInterval;
                        }
                        if (typeof retriesLeft === "undefined") {
                            retriesLeft = this.settings.reconnectAttempts;
                        }
                        if (retriesLeft !== undefined) {
                            if (retriesLeft === 0) {
                                this.notifyForSocketState("wait for socket on ".concat(this.settings.ws, " failed - no more retries left"));
                                return [2];
                            }
                            this.logger.debug("will retry ".concat(retriesLeft, " more times (every ").concat(retryInterval, " ms)"));
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4, this.initiateSocket()];
                    case 2:
                        _b.sent();
                        this.startupTimer.mark("socket-initiated");
                        this.notifyForSocketState();
                        return [3, 4];
                    case 3:
                        _b.sent();
                        setTimeout(function () {
                            var retries = retriesLeft === undefined ? undefined : retriesLeft - 1;
                            _this.openSocket(retryInterval, retries);
                        }, retryInterval);
                        return [3, 4];
                    case 4: return [2];
                }
            });
        });
    };
    WS.prototype.initiateSocket = function () {
        var _this = this;
        var pw = new PromiseWrapper();
        this.logger.debug("initiating ws to ".concat(this.settings.ws, "..."));
        this.ws = new WebSocketConstructor(this.settings.ws || "");
        this.ws.onerror = function (err) {
            var reason = "";
            try {
                reason = JSON.stringify(err);
            }
            catch (error) {
                var seen_1 = new WeakSet();
                var replacer = function (key, value) {
                    if (typeof value === "object" && value !== null) {
                        if (seen_1.has(value)) {
                            return;
                        }
                        seen_1.add(value);
                    }
                    return value;
                };
                reason = JSON.stringify(err, replacer);
            }
            pw.reject("error");
            _this.notifyStatusChanged(false, reason);
        };
        this.ws.onclose = function (err) {
            _this.logger.info("ws closed ".concat(err));
            pw.reject("closed");
            _this.notifyStatusChanged(false);
        };
        this.ws.onopen = function () {
            var _a;
            _this.startupTimer.mark("ws-opened");
            _this.logger.info("ws opened ".concat((_a = _this.settings.identity) === null || _a === void 0 ? void 0 : _a.application));
            pw.resolve();
            _this.notifyStatusChanged(true);
        };
        this.ws.onmessage = function (message) {
            _this._registry.execute("onMessage", message.data);
        };
        return pw.promise;
    };
    WS.prototype.notifyForSocketState = function (error) {
        this.wsRequests.forEach(function (wsRequest) {
            if (error) {
                if (wsRequest.failed) {
                    wsRequest.failed(error);
                }
            }
            else {
                wsRequest.callback();
            }
        });
        this.wsRequests = [];
    };
    WS.prototype.notifyStatusChanged = function (status, reason) {
        this._registry.execute("onConnectedChanged", status, reason);
    };
    return WS;
}());

var shortidExports = {};
var shortid$1 = {
  get exports(){ return shortidExports; },
  set exports(v){ shortidExports = v; },
};

var libExports = {};
var lib = {
  get exports(){ return libExports; },
  set exports(v){ libExports = v; },
};

// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed$1(_seed_) {
    seed = _seed_;
}

var randomFromSeed$1 = {
    nextValue: getNextValue,
    seed: setSeed$1
};

var randomFromSeed = randomFromSeed$1;

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet$2;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet$2 !== ORIGINAL) {
            alphabet$2 = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet$2) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet$2 = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet$2;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet$2) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet$2.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

function get () {
  return alphabet$2 || ORIGINAL;
}

var alphabet_1 = {
    get: get,
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};

var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

var randomByte;

if (!crypto || !crypto.getRandomValues) {
    randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
    };
} else {
    randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
    };
}

var randomByteBrowser = randomByte;

// This file replaces `format.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

var format_browser = function (random, alphabet, size) {
  // We can’t use bytes bigger than the alphabet. To make bytes values closer
  // to the alphabet, we apply bitmask on them. We look for the closest
  // `2 ** x - 1` number, which will be bigger than alphabet size. If we have
  // 30 symbols in the alphabet, we will take 31 (00011111).
  // We do not use faster Math.clz32, because it is not available in browsers.
  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  // Bitmask is not a perfect solution (in our example it will pass 31 bytes,
  // which is bigger than the alphabet). As a result, we will need more bytes,
  // than ID size, because we will refuse bytes bigger than the alphabet.

  // Every hardware random generator call is costly,
  // because we need to wait for entropy collection. This is why often it will
  // be faster to ask for few extra bytes in advance, to avoid additional calls.

  // Here we calculate how many random bytes should we call in advance.
  // It depends on ID length, mask / alphabet size and magic number 1.6
  // (which was selected according benchmarks).

  // -~f => Math.ceil(f) if n is float number
  // -~i => i + 1 if n is integer number
  var step = -~(1.6 * mask * size / alphabet.length);
  var id = '';

  while (true) {
    var bytes = random(step);
    // Compact alternative for `for (var i = 0; i < step; i++)`
    var i = step;
    while (i--) {
      // If random byte is bigger than alphabet even after bitmask,
      // we refuse it by `|| ''`.
      id += alphabet[bytes[i] & mask] || '';
      // More compact than `id.length + 1 === size`
      if (id.length === +size) return id
    }
  }
};

var alphabet$1 = alphabet_1;
var random = randomByteBrowser;
var format = format_browser;

function generate$1(number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + format(random, alphabet$1.get(), 1);
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

var generate_1 = generate$1;

var generate = generate_1;

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1567752802062;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version$1 = 7;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function build(clusterWorkerId) {
    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + generate(version$1);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
        str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
}

var build_1 = build;

var alphabet = alphabet_1;

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var nonAlphabetic = new RegExp('[^' +
      alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
    return !nonAlphabetic.test(id);
}

var isValid = isShortId;

(function (module) {

	var alphabet = alphabet_1;
	var build = build_1;
	var isValid$1 = isValid;

	// if you are using cluster or multiple servers use this to make each instance
	// has a unique value for worker
	// Note: I don't know if this is automatically set when using third
	// party cluster solutions such as pm2.
	var clusterWorkerId = 0;

	/**
	 * Set the seed.
	 * Highly recommended if you don't want people to try to figure out your id schema.
	 * exposed as shortid.seed(int)
	 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
	 */
	function seed(seedValue) {
	    alphabet.seed(seedValue);
	    return module.exports;
	}

	/**
	 * Set the cluster worker or machine id
	 * exposed as shortid.worker(int)
	 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
	 * returns shortid module so it can be chained.
	 */
	function worker(workerId) {
	    clusterWorkerId = workerId;
	    return module.exports;
	}

	/**
	 *
	 * sets new characters to use in the alphabet
	 * returns the shuffled alphabet
	 */
	function characters(newCharacters) {
	    if (newCharacters !== undefined) {
	        alphabet.characters(newCharacters);
	    }

	    return alphabet.shuffled();
	}

	/**
	 * Generate unique id
	 * Returns string id
	 */
	function generate() {
	  return build(clusterWorkerId);
	}

	// Export all other functions as properties of the generate function
	module.exports = generate;
	module.exports.generate = generate;
	module.exports.seed = seed;
	module.exports.worker = worker;
	module.exports.characters = characters;
	module.exports.isValid = isValid$1;
} (lib));

(function (module) {
	module.exports = libExports;
} (shortid$1));

var shortid = /*@__PURE__*/getDefaultExportFromCjs(shortidExports);

function domainSession (domain, connection, logger, successMessages, errorMessages) {
    if (domain == null) {
        domain = "global";
    }
    successMessages = successMessages || ["success"];
    errorMessages = errorMessages || ["error"];
    var isJoined = false;
    var tryReconnecting = false;
    var _latestOptions;
    var _connectionOn = false;
    var callbacks = lib$1();
    connection.disconnected(handleConnectionDisconnected);
    connection.loggedIn(handleConnectionLoggedIn);
    connection.on("success", function (msg) { return handleSuccessMessage(msg); });
    connection.on("error", function (msg) { return handleErrorMessage(msg); });
    connection.on("result", function (msg) { return handleSuccessMessage(msg); });
    if (successMessages) {
        successMessages.forEach(function (sm) {
            connection.on(sm, function (msg) { return handleSuccessMessage(msg); });
        });
    }
    if (errorMessages) {
        errorMessages.forEach(function (sm) {
            connection.on(sm, function (msg) { return handleErrorMessage(msg); });
        });
    }
    var requestsMap = {};
    function join(options) {
        _latestOptions = options;
        return new Promise(function (resolve, reject) {
            if (isJoined) {
                resolve({});
                return;
            }
            var joinPromise;
            if (domain === "global") {
                joinPromise = _connectionOn ? Promise.resolve({}) : Promise.reject("not connected to gateway");
            }
            else {
                logger.debug("joining domain ".concat(domain));
                var joinMsg = {
                    type: "join",
                    destination: domain,
                    domain: "global",
                    options: options,
                };
                joinPromise = send(joinMsg);
            }
            joinPromise
                .then(function () {
                handleJoined();
                resolve({});
            })
                .catch(function (err) {
                logger.debug("error joining " + domain + " domain: " + JSON.stringify(err));
                reject(err);
            });
        });
    }
    function leave() {
        if (domain === "global") {
            return Promise.resolve();
        }
        logger.debug("stopping session " + domain + "...");
        var leaveMsg = {
            type: "leave",
            destination: domain,
            domain: "global",
        };
        tryReconnecting = false;
        return send(leaveMsg)
            .then(function () {
            isJoined = false;
            callbacks.execute("onLeft");
        })
            .catch(function () {
            isJoined = false;
            callbacks.execute("onLeft");
        });
    }
    function handleJoined() {
        logger.debug("did join " + domain);
        isJoined = true;
        var wasReconnect = tryReconnecting;
        tryReconnecting = false;
        callbacks.execute("onJoined", wasReconnect);
    }
    function handleConnectionDisconnected() {
        _connectionOn = false;
        logger.debug("connection is down");
        isJoined = false;
        tryReconnecting = true;
        callbacks.execute("onLeft", { disconnected: true });
    }
    function handleConnectionLoggedIn() {
        _connectionOn = true;
        if (tryReconnecting) {
            logger.debug("connection is now up - trying to reconnect...");
            join(_latestOptions);
        }
    }
    function onJoined(callback) {
        if (isJoined) {
            callback(false);
        }
        return callbacks.add("onJoined", callback);
    }
    function onLeft(callback) {
        if (!isJoined) {
            callback();
        }
        return callbacks.add("onLeft", callback);
    }
    function handleErrorMessage(msg) {
        if (domain !== msg.domain) {
            return;
        }
        var requestId = msg.request_id;
        if (!requestId) {
            return;
        }
        var entry = requestsMap[requestId];
        if (!entry) {
            return;
        }
        entry.error(msg);
    }
    function handleSuccessMessage(msg) {
        if (msg.domain !== domain) {
            return;
        }
        var requestId = msg.request_id;
        if (!requestId) {
            return;
        }
        var entry = requestsMap[requestId];
        if (!entry) {
            return;
        }
        entry.success(msg);
    }
    function getNextRequestId() {
        return shortid();
    }
    function send(msg, tag, options) {
        options = options || {};
        msg.request_id = msg.request_id || getNextRequestId();
        msg.domain = msg.domain || domain;
        if (!options.skipPeerId) {
            msg.peer_id = connection.peerId;
        }
        var requestId = msg.request_id;
        return new Promise(function (resolve, reject) {
            requestsMap[requestId] = {
                success: function (successMsg) {
                    delete requestsMap[requestId];
                    successMsg._tag = tag;
                    resolve(successMsg);
                },
                error: function (errorMsg) {
                    logger.warn("GW error - ".concat(JSON.stringify(errorMsg), " for request ").concat(JSON.stringify(msg)));
                    delete requestsMap[requestId];
                    errorMsg._tag = tag;
                    reject(errorMsg);
                },
            };
            connection
                .send(msg, options)
                .catch(function (err) {
                requestsMap[requestId].error({ err: err });
            });
        });
    }
    function sendFireAndForget(msg) {
        msg.request_id = msg.request_id ? msg.request_id : getNextRequestId();
        msg.domain = msg.domain || domain;
        msg.peer_id = connection.peerId;
        return connection.send(msg);
    }
    return {
        join: join,
        leave: leave,
        onJoined: onJoined,
        onLeft: onLeft,
        send: send,
        sendFireAndForget: sendFireAndForget,
        on: function (type, callback) {
            connection.on(type, function (msg) {
                if (msg.domain !== domain) {
                    return;
                }
                try {
                    callback(msg);
                }
                catch (e) {
                    logger.error("Callback  failed: ".concat(e, " \n ").concat(e.stack, " \n msg was: ").concat(JSON.stringify(msg)), e);
                }
            });
        },
        loggedIn: function (callback) { return connection.loggedIn(callback); },
        connected: function (callback) { return connection.connected(callback); },
        disconnected: function (callback) { return connection.disconnected(callback); },
        get peerId() {
            return connection.peerId;
        },
        get domain() {
            return domain;
        },
    };
}

var GW3ProtocolImpl = (function () {
    function GW3ProtocolImpl(connection, settings, logger) {
        var _this = this;
        this.connection = connection;
        this.settings = settings;
        this.logger = logger;
        this.protocolVersion = 3;
        this.datePrefix = "#T42_DATE#";
        this.datePrefixLen = this.datePrefix.length;
        this.dateMinLen = this.datePrefixLen + 1;
        this.datePrefixFirstChar = this.datePrefix[0];
        this.registry = lib$1();
        this._isLoggedIn = false;
        this.shouldTryLogin = true;
        this.initialLogin = true;
        this.initialLoginAttempts = 3;
        this.sessions = [];
        connection.disconnected(function () {
            _this.handleDisconnected();
        });
        this.ping();
    }
    Object.defineProperty(GW3ProtocolImpl.prototype, "isLoggedIn", {
        get: function () {
            return this._isLoggedIn;
        },
        enumerable: false,
        configurable: true
    });
    GW3ProtocolImpl.prototype.processStringMessage = function (message) {
        var _this = this;
        var msg = JSON.parse(message, function (key, value) {
            if (typeof value !== "string") {
                return value;
            }
            if (value.length < _this.dateMinLen) {
                return value;
            }
            if (value[0] !== _this.datePrefixFirstChar) {
                return value;
            }
            if (value.substring(0, _this.datePrefixLen) !== _this.datePrefix) {
                return value;
            }
            try {
                var milliseconds = parseInt(value.substring(_this.datePrefixLen, value.length), 10);
                if (isNaN(milliseconds)) {
                    return value;
                }
                return new Date(milliseconds);
            }
            catch (ex) {
                return value;
            }
        });
        return {
            msg: msg,
            msgType: msg.type,
        };
    };
    GW3ProtocolImpl.prototype.createStringMessage = function (message) {
        var oldToJson = Date.prototype.toJSON;
        try {
            var datePrefix_1 = this.datePrefix;
            Date.prototype.toJSON = function () {
                return datePrefix_1 + this.getTime();
            };
            var result = JSON.stringify(message);
            return result;
        }
        finally {
            Date.prototype.toJSON = oldToJson;
        }
    };
    GW3ProtocolImpl.prototype.processObjectMessage = function (message) {
        if (!message.type) {
            throw new Error("Object should have type property");
        }
        return {
            msg: message,
            msgType: message.type,
        };
    };
    GW3ProtocolImpl.prototype.createObjectMessage = function (message) {
        return message;
    };
    GW3ProtocolImpl.prototype.login = function (config, reconnect) {
        return __awaiter(this, void 0, void 0, function () {
            var authentication, token, e_1, _a, helloMsg, sendOptions, welcomeMsg, msg, token, _b, err_1;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        this.logger.debug("logging in...");
                        this.loginConfig = config;
                        if (!this.loginConfig) {
                            this.loginConfig = { username: "", password: "" };
                        }
                        this.shouldTryLogin = true;
                        authentication = {};
                        this.connection.gatewayToken = config.gatewayToken;
                        if (!config.gatewayToken) return [3, 5];
                        if (!reconnect) return [3, 4];
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4, this.getNewGWToken()];
                    case 2:
                        token = _c.sent();
                        config.gatewayToken = token;
                        return [3, 4];
                    case 3:
                        e_1 = _c.sent();
                        this.logger.warn("failed to get GW token when reconnecting ".concat((e_1 === null || e_1 === void 0 ? void 0 : e_1.message) || e_1));
                        return [3, 4];
                    case 4:
                        authentication.method = "gateway-token";
                        authentication.token = config.gatewayToken;
                        this.connection.gatewayToken = config.gatewayToken;
                        return [3, 10];
                    case 5:
                        if (!(config.flowName === "sspi")) return [3, 9];
                        authentication.provider = "win";
                        authentication.method = "access-token";
                        if (!(config.flowCallback && config.sessionId)) return [3, 7];
                        _a = authentication;
                        return [4, config.flowCallback(config.sessionId, null)];
                    case 6:
                        _a.token =
                            (_c.sent())
                                .data
                                .toString("base64");
                        return [3, 8];
                    case 7: throw new Error("Invalid SSPI config");
                    case 8: return [3, 10];
                    case 9:
                        if (config.token) {
                            authentication.method = "access-token";
                            authentication.token = config.token;
                        }
                        else if (config.username) {
                            authentication.method = "secret";
                            authentication.login = config.username;
                            authentication.secret = config.password;
                        }
                        else if (config.provider) {
                            authentication.provider = config.provider;
                            authentication.providerContext = config.providerContext;
                        }
                        else {
                            throw new Error("invalid auth message" + JSON.stringify(config));
                        }
                        _c.label = 10;
                    case 10:
                        helloMsg = {
                            type: "hello",
                            identity: this.settings.identity,
                            authentication: authentication
                        };
                        if (config.sessionId) {
                            helloMsg.request_id = config.sessionId;
                        }
                        this.globalDomain = domainSession("global", this.connection, this.logger.subLogger("global-domain"), [
                            "welcome",
                            "token",
                            "authentication-request"
                        ]);
                        sendOptions = { skipPeerId: true };
                        if (this.initialLogin) {
                            sendOptions.retryInterval = this.settings.reconnectInterval;
                            sendOptions.maxRetries = this.settings.reconnectAttempts;
                        }
                        _c.label = 11;
                    case 11:
                        _c.trys.push([11, 19, 20, 21]);
                        welcomeMsg = void 0;
                        _c.label = 12;
                    case 12:
                        return [4, this.globalDomain.send(helloMsg, undefined, sendOptions)];
                    case 13:
                        msg = _c.sent();
                        if (!(msg.type === "authentication-request")) return [3, 16];
                        token = Buffer.from(msg.authentication.token, "base64");
                        if (!(config.flowCallback && config.sessionId)) return [3, 15];
                        _b = helloMsg.authentication;
                        return [4, config.flowCallback(config.sessionId, token)];
                    case 14:
                        _b.token =
                            (_c.sent())
                                .data
                                .toString("base64");
                        _c.label = 15;
                    case 15:
                        helloMsg.request_id = config.sessionId;
                        return [3, 12];
                    case 16:
                        if (msg.type === "welcome") {
                            welcomeMsg = msg;
                            return [3, 18];
                        }
                        else if (msg.type === "error") {
                            throw new Error("Authentication failed: " + msg.reason);
                        }
                        else {
                            throw new Error("Unexpected message type during authentication: " + msg.type);
                        }
                    case 17: return [3, 12];
                    case 18:
                        this.initialLogin = false;
                        this.logger.debug("login successful with peerId " + welcomeMsg.peer_id);
                        this.connection.peerId = welcomeMsg.peer_id;
                        this.connection.resolvedIdentity = welcomeMsg.resolved_identity;
                        this.connection.availableDomains = welcomeMsg.available_domains;
                        if (welcomeMsg.options) {
                            this.connection.token = welcomeMsg.options.access_token;
                            this.connection.info = welcomeMsg.options.info;
                        }
                        this.setLoggedIn(true);
                        return [2, welcomeMsg.resolved_identity];
                    case 19:
                        err_1 = _c.sent();
                        this.logger.error("error sending hello message - " + (err_1.message || err_1.msg || err_1.reason || err_1), err_1);
                        throw err_1;
                    case 20:
                        if (config && config.flowCallback && config.sessionId) {
                            config.flowCallback(config.sessionId, null);
                        }
                        return [7];
                    case 21: return [2];
                }
            });
        });
    };
    GW3ProtocolImpl.prototype.logout = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.debug("logging out...");
                        this.shouldTryLogin = false;
                        if (this.pingTimer) {
                            clearTimeout(this.pingTimer);
                        }
                        promises = this.sessions.map(function (session) {
                            session.leave();
                        });
                        return [4, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GW3ProtocolImpl.prototype.loggedIn = function (callback) {
        if (this._isLoggedIn) {
            callback();
        }
        return this.registry.add("onLoggedIn", callback);
    };
    GW3ProtocolImpl.prototype.domain = function (domainName, domainLogger, successMessages, errorMessages) {
        var session = this.sessions.filter(function (s) { return s.domain === domainName; })[0];
        if (!session) {
            session = domainSession(domainName, this.connection, domainLogger, successMessages, errorMessages);
            this.sessions.push(session);
        }
        return session;
    };
    GW3ProtocolImpl.prototype.handleDisconnected = function () {
        var _this = this;
        this.setLoggedIn(false);
        var tryToLogin = this.shouldTryLogin;
        if (tryToLogin && this.initialLogin) {
            if (this.initialLoginAttempts <= 0) {
                return;
            }
            this.initialLoginAttempts--;
        }
        this.logger.debug("disconnected - will try new login?" + this.shouldTryLogin);
        if (this.shouldTryLogin) {
            if (!this.loginConfig) {
                throw new Error("no login info");
            }
            this.connection.login(this.loginConfig, true)
                .catch(function () {
                setTimeout(_this.handleDisconnected.bind(_this), _this.settings.reconnectInterval || 1000);
            });
        }
    };
    GW3ProtocolImpl.prototype.setLoggedIn = function (value) {
        this._isLoggedIn = value;
        if (this._isLoggedIn) {
            this.registry.execute("onLoggedIn");
        }
    };
    GW3ProtocolImpl.prototype.ping = function () {
        var _this = this;
        if (!this.shouldTryLogin) {
            return;
        }
        if (this._isLoggedIn) {
            this.connection.send({ type: "ping" });
        }
        this.pingTimer = setTimeout(function () {
            _this.ping();
        }, 30 * 1000);
    };
    GW3ProtocolImpl.prototype.authToken = function () {
        var createTokenReq = {
            type: "create-token"
        };
        if (!this.globalDomain) {
            return Promise.reject(new Error("no global domain session"));
        }
        return this.globalDomain.send(createTokenReq)
            .then(function (res) {
            return res.token;
        });
    };
    GW3ProtocolImpl.prototype.getNewGWToken = function () {
        if (typeof window !== undefined) {
            var glue42gd = window.glue42gd;
            if (glue42gd) {
                return glue42gd.getGWToken();
            }
        }
        return Promise.reject(new Error("not running in GD"));
    };
    return GW3ProtocolImpl;
}());

var MessageReplayerImpl = (function () {
    function MessageReplayerImpl(specs) {
        this.specsNames = [];
        this.messages = {};
        this.subs = {};
        this.subsRefCount = {};
        this.specs = {};
        for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
            var spec = specs_1[_i];
            this.specs[spec.name] = spec;
            this.specsNames.push(spec.name);
        }
    }
    MessageReplayerImpl.prototype.init = function (connection) {
        var _this = this;
        this.connection = connection;
        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {
            var name_1 = _a[_i];
            var _loop_1 = function (type) {
                var refCount = this_1.subsRefCount[type];
                if (!refCount) {
                    refCount = 0;
                }
                refCount += 1;
                this_1.subsRefCount[type] = refCount;
                if (refCount > 1) {
                    return "continue";
                }
                var sub = connection.on(type, function (msg) { return _this.processMessage(type, msg); });
                this_1.subs[type] = sub;
            };
            var this_1 = this;
            for (var _b = 0, _c = this.specs[name_1].types; _b < _c.length; _b++) {
                var type = _c[_b];
                _loop_1(type);
            }
        }
    };
    MessageReplayerImpl.prototype.processMessage = function (type, msg) {
        if (this.isDone || !msg) {
            return;
        }
        for (var _i = 0, _a = this.specsNames; _i < _a.length; _i++) {
            var name_2 = _a[_i];
            if (this.specs[name_2].types.indexOf(type) !== -1) {
                var messages = this.messages[name_2] || [];
                this.messages[name_2] = messages;
                messages.push(msg);
            }
        }
    };
    MessageReplayerImpl.prototype.drain = function (name, callback) {
        var _a;
        if (callback) {
            (this.messages[name] || []).forEach(callback);
        }
        delete this.messages[name];
        for (var _i = 0, _b = this.specs[name].types; _i < _b.length; _i++) {
            var type = _b[_i];
            this.subsRefCount[type] -= 1;
            if (this.subsRefCount[type] <= 0) {
                (_a = this.connection) === null || _a === void 0 ? void 0 : _a.off(this.subs[type]);
                delete this.subs[type];
                delete this.subsRefCount[type];
            }
        }
        delete this.specs[name];
        if (!this.specs.length) {
            this.isDone = true;
        }
    };
    return MessageReplayerImpl;
}());

var PromisePlus = function (executor, timeoutMilliseconds, timeoutMessage) {
    return new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
            var message = timeoutMessage || "Promise timeout hit: ".concat(timeoutMilliseconds);
            reject(message);
        }, timeoutMilliseconds);
        var providedPromise = new Promise(executor);
        providedPromise
            .then(function (result) {
            clearTimeout(timeout);
            resolve(result);
        })
            .catch(function (error) {
            clearTimeout(timeout);
            reject(error);
        });
    });
};

var WebPlatformTransport = (function () {
    function WebPlatformTransport(settings, logger, identity) {
        this.settings = settings;
        this.logger = logger;
        this.identity = identity;
        this.iAmConnected = false;
        this.parentReady = false;
        this.rejected = false;
        this.children = [];
        this.extContentAvailable = false;
        this.extContentConnecting = false;
        this.extContentConnected = false;
        this.parentInExtMode = false;
        this.webNamespace = "g42_core_web";
        this.parentPingTimeout = 5000;
        this.connectionRequestTimeout = 7000;
        this.defaultTargetString = "*";
        this.registry = lib$1();
        this.messages = {
            connectionAccepted: { name: "connectionAccepted", handle: this.handleConnectionAccepted.bind(this) },
            connectionRejected: { name: "connectionRejected", handle: this.handleConnectionRejected.bind(this) },
            connectionRequest: { name: "connectionRequest", handle: this.handleConnectionRequest.bind(this) },
            parentReady: {
                name: "parentReady", handle: function () {
                }
            },
            parentPing: { name: "parentPing", handle: this.handleParentPing.bind(this) },
            platformPing: { name: "platformPing", handle: this.handlePlatformPing.bind(this) },
            platformReady: { name: "platformReady", handle: this.handlePlatformReady.bind(this) },
            clientUnload: { name: "clientUnload", handle: this.handleClientUnload.bind(this) },
            manualUnload: { name: "manualUnload", handle: this.handleManualUnload.bind(this) },
            extConnectionResponse: { name: "extConnectionResponse", handle: this.handleExtConnectionResponse.bind(this) },
            extSetupRequest: { name: "extSetupRequest", handle: this.handleExtSetupRequest.bind(this) },
            gatewayDisconnect: { name: "gatewayDisconnect", handle: this.handleGatewayDisconnect.bind(this) },
            gatewayInternalConnect: { name: "gatewayInternalConnect", handle: this.handleGatewayInternalConnect.bind(this) }
        };
        this.extContentAvailable = !!window.glue42ext;
        this.setUpMessageListener();
        this.setUpUnload();
        this.setupPlatformUnloadListener();
        this.parentType = window.name.includes("#wsp") ? "workspace" : undefined;
    }
    WebPlatformTransport.prototype.manualSetReadyState = function () {
        this.iAmConnected = true;
        this.parentReady = true;
    };
    Object.defineProperty(WebPlatformTransport.prototype, "transportWindowId", {
        get: function () {
            return this.publicWindowId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebPlatformTransport.prototype, "communicationId", {
        get: function () {
            return this._communicationId;
        },
        enumerable: false,
        configurable: true
    });
    WebPlatformTransport.prototype.sendObject = function (msg) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.extContentConnected) {
                    return [2, window.postMessage({ glue42ExtOut: msg }, this.defaultTargetString)];
                }
                if (!this.port) {
                    throw new Error("Cannot send message, because the port was not opened yet");
                }
                this.port.postMessage(msg);
                return [2];
            });
        });
    };
    Object.defineProperty(WebPlatformTransport.prototype, "isObjectBasedTransport", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    WebPlatformTransport.prototype.onMessage = function (callback) {
        return this.registry.add("onMessage", callback);
    };
    WebPlatformTransport.prototype.send = function () {
        return Promise.reject("not supported");
    };
    WebPlatformTransport.prototype.onConnectedChanged = function (callback) {
        return this.registry.add("onConnectedChanged", callback);
    };
    WebPlatformTransport.prototype.open = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.debug("opening a connection to the web platform gateway.");
                        return [4, this.connect()];
                    case 1:
                        _a.sent();
                        this.notifyStatusChanged(true);
                        return [2];
                }
            });
        });
    };
    WebPlatformTransport.prototype.close = function () {
        var _a, _b;
        var message = {
            glue42core: {
                type: this.messages.gatewayDisconnect.name,
                data: {
                    clientId: this.myClientId,
                    ownWindowId: (_a = this.identity) === null || _a === void 0 ? void 0 : _a.windowId
                }
            }
        };
        (_b = this.port) === null || _b === void 0 ? void 0 : _b.postMessage(message);
        this.parentReady = false;
        this.notifyStatusChanged(false, "manual reconnection");
        return Promise.resolve();
    };
    WebPlatformTransport.prototype.name = function () {
        return "web-platform";
    };
    WebPlatformTransport.prototype.reconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.close()];
                    case 1:
                        _a.sent();
                        return [2, Promise.resolve()];
                }
            });
        });
    };
    WebPlatformTransport.prototype.initiateInternalConnection = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.logger.debug("opening an internal web platform connection");
            _this.port = _this.settings.port;
            if (_this.iAmConnected) {
                _this.logger.warn("cannot open a new connection, because this client is currently connected");
                return;
            }
            _this.port.onmessage = function (event) {
                var _a, _b;
                if (_this.iAmConnected && !((_a = event.data) === null || _a === void 0 ? void 0 : _a.glue42core)) {
                    _this.registry.execute("onMessage", event.data);
                    return;
                }
                var data = (_b = event.data) === null || _b === void 0 ? void 0 : _b.glue42core;
                if (!data) {
                    return;
                }
                if (data.type === _this.messages.gatewayInternalConnect.name && data.success) {
                    _this.publicWindowId = _this.settings.windowId;
                    if (_this.identity && _this.publicWindowId) {
                        _this.identity.windowId = _this.publicWindowId;
                        _this.identity.instance = _this.publicWindowId;
                    }
                    resolve();
                }
                if (data.type === _this.messages.gatewayInternalConnect.name && data.error) {
                    reject(data.error);
                }
            };
            _this.port.postMessage({
                glue42core: {
                    type: _this.messages.gatewayInternalConnect.name
                }
            });
        });
    };
    WebPlatformTransport.prototype.initiateRemoteConnection = function (target) {
        var _this = this;
        return PromisePlus(function (resolve, reject) {
            var _a;
            _this.connectionResolve = resolve;
            _this.connectionReject = reject;
            _this.myClientId = (_a = _this.myClientId) !== null && _a !== void 0 ? _a : shortid();
            var bridgeInstanceId = _this.getMyWindowId() || shortid();
            var request = {
                glue42core: {
                    type: _this.messages.connectionRequest.name,
                    clientId: _this.myClientId,
                    clientType: "child",
                    bridgeInstanceId: bridgeInstanceId,
                    selfAssignedWindowId: _this.selfAssignedWindowId
                }
            };
            _this.logger.debug("sending connection request");
            if (_this.extContentConnecting) {
                request.glue42core.clientType = "child";
                request.glue42core.bridgeInstanceId = _this.myClientId;
                request.glue42core.parentWindowId = _this.parentWindowId;
                return window.postMessage(request, _this.defaultTargetString);
            }
            if (!target) {
                throw new Error("Cannot send a connection request, because no glue target was specified!");
            }
            target.postMessage(request, _this.defaultTargetString);
        }, this.connectionRequestTimeout, "The connection to the target glue window timed out");
    };
    WebPlatformTransport.prototype.isParentCheckSuccess = function (parentCheck) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4, parentCheck];
                    case 1:
                        _a.sent();
                        return [2, { success: true }];
                    case 2:
                        _a.sent();
                        return [2, { success: false }];
                    case 3: return [2];
                }
            });
        });
    };
    WebPlatformTransport.prototype.setUpMessageListener = function () {
        var _this = this;
        if (this.settings.port) {
            this.logger.debug("skipping generic message listener, because this is an internal client");
            return;
        }
        window.addEventListener("message", function (event) {
            var _a;
            var data = (_a = event.data) === null || _a === void 0 ? void 0 : _a.glue42core;
            if (!data || _this.rejected) {
                return;
            }
            if (!_this.checkMessageTypeValid(data.type)) {
                _this.logger.error("cannot handle the incoming glue42 core message, because the type is invalid: ".concat(data.type));
                return;
            }
            var messageType = data.type;
            _this.logger.debug("received valid glue42core message of type: ".concat(messageType));
            _this.messages[messageType].handle(event);
        });
    };
    WebPlatformTransport.prototype.setUpUnload = function () {
        var _this = this;
        if (this.settings.port) {
            this.logger.debug("skipping unload event listener, because this is an internal client");
            return;
        }
        window.addEventListener("beforeunload", function () {
            var _a, _b;
            if (_this.extContentConnected) {
                return;
            }
            var message = {
                glue42core: {
                    type: _this.messages.clientUnload.name,
                    data: {
                        clientId: _this.myClientId,
                        ownWindowId: (_a = _this.identity) === null || _a === void 0 ? void 0 : _a.windowId
                    }
                }
            };
            if (_this.parent) {
                _this.parent.postMessage(message, _this.defaultTargetString);
            }
            (_b = _this.port) === null || _b === void 0 ? void 0 : _b.postMessage(message);
        });
    };
    WebPlatformTransport.prototype.handlePlatformReady = function (event) {
        this.logger.debug("the web platform gave the ready signal");
        this.parentReady = true;
        if (this.parentPingResolve) {
            this.parentPingResolve();
            delete this.parentPingResolve;
        }
        if (this.parentPingInterval) {
            clearInterval(this.parentPingInterval);
            delete this.parentPingInterval;
        }
        this.parent = event.source;
        this.parentType = window.name.includes("#wsp") ? "workspace" : "window";
    };
    WebPlatformTransport.prototype.handleConnectionAccepted = function (event) {
        var _a;
        var data = (_a = event.data) === null || _a === void 0 ? void 0 : _a.glue42core;
        if (this.myClientId === data.clientId) {
            return this.handleAcceptanceOfMyRequest(data);
        }
        return this.handleAcceptanceOfGrandChildRequest(data, event);
    };
    WebPlatformTransport.prototype.handleAcceptanceOfMyRequest = function (data) {
        var _this = this;
        this.logger.debug("handling a connection accepted signal targeted at me.");
        this.isPreferredActivated = data.isPreferredActivated;
        if (this.extContentConnecting) {
            return this.processExtContentConnection(data);
        }
        if (!data.port) {
            this.logger.error("cannot set up my connection, because I was not provided with a port");
            return;
        }
        this.publicWindowId = this.getMyWindowId();
        if (this.identity) {
            this.identity.windowId = this.publicWindowId;
            this.identity.instance = this.identity.instance ? this.identity.instance : this.publicWindowId || shortid();
        }
        if (this.identity && data.appName) {
            this.identity.application = data.appName;
            this.identity.applicationName = data.appName;
        }
        this._communicationId = data.communicationId;
        this.port = data.port;
        this.port.onmessage = function (e) { return _this.registry.execute("onMessage", e.data); };
        if (this.connectionResolve) {
            this.logger.debug("my connection is set up, calling the connection resolve.");
            this.connectionResolve();
            delete this.connectionResolve;
            return;
        }
        this.logger.error("unable to call the connection resolve, because no connection promise was found");
    };
    WebPlatformTransport.prototype.processExtContentConnection = function (data) {
        var _this = this;
        this.logger.debug("handling a connection accepted signal targeted at me for extension content connection.");
        this.extContentConnecting = false;
        this.extContentConnected = true;
        this.publicWindowId = this.parentWindowId || this.myClientId;
        if (this.extContentConnecting && this.identity) {
            this.identity.windowId = this.publicWindowId;
        }
        if (this.identity && data.appName) {
            this.identity.application = data.appName;
            this.identity.applicationName = data.appName;
        }
        window.addEventListener("message", function (event) {
            var _a;
            var extData = (_a = event.data) === null || _a === void 0 ? void 0 : _a.glue42ExtInc;
            if (!extData) {
                return;
            }
            _this.registry.execute("onMessage", extData);
        });
        if (this.connectionResolve) {
            this.logger.debug("my connection is set up, calling the connection resolve.");
            this.connectionResolve();
            delete this.connectionResolve;
            return;
        }
    };
    WebPlatformTransport.prototype.handleAcceptanceOfGrandChildRequest = function (data, event) {
        if (this.extContentConnecting || this.extContentConnected) {
            this.logger.debug("cannot process acceptance of a grandchild, because I am connected to a content script");
            return;
        }
        this.logger.debug("handling a connection accepted signal targeted at a grandchild: ".concat(data.clientId));
        var child = this.children.find(function (c) { return c.grandChildId === data.clientId; });
        if (!child) {
            this.logger.error("cannot handle connection accepted for grandchild: ".concat(data.clientId, ", because there is no grandchild with this id"));
            return;
        }
        child.connected = true;
        this.logger.debug("the grandchild connection for ".concat(data.clientId, " is set up, forwarding the success message and the gateway port"));
        data.parentWindowId = this.publicWindowId;
        child.source.postMessage(event.data, child.origin, [data.port]);
        return;
    };
    WebPlatformTransport.prototype.handleConnectionRejected = function () {
        this.logger.debug("handling a connection rejection. Most likely the reason is that this window was not created by a glue API call");
        if (this.connectionReject) {
            this.connectionReject("The platform connection was rejected. Most likely because this window was not created by a glue API call");
            delete this.connectionReject;
        }
    };
    WebPlatformTransport.prototype.handleConnectionRequest = function (event) {
        if (this.extContentConnecting) {
            this.logger.debug("This connection request event is targeted at the extension content");
            return;
        }
        var source = event.source;
        var data = event.data.glue42core;
        if (!data.clientType || data.clientType !== "grandChild") {
            return this.rejectConnectionRequest(source, event.origin, "rejecting a connection request, because the source was not opened by a glue API call");
        }
        if (!data.clientId) {
            return this.rejectConnectionRequest(source, event.origin, "rejecting a connection request, because the source did not provide a valid id");
        }
        if (!this.parent) {
            return this.rejectConnectionRequest(source, event.origin, "Cannot forward the connection request, because no direct connection to the platform was found");
        }
        this.logger.debug("handling a connection request for a grandchild: ".concat(data.clientId));
        this.children.push({ grandChildId: data.clientId, source: source, connected: false, origin: event.origin });
        this.logger.debug("grandchild: ".concat(data.clientId, " is prepared, forwarding connection request to the platform"));
        this.parent.postMessage(event.data, this.defaultTargetString);
    };
    WebPlatformTransport.prototype.handleParentPing = function (event) {
        if (!this.parentReady) {
            this.logger.debug("my parent is not ready, I am ignoring the parent ping");
            return;
        }
        if (!this.iAmConnected) {
            this.logger.debug("i am not fully connected yet, I am ignoring the parent ping");
            return;
        }
        var message = {
            glue42core: {
                type: this.messages.parentReady.name
            }
        };
        if (this.extContentConnected) {
            message.glue42core.extMode = { windowId: this.myClientId };
        }
        var source = event.source;
        this.logger.debug("responding to a parent ping with a ready message");
        source.postMessage(message, event.origin);
    };
    WebPlatformTransport.prototype.setupPlatformUnloadListener = function () {
        var _this = this;
        this.onMessage(function (msg) {
            if (msg.type === "platformUnload") {
                _this.logger.debug("detected a web platform unload");
                _this.parentReady = false;
                _this.notifyStatusChanged(false, "Gateway unloaded");
            }
        });
    };
    WebPlatformTransport.prototype.handleManualUnload = function () {
        var _a, _b;
        var message = {
            glue42core: {
                type: this.messages.clientUnload.name,
                data: {
                    clientId: this.myClientId,
                    ownWindowId: (_a = this.identity) === null || _a === void 0 ? void 0 : _a.windowId
                }
            }
        };
        if (this.extContentConnected) {
            return window.postMessage({ glue42ExtOut: message }, this.defaultTargetString);
        }
        (_b = this.port) === null || _b === void 0 ? void 0 : _b.postMessage(message);
    };
    WebPlatformTransport.prototype.handleClientUnload = function (event) {
        var data = event.data.glue42core;
        var clientId = data === null || data === void 0 ? void 0 : data.data.clientId;
        if (!clientId) {
            this.logger.warn("cannot process grand child unload, because the provided id was not valid");
            return;
        }
        var foundChild = this.children.find(function (child) { return child.grandChildId === clientId; });
        if (!foundChild) {
            this.logger.warn("cannot process grand child unload, because this client is unaware of this grandchild");
            return;
        }
        this.logger.debug("handling grandchild unload for id: ".concat(clientId));
        this.children = this.children.filter(function (child) { return child.grandChildId !== clientId; });
    };
    WebPlatformTransport.prototype.handlePlatformPing = function () {
        return;
    };
    WebPlatformTransport.prototype.notifyStatusChanged = function (status, reason) {
        this.iAmConnected = status;
        this.registry.execute("onConnectedChanged", status, reason);
    };
    WebPlatformTransport.prototype.checkMessageTypeValid = function (typeToValidate) {
        return typeof typeToValidate === "string" && !!this.messages[typeToValidate];
    };
    WebPlatformTransport.prototype.rejectConnectionRequest = function (source, origin, reason) {
        this.rejected = true;
        this.logger.error(reason);
        var rejection = {
            glue42core: {
                type: this.messages.connectionRejected.name
            }
        };
        source.postMessage(rejection, origin);
    };
    WebPlatformTransport.prototype.requestConnectionPermissionFromExt = function () {
        var _this = this;
        return this.waitForContentScript()
            .then(function () { return PromisePlus(function (resolve, reject) {
            _this.extConnectionResolve = resolve;
            _this.extConnectionReject = reject;
            var message = {
                glue42core: {
                    type: "extSetupRequest"
                }
            };
            _this.logger.debug("permission request to the extension content script was sent");
            window.postMessage(message, _this.defaultTargetString);
        }, _this.parentPingTimeout, "Cannot initialize glue, because this app was not opened or created by a Glue Client and the request for extension connection timed out"); });
    };
    WebPlatformTransport.prototype.handleExtConnectionResponse = function (event) {
        var _a;
        var data = (_a = event.data) === null || _a === void 0 ? void 0 : _a.glue42core;
        if (!data.approved) {
            return this.extConnectionReject ? this.extConnectionReject("Cannot initialize glue, because this app was not opened or created by a Glue Client and the request for extension connection was rejected") : undefined;
        }
        if (this.extConnectionResolve) {
            this.extConnectionResolve();
            delete this.extConnectionResolve;
        }
        this.extContentConnecting = true;
        this.parentType = "extension";
        this.logger.debug("The extension connection was approved, proceeding.");
    };
    WebPlatformTransport.prototype.handleExtSetupRequest = function () {
        return;
    };
    WebPlatformTransport.prototype.handleGatewayDisconnect = function () {
        return;
    };
    WebPlatformTransport.prototype.handleGatewayInternalConnect = function () {
        return;
    };
    WebPlatformTransport.prototype.waitForContentScript = function () {
        var _a;
        var contentReady = !!((_a = window.glue42ext) === null || _a === void 0 ? void 0 : _a.content);
        if (contentReady) {
            return Promise.resolve();
        }
        return PromisePlus(function (resolve) {
            window.addEventListener("Glue42EXTReady", function () {
                resolve();
            });
        }, this.connectionRequestTimeout, "The content script was available, but was never heard to be ready");
    };
    WebPlatformTransport.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.settings.port) return [3, 2];
                        return [4, this.initiateInternalConnection()];
                    case 1:
                        _a.sent();
                        this.logger.debug("internal web platform connection completed");
                        return [2];
                    case 2:
                        this.logger.debug("opening a client web platform connection");
                        return [4, this.findParent()];
                    case 3:
                        _a.sent();
                        return [4, this.initiateRemoteConnection(this.parent)];
                    case 4:
                        _a.sent();
                        this.logger.debug("the client is connected");
                        return [2];
                }
            });
        });
    };
    WebPlatformTransport.prototype.findParent = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var connectionNotPossibleMsg, myInsideParents, myOutsideParents, uniqueParents, defaultParentCheck;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        connectionNotPossibleMsg = "Cannot initiate glue, because this window was not opened or created by a glue client";
                        myInsideParents = this.getPossibleParentsInWindow(window);
                        myOutsideParents = this.getPossibleParentsOutsideWindow((_a = window.top) === null || _a === void 0 ? void 0 : _a.opener, window.top);
                        uniqueParents = new Set(__spreadArray(__spreadArray([], myInsideParents, true), myOutsideParents, true));
                        if (!uniqueParents.size && !this.extContentAvailable) {
                            throw new Error(connectionNotPossibleMsg);
                        }
                        if (!(!uniqueParents.size && this.extContentAvailable)) return [3, 2];
                        return [4, this.requestConnectionPermissionFromExt()];
                    case 1:
                        _b.sent();
                        return [2];
                    case 2: return [4, this.isParentCheckSuccess(this.confirmParent(Array.from(uniqueParents)))];
                    case 3:
                        defaultParentCheck = _b.sent();
                        if (defaultParentCheck.success) {
                            this.logger.debug("The default parent was found!");
                            return [2];
                        }
                        if (!this.extContentAvailable) {
                            throw new Error(connectionNotPossibleMsg);
                        }
                        return [4, this.requestConnectionPermissionFromExt()];
                    case 4:
                        _b.sent();
                        return [2];
                }
            });
        });
    };
    WebPlatformTransport.prototype.getPossibleParentsInWindow = function (currentWindow) {
        return (!currentWindow || currentWindow === currentWindow.top) ? [] : __spreadArray([currentWindow.parent], this.getPossibleParentsInWindow(currentWindow.parent), true);
    };
    WebPlatformTransport.prototype.getPossibleParentsOutsideWindow = function (opener, current) {
        return (!opener || !current || opener === current) ? [] : __spreadArray(__spreadArray([opener], this.getPossibleParentsInWindow(opener), true), this.getPossibleParentsOutsideWindow(opener.opener, opener), true);
    };
    WebPlatformTransport.prototype.confirmParent = function (targets) {
        var _this = this;
        var connectionNotPossibleMsg = "Cannot initiate glue, because this window was not opened or created by a glue client";
        var parentCheck = PromisePlus(function (resolve) {
            _this.parentPingResolve = resolve;
            var message = {
                glue42core: {
                    type: _this.messages.platformPing.name
                }
            };
            _this.parentPingInterval = setInterval(function () {
                targets.forEach(function (target) {
                    target.postMessage(message, _this.defaultTargetString);
                });
            }, 1000);
        }, this.parentPingTimeout, connectionNotPossibleMsg);
        parentCheck.catch(function () {
            if (_this.parentPingInterval) {
                clearInterval(_this.parentPingInterval);
                delete _this.parentPingInterval;
            }
        });
        return parentCheck;
    };
    WebPlatformTransport.prototype.getMyWindowId = function () {
        var _a;
        if (this.parentType === "workspace") {
            return window.name.substring(0, window.name.indexOf("#wsp"));
        }
        if (window !== window.top) {
            return;
        }
        if ((_a = window.name) === null || _a === void 0 ? void 0 : _a.includes("g42")) {
            return window.name;
        }
        this.selfAssignedWindowId = this.selfAssignedWindowId || "g42-".concat(shortid());
        return this.selfAssignedWindowId;
    };
    return WebPlatformTransport;
}());

var waitForInvocations = function (invocations, callback) {
    var left = invocations;
    return function () {
        left--;
        if (left === 0) {
            callback();
        }
    };
};

var AsyncSequelizer = (function () {
    function AsyncSequelizer(minSequenceInterval) {
        if (minSequenceInterval === void 0) { minSequenceInterval = 0; }
        this.minSequenceInterval = minSequenceInterval;
        this.queue = [];
        this.isExecutingQueue = false;
    }
    AsyncSequelizer.prototype.enqueue = function (action) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.queue.push({ action: action, resolve: resolve, reject: reject });
            _this.executeQueue();
        });
    };
    AsyncSequelizer.prototype.executeQueue = function () {
        return __awaiter(this, void 0, void 0, function () {
            var operation, actionResult, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isExecutingQueue) {
                            return [2];
                        }
                        this.isExecutingQueue = true;
                        _a.label = 1;
                    case 1:
                        if (!this.queue.length) return [3, 7];
                        operation = this.queue.shift();
                        if (!operation) {
                            this.isExecutingQueue = false;
                            return [2];
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4, operation.action()];
                    case 3:
                        actionResult = _a.sent();
                        operation.resolve(actionResult);
                        return [3, 5];
                    case 4:
                        error_1 = _a.sent();
                        operation.reject(error_1);
                        return [3, 5];
                    case 5: return [4, this.intervalBreak()];
                    case 6:
                        _a.sent();
                        return [3, 1];
                    case 7:
                        this.isExecutingQueue = false;
                        return [2];
                }
            });
        });
    };
    AsyncSequelizer.prototype.intervalBreak = function () {
        var _this = this;
        return new Promise(function (res) { return setTimeout(res, _this.minSequenceInterval); });
    };
    return AsyncSequelizer;
}());

var Connection = (function () {
    function Connection(settings, logger) {
        this.settings = settings;
        this.logger = logger;
        this.messageHandlers = {};
        this.ids = 1;
        this.registry = lib$1();
        this._connected = false;
        this.isTrace = false;
        this._swapTransport = false;
        this._switchInProgress = false;
        this._transportSubscriptions = [];
        this._sequelizer = new AsyncSequelizer();
        settings = settings || {};
        settings.reconnectAttempts = settings.reconnectAttempts || 10;
        settings.reconnectInterval = settings.reconnectInterval || 1000;
        if (settings.inproc) {
            this.transport = new InProcTransport(settings.inproc, logger.subLogger("inMemory"));
        }
        else if (settings.sharedWorker) {
            this.transport = new SharedWorkerTransport(settings.sharedWorker, logger.subLogger("shared-worker"));
        }
        else if (settings.webPlatform) {
            this.transport = new WebPlatformTransport(settings.webPlatform, logger.subLogger("web-platform"), settings.identity);
        }
        else if (settings.ws !== undefined) {
            this.transport = new WS(settings, logger.subLogger("ws"));
        }
        else {
            throw new Error("No connection information specified");
        }
        this.isTrace = logger.canPublish("trace");
        logger.debug("starting with ".concat(this.transport.name(), " transport"));
        this.protocol = new GW3ProtocolImpl(this, settings, logger.subLogger("protocol"));
        var unsubConnectionChanged = this.transport.onConnectedChanged(this.handleConnectionChanged.bind(this));
        var unsubOnMessage = this.transport.onMessage(this.handleTransportMessage.bind(this));
        this._transportSubscriptions.push(unsubConnectionChanged);
        this._transportSubscriptions.push(unsubOnMessage);
        this._defaultTransport = this.transport;
    }
    Object.defineProperty(Connection.prototype, "protocolVersion", {
        get: function () {
            var _a;
            return (_a = this.protocol) === null || _a === void 0 ? void 0 : _a.protocolVersion;
        },
        enumerable: false,
        configurable: true
    });
    Connection.prototype.switchTransport = function (settings) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this._sequelizer.enqueue(function () { return __awaiter(_this, void 0, void 0, function () {
                        var switchTargetTransport, verifyPromise, isSwitchSuccess;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!settings || typeof settings !== "object") {
                                        throw new Error("Cannot switch transports, because the settings are missing or invalid.");
                                    }
                                    if (typeof settings.type === "undefined") {
                                        throw new Error("Cannot switch the transport, because the type is not defined");
                                    }
                                    this.logger.trace("Starting transport switch with settings: ".concat(JSON.stringify(settings)));
                                    switchTargetTransport = settings.type === "secondary" ? this.getNewSecondaryTransport(settings) : this._defaultTransport;
                                    this._targetTransport = switchTargetTransport;
                                    this._targetAuth = settings.type === "secondary" ? this.getNewSecondaryAuth(settings) : this._defaultAuth;
                                    verifyPromise = this.verifyConnection();
                                    this._swapTransport = true;
                                    this._switchInProgress = true;
                                    this.logger.trace("The new transport has been set, closing the current transport");
                                    return [4, this.transport.close()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 4, , 5]);
                                    return [4, verifyPromise];
                                case 3:
                                    _a.sent();
                                    isSwitchSuccess = this.transport === switchTargetTransport;
                                    this.logger.info("The reconnection after the switch was completed. Was the switch a success: ".concat(isSwitchSuccess));
                                    this._switchInProgress = false;
                                    return [2, { success: isSwitchSuccess }];
                                case 4:
                                    _a.sent();
                                    this.logger.info("The reconnection after the switch timed out, reverting back to the default transport.");
                                    this.switchTransport({ type: "default" });
                                    this._switchInProgress = false;
                                    return [2, { success: false }];
                                case 5: return [2];
                            }
                        });
                    }); })];
            });
        });
    };
    Connection.prototype.onLibReAnnounced = function (callback) {
        return this.registry.add("libReAnnounced", callback);
    };
    Connection.prototype.setLibReAnnounced = function (lib) {
        this.registry.execute("libReAnnounced", lib);
    };
    Connection.prototype.send = function (message, options) {
        if (this.transport.sendObject &&
            this.transport.isObjectBasedTransport) {
            var msg = this.protocol.createObjectMessage(message);
            if (this.isTrace) {
                this.logger.trace(">> ".concat(JSON.stringify(msg)));
            }
            return this.transport.sendObject(msg, options);
        }
        else {
            var strMessage = this.protocol.createStringMessage(message);
            if (this.isTrace) {
                this.logger.trace(">> ".concat(strMessage));
            }
            return this.transport.send(strMessage, options);
        }
    };
    Connection.prototype.on = function (type, messageHandler) {
        type = type.toLowerCase();
        if (this.messageHandlers[type] === undefined) {
            this.messageHandlers[type] = {};
        }
        var id = this.ids++;
        this.messageHandlers[type][id] = messageHandler;
        return {
            type: type,
            id: id,
        };
    };
    Connection.prototype.off = function (info) {
        delete this.messageHandlers[info.type.toLowerCase()][info.id];
    };
    Object.defineProperty(Connection.prototype, "isConnected", {
        get: function () {
            return this.protocol.isLoggedIn;
        },
        enumerable: false,
        configurable: true
    });
    Connection.prototype.connected = function (callback) {
        var _this = this;
        return this.protocol.loggedIn(function () {
            var currentServer = _this.transport.name();
            callback(currentServer);
        });
    };
    Connection.prototype.disconnected = function (callback) {
        return this.registry.add("disconnected", callback);
    };
    Connection.prototype.login = function (authRequest, reconnect) {
        return __awaiter(this, void 0, void 0, function () {
            var newAuth, identity, error_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._defaultAuth) {
                            this._defaultAuth = authRequest;
                        }
                        if (this._swapTransport) {
                            this.logger.trace("Detected a transport swap, swapping transports");
                            newAuth = this.transportSwap();
                            authRequest = newAuth !== null && newAuth !== void 0 ? newAuth : authRequest;
                        }
                        this.logger.trace("Starting login for transport: ".concat(this.transport.name(), " and auth ").concat(JSON.stringify(authRequest)));
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4, this.transport.open()];
                    case 2:
                        _a.sent();
                        this.logger.trace("Transport: ".concat(this.transport.name(), " opened, logging in"));
                        timer("connection").mark("transport-opened");
                        return [4, this.protocol.login(authRequest, reconnect)];
                    case 3:
                        identity = _a.sent();
                        this.logger.trace("Logged in with identity: ".concat(JSON.stringify(identity)));
                        timer("connection").mark("protocol-logged-in");
                        return [2, identity];
                    case 4:
                        error_2 = _a.sent();
                        if (this._switchInProgress) {
                            this.logger.trace("An error while logging in after a transport swap, preparing a default swap.");
                            this.prepareDefaultSwap();
                        }
                        throw new Error(error_2);
                    case 5: return [2];
                }
            });
        });
    };
    Connection.prototype.logout = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.protocol.logout()];
                    case 1:
                        _a.sent();
                        return [4, this.transport.close()];
                    case 2:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    Connection.prototype.loggedIn = function (callback) {
        return this.protocol.loggedIn(callback);
    };
    Connection.prototype.domain = function (domain, successMessages, errorMessages) {
        return this.protocol.domain(domain, this.logger.subLogger("domain=".concat(domain)), successMessages, errorMessages);
    };
    Connection.prototype.authToken = function () {
        return this.protocol.authToken();
    };
    Connection.prototype.reconnect = function () {
        return this.transport.reconnect();
    };
    Connection.prototype.distributeMessage = function (message, type) {
        var _this = this;
        var handlers = this.messageHandlers[type.toLowerCase()];
        if (handlers !== undefined) {
            Object.keys(handlers).forEach(function (handlerId) {
                var handler = handlers[handlerId];
                if (handler !== undefined) {
                    try {
                        handler(message);
                    }
                    catch (error) {
                        try {
                            _this.logger.error("Message handler failed with ".concat(error.stack), error);
                        }
                        catch (loggerError) {
                            console.log("Message handler failed", error);
                        }
                    }
                }
            });
        }
    };
    Connection.prototype.handleConnectionChanged = function (connected) {
        if (this._connected === connected) {
            return;
        }
        this._connected = connected;
        if (connected) {
            if (this.settings.replaySpecs && this.settings.replaySpecs.length) {
                this.replayer = new MessageReplayerImpl(this.settings.replaySpecs);
                this.replayer.init(this);
            }
            this.registry.execute("connected");
        }
        else {
            this.registry.execute("disconnected");
        }
    };
    Connection.prototype.handleTransportMessage = function (msg) {
        var msgObj;
        if (typeof msg === "string") {
            msgObj = this.protocol.processStringMessage(msg);
        }
        else {
            msgObj = this.protocol.processObjectMessage(msg);
        }
        if (this.isTrace) {
            this.logger.trace("<< ".concat(JSON.stringify(msgObj)));
        }
        this.distributeMessage(msgObj.msg, msgObj.msgType);
    };
    Connection.prototype.verifyConnection = function () {
        var _this = this;
        return PromisePlus(function (resolve) {
            var unsub;
            var ready = waitForInvocations(2, function () {
                if (unsub) {
                    unsub();
                }
                resolve();
            });
            unsub = _this.onLibReAnnounced(function (lib) {
                if (lib.name === "interop") {
                    return ready();
                }
                if (lib.name === "contexts") {
                    return ready();
                }
            });
        }, 10000, "Transport switch timed out waiting for all libraries to be re-announced");
    };
    Connection.prototype.getNewSecondaryTransport = function (settings) {
        var _a;
        if (!((_a = settings.transportConfig) === null || _a === void 0 ? void 0 : _a.url)) {
            throw new Error("Missing secondary transport URL.");
        }
        return new WS(Object.assign({}, this.settings, { ws: settings.transportConfig.url, reconnectAttempts: 1 }), this.logger.subLogger("ws-secondary"));
    };
    Connection.prototype.getNewSecondaryAuth = function (settings) {
        var _a;
        if (!((_a = settings.transportConfig) === null || _a === void 0 ? void 0 : _a.auth)) {
            throw new Error("Missing secondary transport auth information.");
        }
        return settings.transportConfig.auth;
    };
    Connection.prototype.transportSwap = function () {
        this._swapTransport = false;
        if (!this._targetTransport || !this._targetAuth) {
            this.logger.warn("Error while switching transports - either the target transport or auth is not defined: transport defined -> ".concat(!!this._defaultTransport, ", auth defined -> ").concat(!!this._targetAuth, ". Staying on the current one."));
            return;
        }
        this._transportSubscriptions.forEach(function (unsub) { return unsub(); });
        this._transportSubscriptions = [];
        this.transport = this._targetTransport;
        var unsubConnectionChanged = this.transport.onConnectedChanged(this.handleConnectionChanged.bind(this));
        var unsubOnMessage = this.transport.onMessage(this.handleTransportMessage.bind(this));
        this._transportSubscriptions.push(unsubConnectionChanged);
        this._transportSubscriptions.push(unsubOnMessage);
        return this._targetAuth;
    };
    Connection.prototype.prepareDefaultSwap = function () {
        var _this = this;
        this._transportSubscriptions.forEach(function (unsub) { return unsub(); });
        this._transportSubscriptions = [];
        this.transport.close().catch(function (error) { return _this.logger.warn("Error closing the ".concat(_this.transport.name(), " transport after a failed connection attempt: ").concat(JSON.stringify(error))); });
        this._targetTransport = this._defaultTransport;
        this._targetAuth = this._defaultAuth;
        this._swapTransport = true;
    };
    return Connection;
}());

var order = ["trace", "debug", "info", "warn", "error", "off"];
var Logger = (function () {
    function Logger(name, parent, logFn) {
        this.name = name;
        this.parent = parent;
        this.subLoggers = [];
        this.logFn = console;
        this.customLogFn = false;
        this.name = name;
        if (parent) {
            this.path = "".concat(parent.path, ".").concat(name);
        }
        else {
            this.path = name;
        }
        this.loggerFullName = "[".concat(this.path, "]");
        this.includeTimeAndLevel = !logFn;
        if (logFn) {
            this.logFn = logFn;
            this.customLogFn = true;
        }
    }
    Logger.prototype.subLogger = function (name) {
        var existingSub = this.subLoggers.filter(function (subLogger) {
            return subLogger.name === name;
        })[0];
        if (existingSub !== undefined) {
            return existingSub;
        }
        Object.keys(this).forEach(function (key) {
            if (key === name) {
                throw new Error("This sub logger name is not allowed.");
            }
        });
        var sub = new Logger(name, this, this.customLogFn ? this.logFn : undefined);
        this.subLoggers.push(sub);
        return sub;
    };
    Logger.prototype.publishLevel = function (level) {
        var _a;
        if (level) {
            this._publishLevel = level;
        }
        return this._publishLevel || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.publishLevel());
    };
    Logger.prototype.consoleLevel = function (level) {
        var _a;
        if (level) {
            this._consoleLevel = level;
        }
        return this._consoleLevel || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.consoleLevel());
    };
    Logger.prototype.log = function (message, level, error) {
        this.publishMessage(level || "info", message, error);
    };
    Logger.prototype.trace = function (message) {
        this.log(message, "trace");
    };
    Logger.prototype.debug = function (message) {
        this.log(message, "debug");
    };
    Logger.prototype.info = function (message) {
        this.log(message, "info");
    };
    Logger.prototype.warn = function (message) {
        this.log(message, "warn");
    };
    Logger.prototype.error = function (message, err) {
        this.log(message, "error");
    };
    Logger.prototype.canPublish = function (level, compareWith) {
        var levelIdx = order.indexOf(level);
        var restrictionIdx = order.indexOf(compareWith || this.consoleLevel() || "trace");
        return levelIdx >= restrictionIdx;
    };
    Logger.prototype.publishMessage = function (level, message, error) {
        var loggerName = this.loggerFullName;
        if (level === "error" && !error) {
            var e = new Error();
            if (e.stack) {
                message =
                    message +
                        "\n" +
                        e.stack
                            .split("\n")
                            .slice(3)
                            .join("\n");
            }
        }
        if (this.canPublish(level, this.publishLevel())) {
            var interop = Logger.Interop;
            if (interop) {
                try {
                    if (interop.methods({ name: Logger.InteropMethodName }).length > 0) {
                        interop.invoke(Logger.InteropMethodName, {
                            msg: "".concat(message),
                            logger: loggerName,
                            level: level
                        });
                    }
                }
                catch (_a) {
                }
            }
        }
        if (this.canPublish(level)) {
            var prefix = "";
            if (this.includeTimeAndLevel) {
                var date = new Date();
                var time = "".concat(date.getHours(), ":").concat(date.getMinutes(), ":").concat(date.getSeconds(), ":").concat(date.getMilliseconds());
                prefix = "[".concat(time, "] [").concat(level, "] ");
            }
            var toPrint = "".concat(prefix).concat(loggerName, ": ").concat(message);
            switch (level) {
                case "trace":
                    this.logFn.debug(toPrint);
                    break;
                case "debug":
                    if (this.logFn.debug) {
                        this.logFn.debug(toPrint);
                    }
                    else {
                        this.logFn.log(toPrint);
                    }
                    break;
                case "info":
                    this.logFn.info(toPrint);
                    break;
                case "warn":
                    this.logFn.warn(toPrint);
                    break;
                case "error":
                    this.logFn.error(toPrint, error);
                    break;
            }
        }
    };
    Logger.InteropMethodName = "T42.AppLogger.Log";
    return Logger;
}());

var GW_MESSAGE_CREATE_CONTEXT = "create-context";
var GW_MESSAGE_ACTIVITY_CREATED = "created";
var GW_MESSAGE_ACTIVITY_DESTROYED = "destroyed";
var GW_MESSAGE_CONTEXT_CREATED = "context-created";
var GW_MESSAGE_CONTEXT_ADDED = "context-added";
var GW_MESSAGE_SUBSCRIBE_CONTEXT = "subscribe-context";
var GW_MESSAGE_SUBSCRIBED_CONTEXT = "subscribed-context";
var GW_MESSAGE_UNSUBSCRIBE_CONTEXT = "unsubscribe-context";
var GW_MESSAGE_DESTROY_CONTEXT = "destroy-context";
var GW_MESSAGE_CONTEXT_DESTROYED = "context-destroyed";
var GW_MESSAGE_UPDATE_CONTEXT = "update-context";
var GW_MESSAGE_CONTEXT_UPDATED = "context-updated";
var GW_MESSAGE_JOINED_ACTIVITY = "joined";

var ContextMessageReplaySpec = {
    get name() {
        return "context";
    },
    get types() {
        return [
            GW_MESSAGE_CREATE_CONTEXT,
            GW_MESSAGE_ACTIVITY_CREATED,
            GW_MESSAGE_ACTIVITY_DESTROYED,
            GW_MESSAGE_CONTEXT_CREATED,
            GW_MESSAGE_CONTEXT_ADDED,
            GW_MESSAGE_SUBSCRIBE_CONTEXT,
            GW_MESSAGE_SUBSCRIBED_CONTEXT,
            GW_MESSAGE_UNSUBSCRIBE_CONTEXT,
            GW_MESSAGE_DESTROY_CONTEXT,
            GW_MESSAGE_CONTEXT_DESTROYED,
            GW_MESSAGE_UPDATE_CONTEXT,
            GW_MESSAGE_CONTEXT_UPDATED,
            GW_MESSAGE_JOINED_ACTIVITY
        ];
    }
};

var version = "5.10.1";

function prepareConfig (configuration, ext, glue42gd) {
    var _a, _b, _c, _d;
    var nodeStartingContext;
    if (Utils.isNode()) {
        var startingContextString = process.env._GD_STARTING_CONTEXT_;
        if (startingContextString) {
            try {
                nodeStartingContext = JSON.parse(startingContextString);
            }
            catch (_e) {
            }
        }
    }
    function getConnection() {
        var _a, _b, _c, _d, _e, _f;
        var gwConfig = configuration.gateway;
        var protocolVersion = (_a = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.protocolVersion) !== null && _a !== void 0 ? _a : 3;
        var reconnectInterval = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.reconnectInterval;
        var reconnectAttempts = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.reconnectAttempts;
        var defaultWs = "ws://localhost:8385";
        var ws = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.ws;
        var sharedWorker = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.sharedWorker;
        var inproc = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.inproc;
        var webPlatform = (_b = gwConfig === null || gwConfig === void 0 ? void 0 : gwConfig.webPlatform) !== null && _b !== void 0 ? _b : undefined;
        if (glue42gd) {
            ws = glue42gd.gwURL;
        }
        if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwURL) {
            ws = nodeStartingContext.gwURL;
        }
        if (!ws && !sharedWorker && !inproc) {
            ws = defaultWs;
        }
        var instanceId;
        var windowId;
        var pid;
        var environment;
        var region;
        var appName = getApplication();
        var uniqueAppName = appName;
        if (typeof glue42gd !== "undefined") {
            windowId = glue42gd.windowId;
            pid = glue42gd.pid;
            if (glue42gd.env) {
                environment = glue42gd.env.env;
                region = glue42gd.env.region;
            }
            uniqueAppName = (_c = glue42gd.application) !== null && _c !== void 0 ? _c : "glue-app";
            instanceId = glue42gd.appInstanceId;
        }
        else if (Utils.isNode()) {
            pid = process.pid;
            if (nodeStartingContext) {
                environment = nodeStartingContext.env;
                region = nodeStartingContext.region;
                instanceId = nodeStartingContext.instanceId;
            }
        }
        else if (typeof (window === null || window === void 0 ? void 0 : window.glue42electron) !== "undefined") {
            windowId = window === null || window === void 0 ? void 0 : window.glue42electron.instanceId;
            pid = window === null || window === void 0 ? void 0 : window.glue42electron.pid;
            environment = window === null || window === void 0 ? void 0 : window.glue42electron.env;
            region = window === null || window === void 0 ? void 0 : window.glue42electron.region;
            uniqueAppName = (_d = window === null || window === void 0 ? void 0 : window.glue42electron.application) !== null && _d !== void 0 ? _d : "glue-app";
            instanceId = window === null || window === void 0 ? void 0 : window.glue42electron.instanceId;
        }
        else ;
        var replaySpecs = (_f = (_e = configuration.gateway) === null || _e === void 0 ? void 0 : _e.replaySpecs) !== null && _f !== void 0 ? _f : [];
        replaySpecs.push(ContextMessageReplaySpec);
        var identity = {
            application: uniqueAppName,
            applicationName: appName,
            windowId: windowId,
            instance: instanceId,
            process: pid,
            region: region,
            environment: environment,
            api: ext.version || version
        };
        if (configuration.identity) {
            identity = Object.assign(identity, configuration.identity);
        }
        return {
            identity: identity,
            reconnectInterval: reconnectInterval,
            ws: ws,
            sharedWorker: sharedWorker,
            webPlatform: webPlatform,
            inproc: inproc,
            protocolVersion: protocolVersion,
            reconnectAttempts: reconnectAttempts,
            replaySpecs: replaySpecs,
        };
    }
    function getContexts() {
        if (typeof configuration.contexts === "undefined") {
            return { reAnnounceKnownContexts: true };
        }
        if (typeof configuration.contexts === "boolean" && configuration.contexts) {
            return { reAnnounceKnownContexts: true };
        }
        if (typeof configuration.contexts === "object") {
            return Object.assign({}, { reAnnounceKnownContexts: true }, configuration.contexts);
        }
        return false;
    }
    function getApplication() {
        if (configuration.application) {
            return configuration.application;
        }
        if (glue42gd) {
            return glue42gd.applicationName;
        }
        if (typeof window !== "undefined" && typeof window.glue42electron !== "undefined") {
            return window.glue42electron.application;
        }
        var uid = shortid();
        if (Utils.isNode()) {
            if (nodeStartingContext) {
                return nodeStartingContext.applicationConfig.name;
            }
            return "NodeJS" + uid;
        }
        if (typeof window !== "undefined" && typeof document !== "undefined") {
            return document.title + " (".concat(uid, ")");
        }
        return uid;
    }
    function getAuth() {
        var _a, _b, _c;
        if (typeof configuration.auth === "string") {
            return {
                token: configuration.auth
            };
        }
        if (configuration.auth) {
            return configuration.auth;
        }
        if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwToken) {
            return {
                gatewayToken: nodeStartingContext.gwToken
            };
        }
        if (((_a = configuration.gateway) === null || _a === void 0 ? void 0 : _a.webPlatform) || ((_b = configuration.gateway) === null || _b === void 0 ? void 0 : _b.inproc) || ((_c = configuration.gateway) === null || _c === void 0 ? void 0 : _c.sharedWorker)) {
            return {
                username: "glue42", password: "glue42"
            };
        }
    }
    function getLogger() {
        var _a, _b;
        var config = configuration.logger;
        var defaultLevel = "warn";
        if (!config) {
            config = defaultLevel;
        }
        var gdConsoleLevel;
        if (glue42gd) {
            gdConsoleLevel = glue42gd.consoleLogLevel;
        }
        if (typeof config === "string") {
            return { console: gdConsoleLevel !== null && gdConsoleLevel !== void 0 ? gdConsoleLevel : config, publish: defaultLevel };
        }
        return {
            console: (_a = gdConsoleLevel !== null && gdConsoleLevel !== void 0 ? gdConsoleLevel : config.console) !== null && _a !== void 0 ? _a : defaultLevel,
            publish: (_b = config.publish) !== null && _b !== void 0 ? _b : defaultLevel
        };
    }
    var connection = getConnection();
    var application = getApplication();
    if (typeof window !== "undefined") {
        var windowAsAny = window;
        var containerApplication = windowAsAny.htmlContainer ?
            "".concat(windowAsAny.htmlContainer.containerName, ".").concat(windowAsAny.htmlContainer.application) :
            (_a = windowAsAny === null || windowAsAny === void 0 ? void 0 : windowAsAny.glue42gd) === null || _a === void 0 ? void 0 : _a.application;
        if (containerApplication) {
            application = containerApplication;
        }
    }
    return {
        bus: (_b = configuration.bus) !== null && _b !== void 0 ? _b : false,
        application: application,
        auth: getAuth(),
        logger: getLogger(),
        connection: connection,
        metrics: (_c = configuration.metrics) !== null && _c !== void 0 ? _c : true,
        contexts: getContexts(),
        version: ext.version || version,
        libs: (_d = ext.libs) !== null && _d !== void 0 ? _d : [],
        customLogger: configuration.customLogger
    };
}

var GW3ContextData = (function () {
    function GW3ContextData(contextId, name, isAnnounced, activityId) {
        this.updateCallbacks = {};
        this.contextId = contextId;
        this.name = name;
        this.isAnnounced = isAnnounced;
        this.activityId = activityId;
        this.context = {};
    }
    GW3ContextData.prototype.hasCallbacks = function () {
        return Object.keys(this.updateCallbacks).length > 0;
    };
    GW3ContextData.prototype.getState = function () {
        if (this.isAnnounced && this.hasCallbacks()) {
            return 3;
        }
        if (this.isAnnounced) {
            return 2;
        }
        if (this.hasCallbacks()) {
            return 1;
        }
        return 0;
    };
    return GW3ContextData;
}());

function applyContextDelta(context, delta, logger) {
    try {
        if (logger === null || logger === void 0 ? void 0 : logger.canPublish("trace")) {
            logger === null || logger === void 0 ? void 0 : logger.trace("applying context delta ".concat(JSON.stringify(delta), " on context ").concat(JSON.stringify(context)));
        }
        if (!delta) {
            return context;
        }
        if (delta.reset) {
            context = __assign({}, delta.reset);
            return context;
        }
        context = deepClone(context, undefined);
        if (delta.commands) {
            for (var _i = 0, _a = delta.commands; _i < _a.length; _i++) {
                var command = _a[_i];
                if (command.type === "remove") {
                    deletePath(context, command.path);
                }
                else if (command.type === "set") {
                    setValueToPath(context, command.value, command.path);
                }
            }
            return context;
        }
        var added_1 = delta.added;
        var updated_1 = delta.updated;
        var removed = delta.removed;
        if (added_1) {
            Object.keys(added_1).forEach(function (key) {
                context[key] = added_1[key];
            });
        }
        if (updated_1) {
            Object.keys(updated_1).forEach(function (key) {
                mergeObjectsProperties(key, context, updated_1);
            });
        }
        if (removed) {
            removed.forEach(function (key) {
                delete context[key];
            });
        }
        return context;
    }
    catch (e) {
        logger === null || logger === void 0 ? void 0 : logger.error("error applying context delta ".concat(JSON.stringify(delta), " on context ").concat(JSON.stringify(context)), e);
        return context;
    }
}
function deepClone(obj, hash) {
    hash = hash || new WeakMap();
    if (Object(obj) !== obj) {
        return obj;
    }
    if (obj instanceof Set) {
        return new Set(obj);
    }
    if (hash.has(obj)) {
        return hash.get(obj);
    }
    var result = obj instanceof Date ? new Date(obj)
        : obj instanceof RegExp ? new RegExp(obj.source, obj.flags)
            : obj.constructor ? new obj.constructor()
                : Object.create(null);
    hash.set(obj, result);
    if (obj instanceof Map) {
        Array.from(obj, function (_a) {
            var key = _a[0], val = _a[1];
            return result.set(key, deepClone(val, hash));
        });
    }
    return Object.assign.apply(Object, __spreadArray([result], Object.keys(obj).map(function (key) {
        var _a;
        return (_a = {}, _a[key] = deepClone(obj[key], hash), _a);
    }), false));
}
var mergeObjectsProperties = function (key, what, withWhat) {
    var right = withWhat[key];
    if (right === undefined) {
        return what;
    }
    var left = what[key];
    if (!left || !right) {
        what[key] = right;
        return what;
    }
    if (typeof left === "string" ||
        typeof left === "number" ||
        typeof left === "boolean" ||
        typeof right === "string" ||
        typeof right === "number" ||
        typeof right === "boolean" ||
        Array.isArray(left) ||
        Array.isArray(right)) {
        what[key] = right;
        return what;
    }
    what[key] = Object.assign({}, left, right);
    return what;
};
function deepEqual(x, y) {
    if (x === y) {
        return true;
    }
    if (!(x instanceof Object) || !(y instanceof Object)) {
        return false;
    }
    if (x.constructor !== y.constructor) {
        return false;
    }
    for (var p in x) {
        if (!x.hasOwnProperty(p)) {
            continue;
        }
        if (!y.hasOwnProperty(p)) {
            return false;
        }
        if (x[p] === y[p]) {
            continue;
        }
        if (typeof (x[p]) !== "object") {
            return false;
        }
        if (!deepEqual(x[p], y[p])) {
            return false;
        }
    }
    for (var p in y) {
        if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {
            return false;
        }
    }
    return true;
}
function setValueToPath(obj, value, path) {
    var pathArr = path.split(".");
    var i;
    for (i = 0; i < pathArr.length - 1; i++) {
        if (!obj[pathArr[i]]) {
            obj[pathArr[i]] = {};
        }
        if (typeof obj[pathArr[i]] !== "object") {
            obj[pathArr[i]] = {};
        }
        obj = obj[pathArr[i]];
    }
    obj[pathArr[i]] = value;
}
function isSubset(superObj, subObj) {
    return Object.keys(subObj).every(function (ele) {
        if (typeof subObj[ele] === "object") {
            return isSubset((superObj === null || superObj === void 0 ? void 0 : superObj[ele]) || {}, subObj[ele] || {});
        }
        return subObj[ele] === (superObj === null || superObj === void 0 ? void 0 : superObj[ele]);
    });
}
function deletePath(obj, path) {
    var pathArr = path.split(".");
    var i;
    for (i = 0; i < pathArr.length - 1; i++) {
        if (!obj[pathArr[i]]) {
            return;
        }
        obj = obj[pathArr[i]];
    }
    delete obj[pathArr[i]];
}

var GW3Bridge = (function () {
    function GW3Bridge(config) {
        var _this = this;
        var _a;
        this._contextNameToData = {};
        this._gw3Subscriptions = [];
        this._nextCallbackSubscriptionNumber = 0;
        this._contextNameToId = {};
        this._contextIdToName = {};
        this._protocolVersion = undefined;
        this._contextsTempCache = {};
        this._contextsSubscriptionsCache = [];
        this._connection = config.connection;
        this._logger = config.logger;
        this._trackAllContexts = config.trackAllContexts;
        this._reAnnounceKnownContexts = config.reAnnounceKnownContexts;
        this._gw3Session = this._connection.domain("global", [
            GW_MESSAGE_CONTEXT_CREATED,
            GW_MESSAGE_SUBSCRIBED_CONTEXT,
            GW_MESSAGE_CONTEXT_DESTROYED,
            GW_MESSAGE_CONTEXT_UPDATED,
        ]);
        this._gw3Session.disconnected(this.resetState.bind(this));
        this._gw3Session.onJoined(function (wasReconnect) {
            if (!wasReconnect) {
                return;
            }
            if (!_this._reAnnounceKnownContexts) {
                return _this._connection.setLibReAnnounced({ name: "contexts" });
            }
            _this.reInitiateState().then(function () { return _this._connection.setLibReAnnounced({ name: "contexts" }); });
        });
        this.subscribeToContextCreatedMessages();
        this.subscribeToContextUpdatedMessages();
        this.subscribeToContextDestroyedMessages();
        (_a = this._connection.replayer) === null || _a === void 0 ? void 0 : _a.drain(ContextMessageReplaySpec.name, function (message) {
            var type = message.type;
            if (!type) {
                return;
            }
            if (type === GW_MESSAGE_CONTEXT_CREATED ||
                type === GW_MESSAGE_CONTEXT_ADDED ||
                type === GW_MESSAGE_ACTIVITY_CREATED) {
                _this.handleContextCreatedMessage(message);
            }
            else if (type === GW_MESSAGE_SUBSCRIBED_CONTEXT ||
                type === GW_MESSAGE_CONTEXT_UPDATED ||
                type === GW_MESSAGE_JOINED_ACTIVITY) {
                _this.handleContextUpdatedMessage(message);
            }
            else if (type === GW_MESSAGE_CONTEXT_DESTROYED ||
                type === GW_MESSAGE_ACTIVITY_DESTROYED) {
                _this.handleContextDestroyedMessage(message);
            }
        });
    }
    Object.defineProperty(GW3Bridge.prototype, "protocolVersion", {
        get: function () {
            var _a;
            if (!this._protocolVersion) {
                var contextsDomainInfo = this._connection.availableDomains.find(function (d) { return d.uri === "context"; });
                this._protocolVersion = (_a = contextsDomainInfo === null || contextsDomainInfo === void 0 ? void 0 : contextsDomainInfo.version) !== null && _a !== void 0 ? _a : 1;
            }
            return this._protocolVersion;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GW3Bridge.prototype, "setPathSupported", {
        get: function () {
            return this.protocolVersion >= 2;
        },
        enumerable: false,
        configurable: true
    });
    GW3Bridge.prototype.dispose = function () {
        for (var _i = 0, _a = this._gw3Subscriptions; _i < _a.length; _i++) {
            var sub = _a[_i];
            this._connection.off(sub);
        }
        this._gw3Subscriptions.length = 0;
        for (var contextName in this._contextNameToData) {
            if (this._contextNameToId.hasOwnProperty(contextName)) {
                delete this._contextNameToData[contextName];
            }
        }
    };
    GW3Bridge.prototype.createContext = function (name, data) {
        var _this = this;
        return this._gw3Session
            .send({
            type: GW_MESSAGE_CREATE_CONTEXT,
            domain: "global",
            name: name,
            data: data,
            lifetime: "retained",
        })
            .then(function (createContextMsg) {
            _this._contextNameToId[name] = createContextMsg.context_id;
            _this._contextIdToName[createContextMsg.context_id] = name;
            var contextData = _this._contextNameToData[name] || new GW3ContextData(createContextMsg.context_id, name, true, undefined);
            contextData.isAnnounced = true;
            contextData.name = name;
            contextData.contextId = createContextMsg.context_id;
            contextData.context = createContextMsg.data || data;
            contextData.hasReceivedSnapshot = true;
            _this._contextNameToData[name] = contextData;
            return createContextMsg.context_id;
        });
    };
    GW3Bridge.prototype.all = function () {
        var _this = this;
        return Object.keys(this._contextNameToData)
            .filter(function (name) { return _this._contextNameToData[name].isAnnounced; });
    };
    GW3Bridge.prototype.update = function (name, delta) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var contextData, currentContext, calculatedDelta;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        contextData = this._contextNameToData[name];
                        if (!contextData || !contextData.isAnnounced) {
                            return [2, this.createContext(name, delta)];
                        }
                        currentContext = contextData.context;
                        if (!!contextData.hasCallbacks()) return [3, 2];
                        return [4, this.get(contextData.name)];
                    case 1:
                        currentContext = _b.sent();
                        _b.label = 2;
                    case 2:
                        calculatedDelta = this.protocolVersion === 2 ?
                            this.calculateContextDeltaV2(currentContext, delta) :
                            this.calculateContextDeltaV1(currentContext, delta);
                        if (!Object.keys(calculatedDelta.added).length
                            && !Object.keys(calculatedDelta.updated).length
                            && !calculatedDelta.removed.length
                            && !((_a = calculatedDelta.commands) === null || _a === void 0 ? void 0 : _a.length)) {
                            return [2, Promise.resolve()];
                        }
                        return [2, this._gw3Session
                                .send({
                                type: GW_MESSAGE_UPDATE_CONTEXT,
                                domain: "global",
                                context_id: contextData.contextId,
                                delta: calculatedDelta,
                            }, {}, { skipPeerId: false })
                                .then(function (gwResponse) {
                                _this.handleUpdated(contextData, calculatedDelta, {
                                    updaterId: gwResponse.peer_id
                                });
                            })];
                }
            });
        });
    };
    GW3Bridge.prototype.set = function (name, data) {
        var _this = this;
        var contextData = this._contextNameToData[name];
        if (!contextData || !contextData.isAnnounced) {
            return this.createContext(name, data);
        }
        return this._gw3Session
            .send({
            type: GW_MESSAGE_UPDATE_CONTEXT,
            domain: "global",
            context_id: contextData.contextId,
            delta: { reset: data },
        }, {}, { skipPeerId: false })
            .then(function (gwResponse) {
            _this.handleUpdated(contextData, { reset: data, added: {}, removed: [], updated: {} }, { updaterId: gwResponse.peer_id });
        });
    };
    GW3Bridge.prototype.setPath = function (name, path, value) {
        if (!this.setPathSupported) {
            return Promise.reject("glue.contexts.setPath operation is not supported, use Glue42 3.10 or later");
        }
        return this.setPaths(name, [{ path: path, value: value }]);
    };
    GW3Bridge.prototype.setPaths = function (name, pathValues) {
        var _this = this;
        if (!this.setPathSupported) {
            return Promise.reject("glue.contexts.setPaths operation is not supported, use Glue42 3.10 or later");
        }
        var contextData = this._contextNameToData[name];
        if (!contextData || !contextData.isAnnounced) {
            var obj = {};
            for (var _i = 0, pathValues_1 = pathValues; _i < pathValues_1.length; _i++) {
                var pathValue = pathValues_1[_i];
                setValueToPath(obj, pathValue.value, pathValue.path);
            }
            return this.createContext(name, obj);
        }
        var commands = [];
        for (var _a = 0, pathValues_2 = pathValues; _a < pathValues_2.length; _a++) {
            var pathValue = pathValues_2[_a];
            if (pathValue.value === null) {
                commands.push({ type: "remove", path: pathValue.path });
            }
            else {
                commands.push({ type: "set", path: pathValue.path, value: pathValue.value });
            }
        }
        return this._gw3Session
            .send({
            type: GW_MESSAGE_UPDATE_CONTEXT,
            domain: "global",
            context_id: contextData.contextId,
            delta: { commands: commands }
        }, {}, { skipPeerId: false })
            .then(function (gwResponse) {
            _this.handleUpdated(contextData, { added: {}, removed: [], updated: {}, commands: commands }, { updaterId: gwResponse.peer_id });
        });
    };
    GW3Bridge.prototype.get = function (name) {
        var _this = this;
        var _a;
        var contextData = this._contextNameToData[name];
        if (!contextData || !contextData.isAnnounced) {
            return Promise.resolve({});
        }
        if (contextData && (!contextData.hasCallbacks() || !contextData.hasReceivedSnapshot)) {
            return new Promise(function (resolve) {
                _this.subscribe(name, function (data, _d, _r, un) {
                    _this.unsubscribe(un);
                    resolve(data);
                });
            });
        }
        var context = (_a = contextData === null || contextData === void 0 ? void 0 : contextData.context) !== null && _a !== void 0 ? _a : {};
        return Promise.resolve(context);
    };
    GW3Bridge.prototype.subscribe = function (name, callback, subscriptionKey) {
        var _this = this;
        var thisCallbackSubscriptionNumber = typeof subscriptionKey === "undefined" ? this._nextCallbackSubscriptionNumber : subscriptionKey;
        if (typeof subscriptionKey === "undefined") {
            this._nextCallbackSubscriptionNumber += 1;
        }
        if (this._contextsSubscriptionsCache.every(function (subscription) { return subscription.subKey !== _this._nextCallbackSubscriptionNumber; })) {
            this._contextsSubscriptionsCache.push({ contextName: name, subKey: thisCallbackSubscriptionNumber, callback: callback });
        }
        var contextData = this._contextNameToData[name];
        if (!contextData ||
            !contextData.isAnnounced) {
            contextData = contextData || new GW3ContextData(undefined, name, false, undefined);
            this._contextNameToData[name] = contextData;
            contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;
            return Promise.resolve(thisCallbackSubscriptionNumber);
        }
        var hadCallbacks = contextData.hasCallbacks();
        contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;
        if (!hadCallbacks) {
            if (!contextData.joinedActivity) {
                if (contextData.context && contextData.sentExplicitSubscription) {
                    if (contextData.hasReceivedSnapshot) {
                        var clone = deepClone(contextData.context);
                        callback(clone, clone, [], thisCallbackSubscriptionNumber);
                    }
                    return Promise.resolve(thisCallbackSubscriptionNumber);
                }
                return this.sendSubscribe(contextData)
                    .then(function () { return thisCallbackSubscriptionNumber; });
            }
            else {
                if (contextData.hasReceivedSnapshot) {
                    var clone = deepClone(contextData.context);
                    callback(clone, clone, [], thisCallbackSubscriptionNumber);
                }
                return Promise.resolve(thisCallbackSubscriptionNumber);
            }
        }
        else {
            if (contextData.hasReceivedSnapshot) {
                var clone = deepClone(contextData.context);
                callback(clone, clone, [], thisCallbackSubscriptionNumber);
            }
            return Promise.resolve(thisCallbackSubscriptionNumber);
        }
    };
    GW3Bridge.prototype.unsubscribe = function (subscriptionKey) {
        this._contextsSubscriptionsCache = this._contextsSubscriptionsCache.filter(function (subscription) { return subscription.subKey !== subscriptionKey; });
        for (var _i = 0, _a = Object.keys(this._contextNameToData); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            var contextData = this._contextNameToData[name_1];
            if (!contextData) {
                return;
            }
            var hadCallbacks = contextData.hasCallbacks();
            delete contextData.updateCallbacks[subscriptionKey];
            if (contextData.isAnnounced &&
                hadCallbacks &&
                !contextData.hasCallbacks() &&
                contextData.sentExplicitSubscription) {
                this.sendUnsubscribe(contextData);
            }
            if (!contextData.isAnnounced &&
                !contextData.hasCallbacks()) {
                delete this._contextNameToData[name_1];
            }
        }
    };
    GW3Bridge.prototype.destroy = function (name) {
        var contextData = this._contextNameToData[name];
        if (!contextData) {
            return Promise.reject("context with ".concat(name, " does not exist"));
        }
        return this._gw3Session
            .send({
            type: GW_MESSAGE_DESTROY_CONTEXT,
            domain: "global",
            context_id: contextData.contextId,
        }).then(function (_) { return undefined; });
    };
    GW3Bridge.prototype.handleUpdated = function (contextData, delta, extraData) {
        var oldContext = contextData.context;
        contextData.context = applyContextDelta(contextData.context, delta, this._logger);
        contextData.hasReceivedSnapshot = true;
        if (this._contextNameToData[contextData.name] === contextData &&
            !deepEqual(oldContext, contextData.context)) {
            this.invokeUpdateCallbacks(contextData, delta, extraData);
        }
    };
    GW3Bridge.prototype.subscribeToContextCreatedMessages = function () {
        var createdMessageTypes = [
            GW_MESSAGE_CONTEXT_ADDED,
            GW_MESSAGE_CONTEXT_CREATED,
            GW_MESSAGE_ACTIVITY_CREATED,
        ];
        for (var _i = 0, createdMessageTypes_1 = createdMessageTypes; _i < createdMessageTypes_1.length; _i++) {
            var createdMessageType = createdMessageTypes_1[_i];
            var sub = this._connection.on(createdMessageType, this.handleContextCreatedMessage.bind(this));
            this._gw3Subscriptions.push(sub);
        }
    };
    GW3Bridge.prototype.handleContextCreatedMessage = function (contextCreatedMsg) {
        var _this = this;
        var createdMessageType = contextCreatedMsg.type;
        if (createdMessageType === GW_MESSAGE_ACTIVITY_CREATED) {
            this._contextNameToId[contextCreatedMsg.activity_id] = contextCreatedMsg.context_id;
            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.activity_id;
        }
        else if (createdMessageType === GW_MESSAGE_CONTEXT_ADDED) {
            this._contextNameToId[contextCreatedMsg.name] = contextCreatedMsg.context_id;
            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.name;
        }
        else ;
        var name = this._contextIdToName[contextCreatedMsg.context_id];
        if (!name) {
            throw new Error("Received created event for context with unknown name: " + contextCreatedMsg.context_id);
        }
        if (!this._contextNameToId[name]) {
            throw new Error("Received created event for context with unknown id: " + contextCreatedMsg.context_id);
        }
        var contextData = this._contextNameToData[name];
        if (contextData) {
            if (contextData.isAnnounced) {
                return;
            }
            else {
                if (!contextData.hasCallbacks()) {
                    throw new Error("Assertion failure: contextData.hasCallbacks()");
                }
                contextData.isAnnounced = true;
                contextData.contextId = contextCreatedMsg.context_id;
                contextData.activityId = contextCreatedMsg.activity_id;
                if (!contextData.sentExplicitSubscription) {
                    this.sendSubscribe(contextData);
                }
            }
        }
        else {
            this._contextNameToData[name] = contextData =
                new GW3ContextData(contextCreatedMsg.context_id, name, true, contextCreatedMsg.activity_id);
            if (this._trackAllContexts) {
                this.subscribe(name, function () { }).then(function (subKey) { return _this._systemContextsSubKey = subKey; });
            }
        }
    };
    GW3Bridge.prototype.subscribeToContextUpdatedMessages = function () {
        var updatedMessageTypes = [
            GW_MESSAGE_CONTEXT_UPDATED,
            GW_MESSAGE_SUBSCRIBED_CONTEXT,
            GW_MESSAGE_JOINED_ACTIVITY,
        ];
        for (var _i = 0, updatedMessageTypes_1 = updatedMessageTypes; _i < updatedMessageTypes_1.length; _i++) {
            var updatedMessageType = updatedMessageTypes_1[_i];
            var sub = this._connection.on(updatedMessageType, this.handleContextUpdatedMessage.bind(this));
            this._gw3Subscriptions.push(sub);
        }
    };
    GW3Bridge.prototype.handleContextUpdatedMessage = function (contextUpdatedMsg) {
        var updatedMessageType = contextUpdatedMsg.type;
        var contextId = contextUpdatedMsg.context_id;
        var contextData = this._contextNameToData[this._contextIdToName[contextId]];
        var justSeen = !contextData || !contextData.isAnnounced;
        if (updatedMessageType === GW_MESSAGE_JOINED_ACTIVITY) {
            if (!contextData) {
                contextData = new GW3ContextData(contextId, contextUpdatedMsg.activity_id, true, contextUpdatedMsg.activity_id);
                this._contextNameToData[contextUpdatedMsg.activity_id] = contextData;
                this._contextIdToName[contextId] = contextUpdatedMsg.activity_id;
                this._contextNameToId[contextUpdatedMsg.activity_id] = contextId;
            }
            else {
                contextData.contextId = contextId;
                contextData.isAnnounced = true;
                contextData.activityId = contextUpdatedMsg.activity_id;
            }
            contextData.joinedActivity = true;
        }
        else {
            if (!contextData || !contextData.isAnnounced) {
                if (updatedMessageType === GW_MESSAGE_SUBSCRIBED_CONTEXT) {
                    contextData = contextData || new GW3ContextData(contextId, contextUpdatedMsg.name, true, undefined);
                    contextData.sentExplicitSubscription = true;
                    this._contextNameToData[contextUpdatedMsg.name] = contextData;
                    this._contextIdToName[contextId] = contextUpdatedMsg.name;
                    this._contextNameToId[contextUpdatedMsg.name] = contextId;
                }
                else {
                    this._logger.error("Received 'update' for unknown context: ".concat(contextId));
                }
                return;
            }
        }
        var oldContext = contextData.context;
        contextData.hasReceivedSnapshot = true;
        if (updatedMessageType === GW_MESSAGE_SUBSCRIBED_CONTEXT) {
            contextData.context = contextUpdatedMsg.data || {};
        }
        else if (updatedMessageType === GW_MESSAGE_JOINED_ACTIVITY) {
            contextData.context = contextUpdatedMsg.context_snapshot || {};
        }
        else if (updatedMessageType === GW_MESSAGE_CONTEXT_UPDATED) {
            contextData.context = applyContextDelta(contextData.context, contextUpdatedMsg.delta, this._logger);
        }
        else {
            throw new Error("Unrecognized context update message " + updatedMessageType);
        }
        if (justSeen ||
            !deepEqual(contextData.context, oldContext) ||
            updatedMessageType === GW_MESSAGE_SUBSCRIBED_CONTEXT) {
            this.invokeUpdateCallbacks(contextData, contextUpdatedMsg.delta, { updaterId: contextUpdatedMsg.updater_id });
        }
    };
    GW3Bridge.prototype.invokeUpdateCallbacks = function (contextData, delta, extraData) {
        delta = delta || { added: {}, updated: {}, reset: {}, removed: [] };
        if (delta.commands) {
            delta.added = delta.updated = delta.reset = {};
            delta.removed = [];
            for (var _i = 0, _a = delta.commands; _i < _a.length; _i++) {
                var command = _a[_i];
                if (command.type === "remove") {
                    if (command.path.indexOf(".") === -1) {
                        delta.removed.push(command.path);
                    }
                    setValueToPath(delta.updated, null, command.path);
                }
                else if (command.type === "set") {
                    setValueToPath(delta.updated, command.value, command.path);
                }
            }
        }
        for (var updateCallbackIndex in contextData.updateCallbacks) {
            if (contextData.updateCallbacks.hasOwnProperty(updateCallbackIndex)) {
                try {
                    var updateCallback = contextData.updateCallbacks[updateCallbackIndex];
                    updateCallback(deepClone(contextData.context), Object.assign({}, delta.added || {}, delta.updated || {}, delta.reset || {}), delta.removed, parseInt(updateCallbackIndex, 10), extraData);
                }
                catch (err) {
                    this._logger.debug("callback error: " + JSON.stringify(err));
                }
            }
        }
    };
    GW3Bridge.prototype.subscribeToContextDestroyedMessages = function () {
        var destroyedMessageTypes = [
            GW_MESSAGE_CONTEXT_DESTROYED,
            GW_MESSAGE_ACTIVITY_DESTROYED,
        ];
        for (var _i = 0, destroyedMessageTypes_1 = destroyedMessageTypes; _i < destroyedMessageTypes_1.length; _i++) {
            var destroyedMessageType = destroyedMessageTypes_1[_i];
            var sub = this._connection.on(destroyedMessageType, this.handleContextDestroyedMessage.bind(this));
            this._gw3Subscriptions.push(sub);
        }
    };
    GW3Bridge.prototype.handleContextDestroyedMessage = function (destroyedMsg) {
        var destroyedMessageType = destroyedMsg.type;
        var contextId;
        var name;
        if (destroyedMessageType === GW_MESSAGE_ACTIVITY_DESTROYED) {
            name = destroyedMsg.activity_id;
            contextId = this._contextNameToId[name];
            if (!contextId) {
                this._logger.error("Received 'destroyed' for unknown activity: ".concat(destroyedMsg.activity_id));
                return;
            }
        }
        else {
            contextId = destroyedMsg.context_id;
            name = this._contextIdToName[contextId];
            if (!name) {
                this._logger.error("Received 'destroyed' for unknown context: ".concat(destroyedMsg.context_id));
                return;
            }
        }
        delete this._contextIdToName[contextId];
        delete this._contextNameToId[name];
        var contextData = this._contextNameToData[name];
        delete this._contextNameToData[name];
        if (!contextData || !contextData.isAnnounced) {
            this._logger.error("Received 'destroyed' for unknown context: ".concat(contextId));
            return;
        }
    };
    GW3Bridge.prototype.sendSubscribe = function (contextData) {
        contextData.sentExplicitSubscription = true;
        return this._gw3Session
            .send({
            type: GW_MESSAGE_SUBSCRIBE_CONTEXT,
            domain: "global",
            context_id: contextData.contextId,
        }).then(function (_) { return undefined; });
    };
    GW3Bridge.prototype.sendUnsubscribe = function (contextData) {
        contextData.sentExplicitSubscription = false;
        return this._gw3Session
            .send({
            type: GW_MESSAGE_UNSUBSCRIBE_CONTEXT,
            domain: "global",
            context_id: contextData.contextId,
        }).then(function (_) { return undefined; });
    };
    GW3Bridge.prototype.calculateContextDeltaV1 = function (from, to) {
        var delta = { added: {}, updated: {}, removed: [], reset: undefined };
        if (from) {
            for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {
                var x = _a[_i];
                if (Object.keys(to).indexOf(x) !== -1
                    && to[x] !== null
                    && !deepEqual(from[x], to[x])) {
                    delta.updated[x] = to[x];
                }
            }
        }
        for (var _b = 0, _c = Object.keys(to); _b < _c.length; _b++) {
            var x = _c[_b];
            if (!from || (Object.keys(from).indexOf(x) === -1)) {
                if (to[x] !== null) {
                    delta.added[x] = to[x];
                }
            }
            else if (to[x] === null) {
                delta.removed.push(x);
            }
        }
        return delta;
    };
    GW3Bridge.prototype.calculateContextDeltaV2 = function (from, to) {
        var _a, _b;
        var delta = { added: {}, updated: {}, removed: [], reset: undefined, commands: [] };
        for (var _i = 0, _c = Object.keys(to); _i < _c.length; _i++) {
            var x = _c[_i];
            if (to[x] !== null) {
                var fromX = from ? from[x] : null;
                if (!deepEqual(fromX, to[x])) {
                    (_a = delta.commands) === null || _a === void 0 ? void 0 : _a.push({ type: "set", path: x, value: to[x] });
                }
            }
            else {
                (_b = delta.commands) === null || _b === void 0 ? void 0 : _b.push({ type: "remove", path: x });
            }
        }
        return delta;
    };
    GW3Bridge.prototype.resetState = function () {
        var _this = this;
        for (var _i = 0, _a = this._gw3Subscriptions; _i < _a.length; _i++) {
            var sub = _a[_i];
            this._connection.off(sub);
        }
        if (this._systemContextsSubKey) {
            this.unsubscribe(this._systemContextsSubKey);
            delete this._systemContextsSubKey;
        }
        this._gw3Subscriptions = [];
        this._contextNameToId = {};
        this._contextIdToName = {};
        delete this._protocolVersion;
        this._contextsTempCache = Object.keys(this._contextNameToData).reduce(function (cacheSoFar, ctxName) {
            cacheSoFar[ctxName] = _this._contextNameToData[ctxName].context;
            return cacheSoFar;
        }, {});
        this._contextNameToData = {};
    };
    GW3Bridge.prototype.reInitiateState = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _b, _c, _e, _i, ctxName, lastKnownData;
            var _this = this;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        this.subscribeToContextCreatedMessages();
                        this.subscribeToContextUpdatedMessages();
                        this.subscribeToContextDestroyedMessages();
                        (_a = this._connection.replayer) === null || _a === void 0 ? void 0 : _a.drain(ContextMessageReplaySpec.name, function (message) {
                            var type = message.type;
                            if (!type) {
                                return;
                            }
                            if (type === GW_MESSAGE_CONTEXT_CREATED ||
                                type === GW_MESSAGE_CONTEXT_ADDED ||
                                type === GW_MESSAGE_ACTIVITY_CREATED) {
                                _this.handleContextCreatedMessage(message);
                            }
                            else if (type === GW_MESSAGE_SUBSCRIBED_CONTEXT ||
                                type === GW_MESSAGE_CONTEXT_UPDATED ||
                                type === GW_MESSAGE_JOINED_ACTIVITY) {
                                _this.handleContextUpdatedMessage(message);
                            }
                            else if (type === GW_MESSAGE_CONTEXT_DESTROYED ||
                                type === GW_MESSAGE_ACTIVITY_DESTROYED) {
                                _this.handleContextDestroyedMessage(message);
                            }
                        });
                        return [4, Promise.all(this._contextsSubscriptionsCache.map(function (subscription) { return _this.subscribe(subscription.contextName, subscription.callback, subscription.subKey); }))];
                    case 1:
                        _f.sent();
                        return [4, this.flushQueue()];
                    case 2:
                        _f.sent();
                        _b = this._contextsTempCache;
                        _c = [];
                        for (_e in _b)
                            _c.push(_e);
                        _i = 0;
                        _f.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3, 7];
                        _e = _c[_i];
                        if (!(_e in _b)) return [3, 6];
                        ctxName = _e;
                        if (typeof this._contextsTempCache[ctxName] !== "object" || Object.keys(this._contextsTempCache[ctxName]).length === 0) {
                            return [3, 6];
                        }
                        lastKnownData = this._contextsTempCache[ctxName];
                        this._logger.info("Re-announcing known context: ".concat(ctxName));
                        return [4, this.flushQueue()];
                    case 4:
                        _f.sent();
                        return [4, this.update(ctxName, lastKnownData)];
                    case 5:
                        _f.sent();
                        _f.label = 6;
                    case 6:
                        _i++;
                        return [3, 3];
                    case 7:
                        this._contextsTempCache = {};
                        this._logger.info("Contexts are re-announced");
                        return [2];
                }
            });
        });
    };
    GW3Bridge.prototype.flushQueue = function () {
        return new Promise(function (resolve) { return setTimeout(function () { return resolve(); }, 0); });
    };
    return GW3Bridge;
}());

var ContextsModule = (function () {
    function ContextsModule(config) {
        this._bridge = new GW3Bridge(config);
    }
    ContextsModule.prototype.all = function () {
        return this._bridge.all();
    };
    ContextsModule.prototype.update = function (name, data) {
        this.checkName(name);
        this.checkData(data);
        return this._bridge.update(name, data);
    };
    ContextsModule.prototype.set = function (name, data) {
        this.checkName(name);
        this.checkData(data);
        return this._bridge.set(name, data);
    };
    ContextsModule.prototype.setPath = function (name, path, data) {
        this.checkName(name);
        this.checkPath(path);
        var isTopLevelPath = path === "";
        if (isTopLevelPath) {
            this.checkData(data);
            return this.set(name, data);
        }
        return this._bridge.setPath(name, path, data);
    };
    ContextsModule.prototype.setPaths = function (name, paths) {
        this.checkName(name);
        if (!Array.isArray(paths)) {
            throw new Error("Please provide the paths as an array of PathValues!");
        }
        for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
            var _a = paths_1[_i], path = _a.path, value = _a.value;
            this.checkPath(path);
            var isTopLevelPath = path === "";
            if (isTopLevelPath) {
                this.checkData(value);
            }
        }
        return this._bridge.setPaths(name, paths);
    };
    ContextsModule.prototype.subscribe = function (name, callback) {
        var _this = this;
        this.checkName(name);
        if (typeof callback !== "function") {
            throw new Error("Please provide the callback as a function!");
        }
        return this._bridge
            .subscribe(name, function (data, delta, removed, key, extraData) { return callback(data, delta, removed, function () { return _this._bridge.unsubscribe(key); }, extraData); })
            .then(function (key) {
            return function () {
                _this._bridge.unsubscribe(key);
            };
        });
    };
    ContextsModule.prototype.get = function (name) {
        this.checkName(name);
        return this._bridge.get(name);
    };
    ContextsModule.prototype.ready = function () {
        return Promise.resolve(this);
    };
    ContextsModule.prototype.destroy = function (name) {
        this.checkName(name);
        return this._bridge.destroy(name);
    };
    Object.defineProperty(ContextsModule.prototype, "setPathSupported", {
        get: function () {
            return this._bridge.setPathSupported;
        },
        enumerable: false,
        configurable: true
    });
    ContextsModule.prototype.checkName = function (name) {
        if (typeof name !== "string" || name === "") {
            throw new Error("Please provide the name as a non-empty string!");
        }
    };
    ContextsModule.prototype.checkPath = function (path) {
        if (typeof path !== "string") {
            throw new Error("Please provide the path as a dot delimited string!");
        }
    };
    ContextsModule.prototype.checkData = function (data) {
        if (typeof data !== "object") {
            throw new Error("Please provide the data as an object!");
        }
    };
    return ContextsModule;
}());

function promisify (promise, successCallback, errorCallback) {
    if (typeof successCallback !== "function" && typeof errorCallback !== "function") {
        return promise;
    }
    if (typeof successCallback !== "function") {
        successCallback = function () { };
    }
    else if (typeof errorCallback !== "function") {
        errorCallback = function () { };
    }
    return promise.then(successCallback, errorCallback);
}

function rejectAfter(ms, promise, error) {
    if (ms === void 0) { ms = 0; }
    var timeout;
    var clearTimeoutIfThere = function () {
        if (timeout) {
            clearTimeout(timeout);
        }
    };
    promise
        .then(function () {
        clearTimeoutIfThere();
    })
        .catch(function () {
        clearTimeoutIfThere();
    });
    return new Promise(function (resolve, reject) {
        timeout = setTimeout(function () { return reject(error); }, ms);
    });
}

var InvokeStatus;
(function (InvokeStatus) {
    InvokeStatus[InvokeStatus["Success"] = 0] = "Success";
    InvokeStatus[InvokeStatus["Error"] = 1] = "Error";
})(InvokeStatus || (InvokeStatus = {}));
var Client = (function () {
    function Client(protocol, repo, instance, configuration) {
        this.protocol = protocol;
        this.repo = repo;
        this.instance = instance;
        this.configuration = configuration;
    }
    Client.prototype.subscribe = function (method, options, successCallback, errorCallback, existingSub) {
        var _this = this;
        var callProtocolSubscribe = function (targetServers, stream, successProxy, errorProxy) {
            var _a;
            options.methodResponseTimeout = (_a = options.methodResponseTimeout) !== null && _a !== void 0 ? _a : options.waitTimeoutMs;
            _this.protocol.client.subscribe(stream, options, targetServers, successProxy, errorProxy, existingSub);
        };
        var promise = new Promise(function (resolve, reject) {
            var successProxy = function (sub) {
                resolve(sub);
            };
            var errorProxy = function (err) {
                reject(err);
            };
            if (!method) {
                reject("Method definition is required. Please, provide either a unique string for a method name or a \u201CmethodDefinition\u201D object with a required \u201Cname\u201D property.");
                return;
            }
            var methodDef;
            if (typeof method === "string") {
                methodDef = { name: method };
            }
            else {
                methodDef = method;
            }
            if (!methodDef.name) {
                reject("Method definition is required. Please, provide either a unique string for a method name or a \u201CmethodDefinition\u201D object with a required \u201Cname\u201D property.");
                return;
            }
            if (options === undefined) {
                options = {};
            }
            var target = options.target;
            if (target === undefined) {
                target = "best";
            }
            if (typeof target === "string" && target !== "all" && target !== "best") {
                reject(new Error("\"".concat(target, "\" is not a valid target. Valid targets are \"all\", \"best\", or an instance.")));
                return;
            }
            if (options.methodResponseTimeout === undefined) {
                options.methodResponseTimeout = options.method_response_timeout;
                if (options.methodResponseTimeout === undefined) {
                    options.methodResponseTimeout = _this.configuration.methodResponseTimeout;
                }
            }
            if (options.waitTimeoutMs === undefined) {
                options.waitTimeoutMs = options.wait_for_method_timeout;
                if (options.waitTimeoutMs === undefined) {
                    options.waitTimeoutMs = _this.configuration.waitTimeoutMs;
                }
            }
            var delayStep = 500;
            var delayTillNow = 0;
            var currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);
            if (currentServers.length > 0) {
                callProtocolSubscribe(currentServers, currentServers[0].methods[0], successProxy, errorProxy);
            }
            else {
                var retry_1 = function () {
                    if (!target || !(options.waitTimeoutMs)) {
                        return;
                    }
                    delayTillNow += delayStep;
                    currentServers = _this.getServerMethodsByFilterAndTarget(methodDef, target);
                    if (currentServers.length > 0) {
                        var streamInfo = currentServers[0].methods[0];
                        callProtocolSubscribe(currentServers, streamInfo, successProxy, errorProxy);
                    }
                    else if (delayTillNow >= options.waitTimeoutMs) {
                        var def = typeof method === "string" ? { name: method } : method;
                        callProtocolSubscribe(currentServers, def, successProxy, errorProxy);
                    }
                    else {
                        setTimeout(retry_1, delayStep);
                    }
                };
                setTimeout(retry_1, delayStep);
            }
        });
        return promisify(promise, successCallback, errorCallback);
    };
    Client.prototype.servers = function (methodFilter) {
        var filterCopy = methodFilter === undefined
            ? undefined
            : __assign({}, methodFilter);
        return this.getServers(filterCopy).map(function (serverMethodMap) {
            return serverMethodMap.server.instance;
        });
    };
    Client.prototype.methods = function (methodFilter) {
        if (typeof methodFilter === "string") {
            methodFilter = { name: methodFilter };
        }
        else {
            methodFilter = __assign({}, methodFilter);
        }
        return this.getMethods(methodFilter);
    };
    Client.prototype.methodsForInstance = function (instance) {
        return this.getMethodsForInstance(instance);
    };
    Client.prototype.methodAdded = function (callback) {
        return this.repo.onMethodAdded(callback);
    };
    Client.prototype.methodRemoved = function (callback) {
        return this.repo.onMethodRemoved(callback);
    };
    Client.prototype.serverAdded = function (callback) {
        return this.repo.onServerAdded(callback);
    };
    Client.prototype.serverRemoved = function (callback) {
        return this.repo.onServerRemoved(function (server, reason) {
            callback(server, reason);
        });
    };
    Client.prototype.serverMethodAdded = function (callback) {
        return this.repo.onServerMethodAdded(function (server, method) {
            callback({ server: server, method: method });
        });
    };
    Client.prototype.serverMethodRemoved = function (callback) {
        return this.repo.onServerMethodRemoved(function (server, method) {
            callback({ server: server, method: method });
        });
    };
    Client.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {
        return __awaiter(this, void 0, void 0, function () {
            var getInvokePromise;
            var _this = this;
            return __generator(this, function (_a) {
                getInvokePromise = function () { return __awaiter(_this, void 0, void 0, function () {
                    var methodDefinition, serversMethodMap, method, errorObj, timeout, additionalOptionsCopy, invokePromises, invocationMessages, results, allRejected;
                    var _this = this;
                    var _a, _b, _c;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                if (typeof methodFilter === "string") {
                                    methodDefinition = { name: methodFilter };
                                }
                                else {
                                    methodDefinition = __assign({}, methodFilter);
                                }
                                if (!methodDefinition.name) {
                                    return [2, Promise.reject("Method definition is required. Please, provide either a unique string for a method name or a \u201CmethodDefinition\u201D object with a required \u201Cname\u201D property.")];
                                }
                                if (!argumentObj) {
                                    argumentObj = {};
                                }
                                if (!target) {
                                    target = "best";
                                }
                                if (typeof target === "string" && target !== "all" && target !== "best" && target !== "skipMine") {
                                    return [2, Promise.reject(new Error("\"".concat(target, "\" is not a valid target. Valid targets are \"all\" and \"best\".")))];
                                }
                                if (!additionalOptions) {
                                    additionalOptions = {};
                                }
                                if (additionalOptions.methodResponseTimeoutMs === undefined) {
                                    additionalOptions.methodResponseTimeoutMs = additionalOptions.method_response_timeout;
                                    if (additionalOptions.methodResponseTimeoutMs === undefined) {
                                        additionalOptions.methodResponseTimeoutMs = this.configuration.methodResponseTimeout;
                                    }
                                }
                                if (additionalOptions.waitTimeoutMs === undefined) {
                                    additionalOptions.waitTimeoutMs = additionalOptions.wait_for_method_timeout;
                                    if (additionalOptions.waitTimeoutMs === undefined) {
                                        additionalOptions.waitTimeoutMs = this.configuration.waitTimeoutMs;
                                    }
                                }
                                if (additionalOptions.waitTimeoutMs !== undefined && typeof additionalOptions.waitTimeoutMs !== "number") {
                                    return [2, Promise.reject(new Error("\"".concat(additionalOptions.waitTimeoutMs, "\" is not a valid number for \"waitTimeoutMs\" ")))];
                                }
                                if (typeof argumentObj !== "object") {
                                    return [2, Promise.reject(new Error("The method arguments must be an object. method: ".concat(methodDefinition.name)))];
                                }
                                serversMethodMap = this.getServerMethodsByFilterAndTarget(methodDefinition, target);
                                if (!(serversMethodMap.length === 0)) return [3, 4];
                                _d.label = 1;
                            case 1:
                                _d.trys.push([1, 3, , 4]);
                                return [4, this.tryToAwaitForMethods(methodDefinition, target, additionalOptions)];
                            case 2:
                                serversMethodMap = _d.sent();
                                return [3, 4];
                            case 3:
                                _d.sent();
                                method = __assign(__assign({}, methodDefinition), { getServers: function () { return []; }, supportsStreaming: false, objectTypes: (_a = methodDefinition.objectTypes) !== null && _a !== void 0 ? _a : [], flags: (_c = (_b = methodDefinition.flags) === null || _b === void 0 ? void 0 : _b.metadata) !== null && _c !== void 0 ? _c : {} });
                                errorObj = {
                                    method: method,
                                    called_with: argumentObj,
                                    message: "Can not find a method matching ".concat(JSON.stringify(methodFilter), " with server filter ").concat(JSON.stringify(target)),
                                    executed_by: undefined,
                                    returned: undefined,
                                    status: undefined,
                                };
                                return [2, Promise.reject(errorObj)];
                            case 4:
                                timeout = additionalOptions.methodResponseTimeoutMs;
                                additionalOptionsCopy = additionalOptions;
                                invokePromises = serversMethodMap.map(function (serversMethodPair) {
                                    var invId = shortid();
                                    var method = serversMethodPair.methods[0];
                                    var server = serversMethodPair.server;
                                    var invokePromise = _this.protocol.client.invoke(invId, method, argumentObj, server, additionalOptionsCopy);
                                    return Promise.race([
                                        invokePromise,
                                        rejectAfter(timeout, invokePromise, {
                                            invocationId: invId,
                                            message: "Invocation timeout (".concat(timeout, " ms) reached for method name: ").concat(method === null || method === void 0 ? void 0 : method.name, ", target instance: ").concat(JSON.stringify(server.instance), ", options: ").concat(JSON.stringify(additionalOptionsCopy)),
                                            status: InvokeStatus.Error,
                                        })
                                    ]);
                                });
                                return [4, Promise.all(invokePromises)];
                            case 5:
                                invocationMessages = _d.sent();
                                results = this.getInvocationResultObj(invocationMessages, methodDefinition, argumentObj);
                                allRejected = invocationMessages.every(function (result) { return result.status === InvokeStatus.Error; });
                                if (allRejected) {
                                    return [2, Promise.reject(results)];
                                }
                                return [2, results];
                        }
                    });
                }); };
                return [2, promisify(getInvokePromise(), success, error)];
            });
        });
    };
    Client.prototype.getInvocationResultObj = function (invocationResults, method, calledWith) {
        var all_return_values = invocationResults
            .filter(function (invokeMessage) { return invokeMessage.status === InvokeStatus.Success; })
            .reduce(function (allValues, currentValue) {
            allValues = __spreadArray(__spreadArray([], allValues, true), [
                {
                    executed_by: currentValue.instance,
                    returned: currentValue.result,
                    called_with: calledWith,
                    method: method,
                    message: currentValue.message,
                    status: currentValue.status,
                }
            ], false);
            return allValues;
        }, []);
        var all_errors = invocationResults
            .filter(function (invokeMessage) { return invokeMessage.status === InvokeStatus.Error; })
            .reduce(function (allErrors, currError) {
            allErrors = __spreadArray(__spreadArray([], allErrors, true), [
                {
                    executed_by: currError.instance,
                    called_with: calledWith,
                    name: method.name,
                    message: currError.message,
                }
            ], false);
            return allErrors;
        }, []);
        var invResult = invocationResults[0];
        var result = {
            method: method,
            called_with: calledWith,
            returned: invResult.result,
            executed_by: invResult.instance,
            all_return_values: all_return_values,
            all_errors: all_errors,
            message: invResult.message,
            status: invResult.status
        };
        return result;
    };
    Client.prototype.tryToAwaitForMethods = function (methodDefinition, target, additionalOptions) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (additionalOptions.waitTimeoutMs === 0) {
                reject();
                return;
            }
            var delayStep = 500;
            var delayTillNow = 0;
            var retry = function () {
                delayTillNow += delayStep;
                var serversMethodMap = _this.getServerMethodsByFilterAndTarget(methodDefinition, target);
                if (serversMethodMap.length > 0) {
                    clearInterval(interval);
                    resolve(serversMethodMap);
                }
                else if (delayTillNow >= (additionalOptions.waitTimeoutMs || 10000)) {
                    clearInterval(interval);
                    reject();
                    return;
                }
            };
            var interval = setInterval(retry, delayStep);
        });
    };
    Client.prototype.filterByTarget = function (target, serverMethodMap) {
        var _this = this;
        if (typeof target === "string") {
            if (target === "all") {
                return __spreadArray([], serverMethodMap, true);
            }
            else if (target === "best") {
                var localMachine = serverMethodMap
                    .find(function (s) { return s.server.instance.isLocal; });
                if (localMachine) {
                    return [localMachine];
                }
                if (serverMethodMap[0] !== undefined) {
                    return [serverMethodMap[0]];
                }
            }
            else if (target === "skipMine") {
                return serverMethodMap.filter(function (_a) {
                    var server = _a.server;
                    return server.instance.peerId !== _this.instance.peerId;
                });
            }
        }
        else {
            var targetArray = void 0;
            if (!Array.isArray(target)) {
                targetArray = [target];
            }
            else {
                targetArray = target;
            }
            var allServersMatching = targetArray.reduce(function (matches, filter) {
                var myMatches = serverMethodMap.filter(function (serverMethodPair) {
                    return _this.instanceMatch(filter, serverMethodPair.server.instance);
                });
                return matches.concat(myMatches);
            }, []);
            return allServersMatching;
        }
        return [];
    };
    Client.prototype.instanceMatch = function (instanceFilter, instanceDefinition) {
        return this.containsProps(instanceFilter, instanceDefinition);
    };
    Client.prototype.methodMatch = function (methodFilter, methodDefinition) {
        return this.containsProps(methodFilter, methodDefinition);
    };
    Client.prototype.containsProps = function (filter, repoMethod) {
        var filterProps = Object.keys(filter)
            .filter(function (prop) {
            return filter[prop] !== undefined
                && filter[prop] !== null
                && typeof filter[prop] !== "function"
                && prop !== "object_types"
                && prop !== "display_name"
                && prop !== "id"
                && prop !== "gatewayId"
                && prop !== "identifier"
                && prop[0] !== "_";
        });
        return filterProps.every(function (prop) {
            var isMatch;
            var filterValue = filter[prop];
            var repoMethodValue = repoMethod[prop];
            switch (prop) {
                case "objectTypes":
                    isMatch = (filterValue || []).every(function (filterValueEl) {
                        return (repoMethodValue || []).includes(filterValueEl);
                    });
                    break;
                case "flags":
                    isMatch = isSubset(repoMethodValue || {}, filterValue || {});
                    break;
                default:
                    isMatch = String(filterValue).toLowerCase() === String(repoMethodValue).toLowerCase();
            }
            return isMatch;
        });
    };
    Client.prototype.getMethods = function (methodFilter) {
        var _this = this;
        if (methodFilter === undefined) {
            return this.repo.getMethods();
        }
        var methods = this.repo.getMethods().filter(function (method) {
            return _this.methodMatch(methodFilter, method);
        });
        return methods;
    };
    Client.prototype.getMethodsForInstance = function (instanceFilter) {
        var _this = this;
        var allServers = this.repo.getServers();
        var matchingServers = allServers.filter(function (server) {
            return _this.instanceMatch(instanceFilter, server.instance);
        });
        if (matchingServers.length === 0) {
            return [];
        }
        var resultMethodsObject = {};
        if (matchingServers.length === 1) {
            resultMethodsObject = matchingServers[0].methods;
        }
        else {
            matchingServers.forEach(function (server) {
                Object.keys(server.methods).forEach(function (methodKey) {
                    var method = server.methods[methodKey];
                    resultMethodsObject[method.identifier] = method;
                });
            });
        }
        return Object.keys(resultMethodsObject)
            .map(function (key) {
            return resultMethodsObject[key];
        });
    };
    Client.prototype.getServers = function (methodFilter) {
        var _this = this;
        var servers = this.repo.getServers();
        if (methodFilter === undefined) {
            return servers.map(function (server) {
                return { server: server, methods: [] };
            });
        }
        return servers.reduce(function (prev, current) {
            var methodsForServer = Object.values(current.methods);
            var matchingMethods = methodsForServer.filter(function (method) {
                return _this.methodMatch(methodFilter, method);
            });
            if (matchingMethods.length > 0) {
                prev.push({ server: current, methods: matchingMethods });
            }
            return prev;
        }, []);
    };
    Client.prototype.getServerMethodsByFilterAndTarget = function (methodFilter, target) {
        var serversMethodMap = this.getServers(methodFilter);
        return this.filterByTarget(target, serversMethodMap);
    };
    return Client;
}());

var ServerSubscription = (function () {
    function ServerSubscription(protocol, repoMethod, subscription) {
        this.protocol = protocol;
        this.repoMethod = repoMethod;
        this.subscription = subscription;
    }
    Object.defineProperty(ServerSubscription.prototype, "stream", {
        get: function () {
            if (!this.repoMethod.stream) {
                throw new Error("no stream");
            }
            return this.repoMethod.stream;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerSubscription.prototype, "arguments", {
        get: function () { return this.subscription.arguments || {}; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerSubscription.prototype, "branchKey", {
        get: function () { return this.subscription.branchKey; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerSubscription.prototype, "instance", {
        get: function () {
            if (!this.subscription.instance) {
                throw new Error("no instance");
            }
            return this.subscription.instance;
        },
        enumerable: false,
        configurable: true
    });
    ServerSubscription.prototype.close = function () {
        this.protocol.server.closeSingleSubscription(this.repoMethod, this.subscription);
    };
    ServerSubscription.prototype.push = function (data) {
        this.protocol.server.pushDataToSingle(this.repoMethod, this.subscription, data);
    };
    return ServerSubscription;
}());

var Request = (function () {
    function Request(protocol, repoMethod, requestContext) {
        this.protocol = protocol;
        this.repoMethod = repoMethod;
        this.requestContext = requestContext;
        this.arguments = requestContext.arguments;
        this.instance = requestContext.instance;
    }
    Request.prototype.accept = function () {
        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, "");
    };
    Request.prototype.acceptOnBranch = function (branch) {
        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, branch);
    };
    Request.prototype.reject = function (reason) {
        this.protocol.server.rejectRequest(this.requestContext, this.repoMethod, reason);
    };
    return Request;
}());

var ServerStreaming$1 = (function () {
    function ServerStreaming(protocol, server) {
        var _this = this;
        this.protocol = protocol;
        this.server = server;
        protocol.server.onSubRequest(function (rc, rm) { return _this.handleSubRequest(rc, rm); });
        protocol.server.onSubAdded(function (sub, rm) { return _this.handleSubAdded(sub, rm); });
        protocol.server.onSubRemoved(function (sub, rm) { return _this.handleSubRemoved(sub, rm); });
    }
    ServerStreaming.prototype.handleSubRequest = function (requestContext, repoMethod) {
        if (!(repoMethod &&
            repoMethod.streamCallbacks &&
            typeof repoMethod.streamCallbacks.subscriptionRequestHandler === "function")) {
            return;
        }
        var request = new Request(this.protocol, repoMethod, requestContext);
        repoMethod.streamCallbacks.subscriptionRequestHandler(request);
    };
    ServerStreaming.prototype.handleSubAdded = function (subscription, repoMethod) {
        if (!(repoMethod &&
            repoMethod.streamCallbacks &&
            typeof repoMethod.streamCallbacks.subscriptionAddedHandler === "function")) {
            return;
        }
        var sub = new ServerSubscription(this.protocol, repoMethod, subscription);
        repoMethod.streamCallbacks.subscriptionAddedHandler(sub);
    };
    ServerStreaming.prototype.handleSubRemoved = function (subscription, repoMethod) {
        if (!(repoMethod &&
            repoMethod.streamCallbacks &&
            typeof repoMethod.streamCallbacks.subscriptionRemovedHandler === "function")) {
            return;
        }
        var sub = new ServerSubscription(this.protocol, repoMethod, subscription);
        repoMethod.streamCallbacks.subscriptionRemovedHandler(sub);
    };
    return ServerStreaming;
}());

var ServerBranch = (function () {
    function ServerBranch(key, protocol, repoMethod) {
        this.key = key;
        this.protocol = protocol;
        this.repoMethod = repoMethod;
    }
    ServerBranch.prototype.subscriptions = function () {
        var _this = this;
        var subList = this.protocol.server.getSubscriptionList(this.repoMethod, this.key);
        return subList.map(function (sub) {
            return new ServerSubscription(_this.protocol, _this.repoMethod, sub);
        });
    };
    ServerBranch.prototype.close = function () {
        this.protocol.server.closeAllSubscriptions(this.repoMethod, this.key);
    };
    ServerBranch.prototype.push = function (data) {
        this.protocol.server.pushData(this.repoMethod, data, [this.key]);
    };
    return ServerBranch;
}());

var ServerStream = (function () {
    function ServerStream(_protocol, _repoMethod, _server) {
        this._protocol = _protocol;
        this._repoMethod = _repoMethod;
        this._server = _server;
        this.name = this._repoMethod.definition.name;
    }
    ServerStream.prototype.branches = function (key) {
        var _this = this;
        var bList = this._protocol.server.getBranchList(this._repoMethod);
        if (key) {
            if (bList.indexOf(key) > -1) {
                return new ServerBranch(key, this._protocol, this._repoMethod);
            }
            return undefined;
        }
        else {
            return bList.map(function (branchKey) {
                return new ServerBranch(branchKey, _this._protocol, _this._repoMethod);
            });
        }
    };
    ServerStream.prototype.branch = function (key) {
        return this.branches(key);
    };
    ServerStream.prototype.subscriptions = function () {
        var _this = this;
        var subList = this._protocol.server.getSubscriptionList(this._repoMethod);
        return subList.map(function (sub) {
            return new ServerSubscription(_this._protocol, _this._repoMethod, sub);
        });
    };
    Object.defineProperty(ServerStream.prototype, "definition", {
        get: function () {
            var _a;
            var def2 = this._repoMethod.definition;
            return {
                accepts: def2.accepts,
                description: def2.description,
                displayName: def2.displayName,
                name: def2.name,
                objectTypes: def2.objectTypes,
                returns: def2.returns,
                supportsStreaming: def2.supportsStreaming,
                flags: (_a = def2.flags) === null || _a === void 0 ? void 0 : _a.metadata,
            };
        },
        enumerable: false,
        configurable: true
    });
    ServerStream.prototype.close = function () {
        this._protocol.server.closeAllSubscriptions(this._repoMethod);
        this._server.unregister(this._repoMethod.definition, true);
    };
    ServerStream.prototype.push = function (data, branches) {
        if (typeof branches !== "string" && !Array.isArray(branches) && branches !== undefined) {
            throw new Error("invalid branches should be string or string array");
        }
        if (typeof data !== "object") {
            throw new Error("Invalid arguments. Data must be an object.");
        }
        this._protocol.server.pushData(this._repoMethod, data, branches);
    };
    ServerStream.prototype.updateRepoMethod = function (repoMethod) {
        this._repoMethod = repoMethod;
    };
    return ServerStream;
}());

var Server = (function () {
    function Server(protocol, serverRepository) {
        this.protocol = protocol;
        this.serverRepository = serverRepository;
        this.invocations = 0;
        this.currentlyUnregistering = {};
        this.streaming = new ServerStreaming$1(protocol, this);
        this.protocol.server.onInvoked(this.onMethodInvoked.bind(this));
    }
    Server.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback, existingStream) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            if (!streamDef) {
                reject("The stream name must be unique! Please, provide either a unique string for a stream name to “glue.interop.createStream()” or a “methodDefinition” object with a unique “name” property for the stream.");
                return;
            }
            var streamMethodDefinition;
            if (typeof streamDef === "string") {
                streamMethodDefinition = { name: "" + streamDef };
            }
            else {
                streamMethodDefinition = __assign({}, streamDef);
            }
            if (!streamMethodDefinition.name) {
                return reject("The \u201Cname\u201D property is required for the \u201CstreamDefinition\u201D object and must be unique. Stream definition: ".concat(JSON.stringify(streamMethodDefinition)));
            }
            var nameAlreadyExists = _this.serverRepository.getList()
                .some(function (serverMethod) { return serverMethod.definition.name === streamMethodDefinition.name; });
            if (nameAlreadyExists) {
                return reject("A stream with the name \"".concat(streamMethodDefinition.name, "\" already exists! Please, provide a unique name for the stream."));
            }
            streamMethodDefinition.supportsStreaming = true;
            if (!callbacks) {
                callbacks = {};
            }
            if (typeof callbacks.subscriptionRequestHandler !== "function") {
                callbacks.subscriptionRequestHandler = function (request) {
                    request.accept();
                };
            }
            var repoMethod = _this.serverRepository.add({
                definition: streamMethodDefinition,
                streamCallbacks: callbacks,
                protocolState: {},
            });
            _this.protocol.server.createStream(repoMethod)
                .then(function () {
                var streamUserObject;
                if (existingStream) {
                    streamUserObject = existingStream;
                    existingStream.updateRepoMethod(repoMethod);
                }
                else {
                    streamUserObject = new ServerStream(_this.protocol, repoMethod, _this);
                }
                repoMethod.stream = streamUserObject;
                resolve(streamUserObject);
            })
                .catch(function (err) {
                if (repoMethod.repoId) {
                    _this.serverRepository.remove(repoMethod.repoId);
                }
                reject(err);
            });
        });
        return promisify(promise, successCallback, errorCallback);
    };
    Server.prototype.register = function (methodDefinition, callback) {
        var _this = this;
        if (!methodDefinition) {
            return Promise.reject("Method definition is required. Please, provide either a unique string for a method name or a “methodDefinition” object with a required “name” property.");
        }
        if (typeof callback !== "function") {
            return Promise.reject("The second parameter must be a callback function. Method: ".concat(typeof methodDefinition === "string" ? methodDefinition : methodDefinition.name));
        }
        var wrappedCallbackFunction = function (context, resultCallback) { return __awaiter(_this, void 0, void 0, function () {
            var result, resultValue, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 4, , 5]);
                        result = callback(context.args, context.instance);
                        if (!(result && typeof result.then === "function")) return [3, 2];
                        return [4, result];
                    case 1:
                        resultValue = _a.sent();
                        resultCallback(undefined, resultValue);
                        return [3, 3];
                    case 2:
                        resultCallback(undefined, result);
                        _a.label = 3;
                    case 3: return [3, 5];
                    case 4:
                        e_1 = _a.sent();
                        resultCallback(e_1 !== null && e_1 !== void 0 ? e_1 : "", e_1 !== null && e_1 !== void 0 ? e_1 : "");
                        return [3, 5];
                    case 5: return [2];
                }
            });
        }); };
        wrappedCallbackFunction.userCallback = callback;
        return this.registerCore(methodDefinition, wrappedCallbackFunction);
    };
    Server.prototype.registerAsync = function (methodDefinition, callback) {
        if (!methodDefinition) {
            return Promise.reject("Method definition is required. Please, provide either a unique string for a method name or a “methodDefinition” object with a required “name” property.");
        }
        if (typeof callback !== "function") {
            return Promise.reject("The second parameter must be a callback function. Method: ".concat(typeof methodDefinition === "string" ? methodDefinition : methodDefinition.name));
        }
        var wrappedCallback = function (context, resultCallback) {
            try {
                var resultCalled_1 = false;
                var success = function (result) {
                    if (!resultCalled_1) {
                        resultCallback(undefined, result);
                    }
                    resultCalled_1 = true;
                };
                var error = function (e) {
                    if (!resultCalled_1) {
                        if (!e) {
                            e = "";
                        }
                        resultCallback(e, e);
                    }
                    resultCalled_1 = true;
                };
                var methodResult = callback(context.args, context.instance, success, error);
                if (methodResult && typeof methodResult.then === "function") {
                    methodResult
                        .then(success)
                        .catch(error);
                }
            }
            catch (e) {
                resultCallback(e, undefined);
            }
        };
        wrappedCallback.userCallbackAsync = callback;
        return this.registerCore(methodDefinition, wrappedCallback);
    };
    Server.prototype.unregister = function (methodFilter, forStream) {
        if (forStream === void 0) { forStream = false; }
        return __awaiter(this, void 0, void 0, function () {
            var methodDefinition, methodToBeRemoved;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (methodFilter === undefined) {
                            return [2, Promise.reject("Please, provide either a unique string for a name or an object containing a “name” property.")];
                        }
                        if (!(typeof methodFilter === "function")) return [3, 2];
                        return [4, this.unregisterWithPredicate(methodFilter, forStream)];
                    case 1:
                        _a.sent();
                        return [2];
                    case 2:
                        if (typeof methodFilter === "string") {
                            methodDefinition = { name: methodFilter };
                        }
                        else {
                            methodDefinition = methodFilter;
                        }
                        if (methodDefinition.name === undefined) {
                            return [2, Promise.reject("Method name is required. Cannot find a method if the method name is undefined!")];
                        }
                        methodToBeRemoved = this.serverRepository.getList().find(function (serverMethod) {
                            return serverMethod.definition.name === methodDefinition.name
                                && (serverMethod.definition.supportsStreaming || false) === forStream;
                        });
                        if (!methodToBeRemoved) {
                            return [2, Promise.reject("Method with a name \"".concat(methodDefinition.name, "\" does not exist or is not registered by your application!"))];
                        }
                        return [4, this.removeMethodsOrStreams([methodToBeRemoved])];
                    case 3:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    Server.prototype.unregisterWithPredicate = function (filterPredicate, forStream) {
        return __awaiter(this, void 0, void 0, function () {
            var methodsOrStreamsToRemove;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodsOrStreamsToRemove = this.serverRepository.getList()
                            .filter(function (sm) { return filterPredicate(sm.definition); })
                            .filter(function (serverMethod) {
                            return (serverMethod.definition.supportsStreaming || false) === forStream;
                        });
                        if (!methodsOrStreamsToRemove || methodsOrStreamsToRemove.length === 0) {
                            return [2, Promise.reject("Could not find a ".concat(forStream ? "stream" : "method", " matching the specified condition!"))];
                        }
                        return [4, this.removeMethodsOrStreams(methodsOrStreamsToRemove)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    Server.prototype.removeMethodsOrStreams = function (methodsToRemove) {
        var _this = this;
        var methodUnregPromises = [];
        methodsToRemove.forEach(function (method) {
            var promise = _this.protocol.server.unregister(method)
                .then(function () {
                if (method.repoId) {
                    _this.serverRepository.remove(method.repoId);
                }
            });
            methodUnregPromises.push(promise);
            _this.addAsCurrentlyUnregistering(method.definition.name, promise);
        });
        return Promise.all(methodUnregPromises);
    };
    Server.prototype.addAsCurrentlyUnregistering = function (methodName, promise) {
        return __awaiter(this, void 0, void 0, function () {
            var timeout;
            var _this = this;
            return __generator(this, function (_a) {
                timeout = new Promise(function (resolve) { return setTimeout(resolve, 5000); });
                this.currentlyUnregistering[methodName] = Promise.race([promise, timeout]).then(function () {
                    delete _this.currentlyUnregistering[methodName];
                });
                return [2];
            });
        });
    };
    Server.prototype.registerCore = function (method, theFunction) {
        return __awaiter(this, void 0, void 0, function () {
            var methodDefinition, unregisterInProgress, nameAlreadyExists, repoMethod;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof method === "string") {
                            methodDefinition = { name: "" + method };
                        }
                        else {
                            methodDefinition = __assign({}, method);
                        }
                        if (!methodDefinition.name) {
                            return [2, Promise.reject("Please, provide a (unique) string value for the \u201Cname\u201D property in the \u201CmethodDefinition\u201D object: ".concat(JSON.stringify(method)))];
                        }
                        unregisterInProgress = this.currentlyUnregistering[methodDefinition.name];
                        if (!unregisterInProgress) return [3, 2];
                        return [4, unregisterInProgress];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        nameAlreadyExists = this.serverRepository.getList()
                            .some(function (serverMethod) { return serverMethod.definition.name === methodDefinition.name; });
                        if (nameAlreadyExists) {
                            return [2, Promise.reject("A method with the name \"".concat(methodDefinition.name, "\" already exists! Please, provide a unique name for the method."))];
                        }
                        if (methodDefinition.supportsStreaming) {
                            return [2, Promise.reject("When you create methods with \u201Cglue.interop.register()\u201D or \u201Cglue.interop.registerAsync()\u201D the property \u201CsupportsStreaming\u201D cannot be \u201Ctrue\u201D. If you want \u201C".concat(methodDefinition.name, "\u201D to be a stream, please use the \u201Cglue.interop.createStream()\u201D method."))];
                        }
                        repoMethod = this.serverRepository.add({
                            definition: methodDefinition,
                            theFunction: theFunction,
                            protocolState: {},
                        });
                        return [2, this.protocol.server.register(repoMethod)
                                .catch(function (err) {
                                if (repoMethod === null || repoMethod === void 0 ? void 0 : repoMethod.repoId) {
                                    _this.serverRepository.remove(repoMethod.repoId);
                                }
                                throw err;
                            })];
                }
            });
        });
    };
    Server.prototype.onMethodInvoked = function (methodToExecute, invocationId, invocationArgs) {
        var _this = this;
        if (!methodToExecute || !methodToExecute.theFunction) {
            return;
        }
        methodToExecute.theFunction(invocationArgs, function (err, result) {
            if (err !== undefined && err !== null) {
                if (err.message && typeof err.message === "string") {
                    err = err.message;
                }
                else if (typeof err !== "string") {
                    try {
                        err = JSON.stringify(err);
                    }
                    catch (unStrException) {
                        err = "un-stringifyable error in onMethodInvoked! Top level prop names: ".concat(Object.keys(err));
                    }
                }
            }
            if (!result) {
                result = {};
            }
            else if (typeof result !== "object" || Array.isArray(result)) {
                result = { _value: result };
            }
            _this.protocol.server.methodInvocationResult(methodToExecute, invocationId, err, result);
        });
    };
    return Server;
}());

var InstanceWrapper = (function () {
    function InstanceWrapper(API, instance, connection) {
        var _this = this;
        this.wrapped = {};
        this.wrapped.getMethods = function () {
            return API.methodsForInstance(this);
        };
        this.wrapped.getStreams = function () {
            return API.methodsForInstance(this).filter(function (m) { return m.supportsStreaming; });
        };
        if (instance) {
            this.refreshWrappedObject(instance);
        }
        if (connection) {
            connection.loggedIn(function () {
                _this.refresh(connection);
            });
            this.refresh(connection);
        }
    }
    InstanceWrapper.prototype.unwrap = function () {
        return this.wrapped;
    };
    InstanceWrapper.prototype.refresh = function (connection) {
        if (!connection) {
            return;
        }
        var resolvedIdentity = connection === null || connection === void 0 ? void 0 : connection.resolvedIdentity;
        var instance = Object.assign({}, resolvedIdentity !== null && resolvedIdentity !== void 0 ? resolvedIdentity : {}, { peerId: connection === null || connection === void 0 ? void 0 : connection.peerId });
        this.refreshWrappedObject(instance);
    };
    InstanceWrapper.prototype.refreshWrappedObject = function (resolvedIdentity) {
        var _this = this;
        var _a, _b, _c, _d;
        Object.keys(resolvedIdentity).forEach(function (key) {
            _this.wrapped[key] = resolvedIdentity[key];
        });
        this.wrapped.user = resolvedIdentity.user;
        this.wrapped.instance = resolvedIdentity.instance;
        this.wrapped.application = (_a = resolvedIdentity.application) !== null && _a !== void 0 ? _a : shortid();
        this.wrapped.applicationName = resolvedIdentity.applicationName;
        this.wrapped.pid = (_c = (_b = resolvedIdentity.pid) !== null && _b !== void 0 ? _b : resolvedIdentity.process) !== null && _c !== void 0 ? _c : Math.floor(Math.random() * 10000000000);
        this.wrapped.machine = resolvedIdentity.machine;
        this.wrapped.environment = resolvedIdentity.environment;
        this.wrapped.region = resolvedIdentity.region;
        this.wrapped.windowId = resolvedIdentity.windowId;
        this.wrapped.isLocal = (_d = resolvedIdentity.isLocal) !== null && _d !== void 0 ? _d : true;
        this.wrapped.api = resolvedIdentity.api;
        this.wrapped.service = resolvedIdentity.service;
        this.wrapped.peerId = resolvedIdentity.peerId;
    };
    return InstanceWrapper;
}());

var hideMethodSystemFlags = function (method) {
    return __assign(__assign({}, method), { flags: method.flags.metadata || {} });
};
var ClientRepository = (function () {
    function ClientRepository(logger, API) {
        this.logger = logger;
        this.API = API;
        this.servers = {};
        this.methodsCount = {};
        this.callbacks = lib$1();
        var peerId = this.API.instance.peerId;
        this.myServer = {
            id: peerId,
            methods: {},
            instance: this.API.instance,
            wrapper: this.API.unwrappedInstance,
        };
        this.servers[peerId] = this.myServer;
    }
    ClientRepository.prototype.addServer = function (info, serverId) {
        this.logger.debug("adding server ".concat(serverId));
        var current = this.servers[serverId];
        if (current) {
            return current.id;
        }
        var wrapper = new InstanceWrapper(this.API, info);
        var serverEntry = {
            id: serverId,
            methods: {},
            instance: wrapper.unwrap(),
            wrapper: wrapper,
        };
        this.servers[serverId] = serverEntry;
        this.callbacks.execute("onServerAdded", serverEntry.instance);
        return serverId;
    };
    ClientRepository.prototype.removeServerById = function (id, reason) {
        var _this = this;
        var server = this.servers[id];
        if (!server) {
            this.logger.warn("not aware of server ".concat(id, ", my state ").concat(JSON.stringify(Object.keys(this.servers))));
            return;
        }
        else {
            this.logger.debug("removing server ".concat(id));
        }
        Object.keys(server.methods).forEach(function (methodId) {
            _this.removeServerMethod(id, methodId);
        });
        delete this.servers[id];
        this.callbacks.execute("onServerRemoved", server.instance, reason);
    };
    ClientRepository.prototype.addServerMethod = function (serverId, method) {
        var _a;
        var server = this.servers[serverId];
        if (!server) {
            throw new Error("server does not exists");
        }
        if (server.methods[method.id]) {
            return;
        }
        var identifier = this.createMethodIdentifier(method);
        var that = this;
        var methodDefinition = {
            identifier: identifier,
            gatewayId: method.id,
            name: method.name,
            displayName: method.display_name,
            description: method.description,
            version: method.version,
            objectTypes: method.object_types || [],
            accepts: method.input_signature,
            returns: method.result_signature,
            supportsStreaming: typeof method.flags !== "undefined" ? method.flags.streaming : false,
            flags: (_a = method.flags) !== null && _a !== void 0 ? _a : {},
            getServers: function () {
                return that.getServersByMethod(identifier);
            }
        };
        methodDefinition.object_types = methodDefinition.objectTypes;
        methodDefinition.display_name = methodDefinition.displayName;
        methodDefinition.version = methodDefinition.version;
        server.methods[method.id] = methodDefinition;
        var clientMethodDefinition = hideMethodSystemFlags(methodDefinition);
        if (!this.methodsCount[identifier]) {
            this.methodsCount[identifier] = 0;
            this.callbacks.execute("onMethodAdded", clientMethodDefinition);
        }
        this.methodsCount[identifier] = this.methodsCount[identifier] + 1;
        this.callbacks.execute("onServerMethodAdded", server.instance, clientMethodDefinition);
        return methodDefinition;
    };
    ClientRepository.prototype.removeServerMethod = function (serverId, methodId) {
        var server = this.servers[serverId];
        if (!server) {
            throw new Error("server does not exists");
        }
        var method = server.methods[methodId];
        delete server.methods[methodId];
        var clientMethodDefinition = hideMethodSystemFlags(method);
        this.methodsCount[method.identifier] = this.methodsCount[method.identifier] - 1;
        if (this.methodsCount[method.identifier] === 0) {
            this.callbacks.execute("onMethodRemoved", clientMethodDefinition);
        }
        this.callbacks.execute("onServerMethodRemoved", server.instance, clientMethodDefinition);
    };
    ClientRepository.prototype.getMethods = function () {
        return this.extractMethodsFromServers(Object.values(this.servers)).map(hideMethodSystemFlags);
    };
    ClientRepository.prototype.getServers = function () {
        return Object.values(this.servers).map(this.hideServerMethodSystemFlags);
    };
    ClientRepository.prototype.onServerAdded = function (callback) {
        var unsubscribeFunc = this.callbacks.add("onServerAdded", callback);
        var serversWithMethodsToReplay = this.getServers().map(function (s) { return s.instance; });
        return this.returnUnsubWithDelayedReplay(unsubscribeFunc, serversWithMethodsToReplay, callback);
    };
    ClientRepository.prototype.onMethodAdded = function (callback) {
        var unsubscribeFunc = this.callbacks.add("onMethodAdded", callback);
        var methodsToReplay = this.getMethods();
        return this.returnUnsubWithDelayedReplay(unsubscribeFunc, methodsToReplay, callback);
    };
    ClientRepository.prototype.onServerMethodAdded = function (callback) {
        var unsubscribeFunc = this.callbacks.add("onServerMethodAdded", callback);
        var unsubCalled = false;
        var servers = this.getServers();
        setTimeout(function () {
            servers.forEach(function (server) {
                var methods = server.methods;
                Object.keys(methods).forEach(function (methodId) {
                    if (!unsubCalled) {
                        callback(server.instance, methods[methodId]);
                    }
                });
            });
        }, 0);
        return function () {
            unsubCalled = true;
            unsubscribeFunc();
        };
    };
    ClientRepository.prototype.onMethodRemoved = function (callback) {
        var unsubscribeFunc = this.callbacks.add("onMethodRemoved", callback);
        return unsubscribeFunc;
    };
    ClientRepository.prototype.onServerRemoved = function (callback) {
        var unsubscribeFunc = this.callbacks.add("onServerRemoved", callback);
        return unsubscribeFunc;
    };
    ClientRepository.prototype.onServerMethodRemoved = function (callback) {
        var unsubscribeFunc = this.callbacks.add("onServerMethodRemoved", callback);
        return unsubscribeFunc;
    };
    ClientRepository.prototype.getServerById = function (id) {
        return this.hideServerMethodSystemFlags(this.servers[id]);
    };
    ClientRepository.prototype.reset = function () {
        var _a;
        var _this = this;
        Object.keys(this.servers).forEach(function (key) {
            _this.removeServerById(key, "reset");
        });
        this.servers = (_a = {},
            _a[this.myServer.id] = this.myServer,
            _a);
        this.methodsCount = {};
    };
    ClientRepository.prototype.createMethodIdentifier = function (methodInfo) {
        var _a, _b;
        var accepts = (_a = methodInfo.input_signature) !== null && _a !== void 0 ? _a : "";
        var returns = (_b = methodInfo.result_signature) !== null && _b !== void 0 ? _b : "";
        return (methodInfo.name + accepts + returns).toLowerCase();
    };
    ClientRepository.prototype.getServersByMethod = function (identifier) {
        var allServers = [];
        Object.values(this.servers).forEach(function (server) {
            Object.values(server.methods).forEach(function (method) {
                if (method.identifier === identifier) {
                    allServers.push(server.instance);
                }
            });
        });
        return allServers;
    };
    ClientRepository.prototype.returnUnsubWithDelayedReplay = function (unsubscribeFunc, collectionToReplay, callback) {
        var unsubCalled = false;
        setTimeout(function () {
            collectionToReplay.forEach(function (item) {
                if (!unsubCalled) {
                    callback(item);
                }
            });
        }, 0);
        return function () {
            unsubCalled = true;
            unsubscribeFunc();
        };
    };
    ClientRepository.prototype.hideServerMethodSystemFlags = function (server) {
        var clientMethods = {};
        Object.entries(server.methods).forEach(function (_a) {
            var name = _a[0], method = _a[1];
            clientMethods[name] = hideMethodSystemFlags(method);
        });
        return __assign(__assign({}, server), { methods: clientMethods });
    };
    ClientRepository.prototype.extractMethodsFromServers = function (servers) {
        var methods = Object.values(servers).reduce(function (clientMethods, server) {
            return __spreadArray(__spreadArray([], clientMethods, true), Object.values(server.methods), true);
        }, []);
        return methods;
    };
    return ClientRepository;
}());

var ServerRepository = (function () {
    function ServerRepository() {
        this.nextId = 0;
        this.methods = [];
    }
    ServerRepository.prototype.add = function (method) {
        method.repoId = String(this.nextId);
        this.nextId += 1;
        this.methods.push(method);
        return method;
    };
    ServerRepository.prototype.remove = function (repoId) {
        if (typeof repoId !== "string") {
            return new TypeError("Expecting a string");
        }
        this.methods = this.methods.filter(function (m) {
            return m.repoId !== repoId;
        });
    };
    ServerRepository.prototype.getById = function (id) {
        if (typeof id !== "string") {
            return undefined;
        }
        return this.methods.find(function (m) {
            return m.repoId === id;
        });
    };
    ServerRepository.prototype.getList = function () {
        return this.methods.map(function (m) { return m; });
    };
    ServerRepository.prototype.length = function () {
        return this.methods.length;
    };
    ServerRepository.prototype.reset = function () {
        this.methods = [];
    };
    return ServerRepository;
}());

var SUBSCRIPTION_REQUEST = "onSubscriptionRequest";
var SUBSCRIPTION_ADDED = "onSubscriptionAdded";
var SUBSCRIPTION_REMOVED = "onSubscriptionRemoved";
var ServerStreaming = (function () {
    function ServerStreaming(session, repository, serverRepository) {
        var _this = this;
        this.session = session;
        this.repository = repository;
        this.serverRepository = serverRepository;
        this.ERR_URI_SUBSCRIPTION_FAILED = "com.tick42.agm.errors.subscription.failure";
        this.callbacks = lib$1();
        this.nextStreamId = 0;
        session.on("add-interest", function (msg) {
            _this.handleAddInterest(msg);
        });
        session.on("remove-interest", function (msg) {
            _this.handleRemoveInterest(msg);
        });
    }
    ServerStreaming.prototype.acceptRequestOnBranch = function (requestContext, streamingMethod, branch) {
        if (typeof branch !== "string") {
            branch = "";
        }
        if (typeof streamingMethod.protocolState.subscriptionsMap !== "object") {
            throw new TypeError("The streaming method is missing its subscriptions.");
        }
        if (!Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {
            throw new TypeError("The streaming method is missing its branches.");
        }
        var streamId = this.getStreamId(streamingMethod, branch);
        var key = requestContext.msg.subscription_id;
        var subscription = {
            id: key,
            arguments: requestContext.arguments,
            instance: requestContext.instance,
            branchKey: branch,
            streamId: streamId,
            subscribeMsg: requestContext.msg,
        };
        streamingMethod.protocolState.subscriptionsMap[key] = subscription;
        this.session.sendFireAndForget({
            type: "accepted",
            subscription_id: key,
            stream_id: streamId,
        });
        this.callbacks.execute(SUBSCRIPTION_ADDED, subscription, streamingMethod);
    };
    ServerStreaming.prototype.rejectRequest = function (requestContext, streamingMethod, reason) {
        if (typeof reason !== "string") {
            reason = "";
        }
        this.sendSubscriptionFailed("Subscription rejected by user. " + reason, requestContext.msg.subscription_id);
    };
    ServerStreaming.prototype.pushData = function (streamingMethod, data, branches) {
        var _this = this;
        if (typeof streamingMethod !== "object" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {
            return;
        }
        if (typeof data !== "object") {
            throw new Error("Invalid arguments. Data must be an object.");
        }
        if (typeof branches === "string") {
            branches = [branches];
        }
        else if (!Array.isArray(branches) || branches.length <= 0) {
            branches = [];
        }
        var streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap
            .filter(function (br) {
            if (!branches || branches.length === 0) {
                return true;
            }
            return branches.indexOf(br.key) >= 0;
        }).map(function (br) {
            return br.streamId;
        });
        streamIdList.forEach(function (streamId) {
            var publishMessage = {
                type: "publish",
                stream_id: streamId,
                data: data,
            };
            _this.session.sendFireAndForget(publishMessage);
        });
    };
    ServerStreaming.prototype.pushDataToSingle = function (method, subscription, data) {
        if (typeof data !== "object") {
            throw new Error("Invalid arguments. Data must be an object.");
        }
        var postMessage = {
            type: "post",
            subscription_id: subscription.id,
            data: data,
        };
        this.session.sendFireAndForget(postMessage);
    };
    ServerStreaming.prototype.closeSingleSubscription = function (streamingMethod, subscription) {
        if (streamingMethod.protocolState.subscriptionsMap) {
            delete streamingMethod.protocolState.subscriptionsMap[subscription.id];
        }
        var dropSubscriptionMessage = {
            type: "drop-subscription",
            subscription_id: subscription.id,
            reason: "Server dropping a single subscription",
        };
        this.session.sendFireAndForget(dropSubscriptionMessage);
        subscription.instance;
        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);
    };
    ServerStreaming.prototype.closeMultipleSubscriptions = function (streamingMethod, branchKey) {
        var _this = this;
        if (typeof streamingMethod !== "object" || typeof streamingMethod.protocolState.subscriptionsMap !== "object") {
            return;
        }
        if (!streamingMethod.protocolState.subscriptionsMap) {
            return;
        }
        var subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;
        var subscriptionsToClose = Object.keys(subscriptionsMap)
            .map(function (key) {
            return subscriptionsMap[key];
        });
        if (typeof branchKey === "string") {
            subscriptionsToClose = subscriptionsToClose.filter(function (sub) {
                return sub.branchKey === branchKey;
            });
        }
        subscriptionsToClose.forEach(function (subscription) {
            delete subscriptionsMap[subscription.id];
            var drop = {
                type: "drop-subscription",
                subscription_id: subscription.id,
                reason: "Server dropping all subscriptions on stream_id: " + subscription.streamId,
            };
            _this.session.sendFireAndForget(drop);
        });
    };
    ServerStreaming.prototype.getSubscriptionList = function (streamingMethod, branchKey) {
        if (typeof streamingMethod !== "object") {
            return [];
        }
        var subscriptions = [];
        if (!streamingMethod.protocolState.subscriptionsMap) {
            return [];
        }
        var subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;
        var allSubscriptions = Object.keys(subscriptionsMap)
            .map(function (key) {
            return subscriptionsMap[key];
        });
        if (typeof branchKey !== "string") {
            subscriptions = allSubscriptions;
        }
        else {
            subscriptions = allSubscriptions.filter(function (sub) {
                return sub.branchKey === branchKey;
            });
        }
        return subscriptions;
    };
    ServerStreaming.prototype.getBranchList = function (streamingMethod) {
        if (typeof streamingMethod !== "object") {
            return [];
        }
        if (!streamingMethod.protocolState.subscriptionsMap) {
            return [];
        }
        var subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;
        var allSubscriptions = Object.keys(subscriptionsMap)
            .map(function (key) {
            return subscriptionsMap[key];
        });
        var result = [];
        allSubscriptions.forEach(function (sub) {
            var branch = "";
            if (typeof sub === "object" && typeof sub.branchKey === "string") {
                branch = sub.branchKey;
            }
            if (result.indexOf(branch) === -1) {
                result.push(branch);
            }
        });
        return result;
    };
    ServerStreaming.prototype.onSubAdded = function (callback) {
        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_ADDED, callback);
    };
    ServerStreaming.prototype.onSubRequest = function (callback) {
        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REQUEST, callback);
    };
    ServerStreaming.prototype.onSubRemoved = function (callback) {
        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REMOVED, callback);
    };
    ServerStreaming.prototype.handleRemoveInterest = function (msg) {
        var streamingMethod = this.serverRepository.getById(msg.method_id);
        if (typeof msg.subscription_id !== "string" ||
            typeof streamingMethod !== "object") {
            return;
        }
        if (!streamingMethod.protocolState.subscriptionsMap) {
            return;
        }
        if (typeof streamingMethod.protocolState.subscriptionsMap[msg.subscription_id] !== "object") {
            return;
        }
        var subscription = streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];
        delete streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];
        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);
    };
    ServerStreaming.prototype.onSubscriptionLifetimeEvent = function (eventName, handlerFunc) {
        this.callbacks.add(eventName, handlerFunc);
    };
    ServerStreaming.prototype.getNextStreamId = function () {
        return this.nextStreamId++ + "";
    };
    ServerStreaming.prototype.handleAddInterest = function (msg) {
        var caller = this.repository.getServerById(msg.caller_id);
        var instance = caller.instance;
        var requestContext = {
            msg: msg,
            arguments: msg.arguments_kv || {},
            instance: instance,
        };
        var streamingMethod = this.serverRepository.getById(msg.method_id);
        if (streamingMethod === undefined) {
            var errorMsg = "No method with id " + msg.method_id + " on this server.";
            this.sendSubscriptionFailed(errorMsg, msg.subscription_id);
            return;
        }
        if (streamingMethod.protocolState.subscriptionsMap &&
            streamingMethod.protocolState.subscriptionsMap[msg.subscription_id]) {
            this.sendSubscriptionFailed("A subscription with id " + msg.subscription_id + " already exists.", msg.subscription_id);
            return;
        }
        this.callbacks.execute(SUBSCRIPTION_REQUEST, requestContext, streamingMethod);
    };
    ServerStreaming.prototype.sendSubscriptionFailed = function (reason, subscriptionId) {
        var errorMessage = {
            type: "error",
            reason_uri: this.ERR_URI_SUBSCRIPTION_FAILED,
            reason: reason,
            request_id: subscriptionId,
        };
        this.session.sendFireAndForget(errorMessage);
    };
    ServerStreaming.prototype.getStreamId = function (streamingMethod, branchKey) {
        if (typeof branchKey !== "string") {
            branchKey = "";
        }
        if (!streamingMethod.protocolState.branchKeyToStreamIdMap) {
            throw new Error("streaming ".concat(streamingMethod.definition.name, " method without protocol state"));
        }
        var needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter(function (branch) {
            return branch.key === branchKey;
        })[0];
        var streamId = (needleBranch ? needleBranch.streamId : undefined);
        if (typeof streamId !== "string" || streamId === "") {
            streamId = this.getNextStreamId();
            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId: streamId });
        }
        return streamId;
    };
    return ServerStreaming;
}());

var ServerProtocol = (function () {
    function ServerProtocol(session, clientRepository, serverRepository, logger) {
        var _this = this;
        this.session = session;
        this.clientRepository = clientRepository;
        this.serverRepository = serverRepository;
        this.logger = logger;
        this.callbacks = lib$1();
        this.streaming = new ServerStreaming(session, clientRepository, serverRepository);
        this.session.on("invoke", function (msg) { return _this.handleInvokeMessage(msg); });
    }
    ServerProtocol.prototype.createStream = function (repoMethod) {
        repoMethod.protocolState.subscriptionsMap = {};
        repoMethod.protocolState.branchKeyToStreamIdMap = [];
        return this.register(repoMethod, true);
    };
    ServerProtocol.prototype.register = function (repoMethod, isStreaming) {
        var _this = this;
        var _a;
        var methodDef = repoMethod.definition;
        var flags = Object.assign({}, { metadata: (_a = methodDef.flags) !== null && _a !== void 0 ? _a : {} }, { streaming: isStreaming || false });
        var registerMsg = {
            type: "register",
            methods: [{
                    id: repoMethod.repoId,
                    name: methodDef.name,
                    display_name: methodDef.displayName,
                    description: methodDef.description,
                    version: methodDef.version,
                    flags: flags,
                    object_types: methodDef.objectTypes || methodDef.object_types,
                    input_signature: methodDef.accepts,
                    result_signature: methodDef.returns,
                    restrictions: undefined,
                }],
        };
        return this.session.send(registerMsg, { methodId: repoMethod.repoId })
            .then(function () {
            _this.logger.debug("registered method " + repoMethod.definition.name + " with id " + repoMethod.repoId);
        })
            .catch(function (msg) {
            _this.logger.warn("failed to register method ".concat(repoMethod.definition.name, " with id ").concat(repoMethod.repoId, " - ").concat(JSON.stringify(msg)));
            throw msg;
        });
    };
    ServerProtocol.prototype.onInvoked = function (callback) {
        this.callbacks.add("onInvoked", callback);
    };
    ServerProtocol.prototype.methodInvocationResult = function (method, invocationId, err, result) {
        var msg;
        if (err || err === "") {
            msg = {
                type: "error",
                request_id: invocationId,
                reason_uri: "agm.errors.client_error",
                reason: err,
                context: result,
                peer_id: undefined,
            };
        }
        else {
            msg = {
                type: "yield",
                invocation_id: invocationId,
                peer_id: this.session.peerId,
                result: result,
                request_id: undefined,
            };
        }
        this.session.sendFireAndForget(msg);
    };
    ServerProtocol.prototype.unregister = function (method) {
        return __awaiter(this, void 0, void 0, function () {
            var msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        msg = {
                            type: "unregister",
                            methods: [method.repoId],
                        };
                        return [4, this.session.send(msg)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    ServerProtocol.prototype.getBranchList = function (method) {
        return this.streaming.getBranchList(method);
    };
    ServerProtocol.prototype.getSubscriptionList = function (method, branchKey) {
        return this.streaming.getSubscriptionList(method, branchKey);
    };
    ServerProtocol.prototype.closeAllSubscriptions = function (method, branchKey) {
        this.streaming.closeMultipleSubscriptions(method, branchKey);
    };
    ServerProtocol.prototype.pushData = function (method, data, branches) {
        this.streaming.pushData(method, data, branches);
    };
    ServerProtocol.prototype.pushDataToSingle = function (method, subscription, data) {
        this.streaming.pushDataToSingle(method, subscription, data);
    };
    ServerProtocol.prototype.closeSingleSubscription = function (method, subscription) {
        this.streaming.closeSingleSubscription(method, subscription);
    };
    ServerProtocol.prototype.acceptRequestOnBranch = function (requestContext, method, branch) {
        this.streaming.acceptRequestOnBranch(requestContext, method, branch);
    };
    ServerProtocol.prototype.rejectRequest = function (requestContext, method, reason) {
        this.streaming.rejectRequest(requestContext, method, reason);
    };
    ServerProtocol.prototype.onSubRequest = function (callback) {
        this.streaming.onSubRequest(callback);
    };
    ServerProtocol.prototype.onSubAdded = function (callback) {
        this.streaming.onSubAdded(callback);
    };
    ServerProtocol.prototype.onSubRemoved = function (callback) {
        this.streaming.onSubRemoved(callback);
    };
    ServerProtocol.prototype.handleInvokeMessage = function (msg) {
        var invocationId = msg.invocation_id;
        var callerId = msg.caller_id;
        var methodId = msg.method_id;
        var args = msg.arguments_kv;
        var methodList = this.serverRepository.getList();
        var method = methodList.filter(function (m) {
            return m.repoId === methodId;
        })[0];
        if (method === undefined) {
            return;
        }
        var client = this.clientRepository.getServerById(callerId).instance;
        var invocationArgs = { args: args, instance: client };
        this.callbacks.execute("onInvoked", method, invocationId, invocationArgs);
    };
    return ServerProtocol;
}());

var UserSubscription = (function () {
    function UserSubscription(repository, subscriptionData) {
        this.repository = repository;
        this.subscriptionData = subscriptionData;
    }
    Object.defineProperty(UserSubscription.prototype, "requestArguments", {
        get: function () {
            return this.subscriptionData.params.arguments || {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserSubscription.prototype, "servers", {
        get: function () {
            var _this = this;
            return this.subscriptionData.trackedServers
                .filter(function (pair) { return pair.subscriptionId; })
                .map(function (pair) { return _this.repository.getServerById(pair.serverId).instance; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserSubscription.prototype, "serverInstance", {
        get: function () {
            return this.servers[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UserSubscription.prototype, "stream", {
        get: function () {
            return this.subscriptionData.method;
        },
        enumerable: false,
        configurable: true
    });
    UserSubscription.prototype.onData = function (dataCallback) {
        if (typeof dataCallback !== "function") {
            throw new TypeError("The data callback must be a function.");
        }
        this.subscriptionData.handlers.onData.push(dataCallback);
        if (this.subscriptionData.handlers.onData.length === 1 && this.subscriptionData.queued.data.length > 0) {
            this.subscriptionData.queued.data.forEach(function (dataItem) {
                dataCallback(dataItem);
            });
        }
    };
    UserSubscription.prototype.onClosed = function (closedCallback) {
        if (typeof closedCallback !== "function") {
            throw new TypeError("The callback must be a function.");
        }
        this.subscriptionData.handlers.onClosed.push(closedCallback);
    };
    UserSubscription.prototype.onFailed = function (callback) {
    };
    UserSubscription.prototype.onConnected = function (callback) {
        if (typeof callback !== "function") {
            throw new TypeError("The callback must be a function.");
        }
        this.subscriptionData.handlers.onConnected.push(callback);
    };
    UserSubscription.prototype.close = function () {
        this.subscriptionData.close();
    };
    UserSubscription.prototype.setNewSubscription = function (newSub) {
        this.subscriptionData = newSub;
    };
    return UserSubscription;
}());

var TimedCache = (function () {
    function TimedCache(config) {
        this.config = config;
        this.cache = [];
        this.timeoutIds = [];
    }
    TimedCache.prototype.add = function (element) {
        var _this = this;
        var id = shortid();
        this.cache.push({ id: id, element: element });
        var timeoutId = setTimeout(function () {
            var elementIdx = _this.cache.findIndex(function (entry) { return entry.id === id; });
            if (elementIdx < 0) {
                return;
            }
            _this.cache.splice(elementIdx, 1);
        }, this.config.ELEMENT_TTL_MS);
        this.timeoutIds.push(timeoutId);
    };
    TimedCache.prototype.flush = function () {
        var elements = this.cache.map(function (entry) { return entry.element; });
        this.timeoutIds.forEach(function (id) { return clearInterval(id); });
        this.cache = [];
        this.timeoutIds = [];
        return elements;
    };
    return TimedCache;
}());

var STATUS_AWAITING_ACCEPT = "awaitingAccept";
var STATUS_SUBSCRIBED = "subscribed";
var ERR_MSG_SUB_FAILED = "Subscription failed.";
var ERR_MSG_SUB_REJECTED = "Subscription rejected.";
var ON_CLOSE_MSG_SERVER_INIT = "ServerInitiated";
var ON_CLOSE_MSG_CLIENT_INIT = "ClientInitiated";
var ClientStreaming = (function () {
    function ClientStreaming(session, repository, logger) {
        var _this = this;
        this.session = session;
        this.repository = repository;
        this.logger = logger;
        this.subscriptionsList = {};
        this.timedCache = new TimedCache({ ELEMENT_TTL_MS: 10000 });
        this.subscriptionIdToLocalKeyMap = {};
        this.nextSubLocalKey = 0;
        this.handleErrorSubscribing = function (errorResponse) {
            var tag = errorResponse._tag;
            var subLocalKey = tag.subLocalKey;
            var pendingSub = _this.subscriptionsList[subLocalKey];
            if (typeof pendingSub !== "object") {
                return;
            }
            pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {
                return server.serverId !== tag.serverId;
            });
            if (pendingSub.trackedServers.length <= 0) {
                clearTimeout(pendingSub.timeoutId);
                if (pendingSub.status === STATUS_AWAITING_ACCEPT) {
                    var reason = (typeof errorResponse.reason === "string" && errorResponse.reason !== "") ?
                        ' Publisher said "' + errorResponse.reason + '".' :
                        " No reason given.";
                    var callArgs = typeof pendingSub.params.arguments === "object" ?
                        JSON.stringify(pendingSub.params.arguments) :
                        "{}";
                    pendingSub.error({
                        message: ERR_MSG_SUB_REJECTED + reason + " Called with:" + callArgs,
                        called_with: pendingSub.params.arguments,
                        method: pendingSub.method,
                    });
                }
                else if (pendingSub.status === STATUS_SUBSCRIBED) {
                    _this.callOnClosedHandlers(pendingSub);
                }
                delete _this.subscriptionsList[subLocalKey];
            }
        };
        this.handleSubscribed = function (msg) {
            var subLocalKey = msg._tag.subLocalKey;
            var pendingSub = _this.subscriptionsList[subLocalKey];
            if (typeof pendingSub !== "object") {
                return;
            }
            var serverId = msg._tag.serverId;
            var acceptingServer = pendingSub.trackedServers
                .filter(function (server) {
                return server.serverId === serverId;
            })[0];
            if (typeof acceptingServer !== "object") {
                return;
            }
            acceptingServer.subscriptionId = msg.subscription_id;
            _this.subscriptionIdToLocalKeyMap[msg.subscription_id] = subLocalKey;
            var isFirstResponse = (pendingSub.status === STATUS_AWAITING_ACCEPT);
            pendingSub.status = STATUS_SUBSCRIBED;
            if (isFirstResponse) {
                var reconnect = false;
                var sub = pendingSub.subscription;
                if (sub) {
                    sub.setNewSubscription(pendingSub);
                    pendingSub.success(sub);
                    reconnect = true;
                }
                else {
                    sub = new UserSubscription(_this.repository, pendingSub);
                    pendingSub.subscription = sub;
                    pendingSub.success(sub);
                }
                for (var _i = 0, _a = pendingSub.handlers.onConnected; _i < _a.length; _i++) {
                    var handler = _a[_i];
                    try {
                        handler(sub.serverInstance, reconnect);
                    }
                    catch (e) {
                    }
                }
            }
        };
        this.handleEventData = function (msg) {
            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];
            if (typeof subLocalKey === "undefined") {
                return;
            }
            var subscription = _this.subscriptionsList[subLocalKey];
            if (typeof subscription !== "object") {
                return;
            }
            var trackedServersFound = subscription.trackedServers.filter(function (server) {
                return server.subscriptionId === msg.subscription_id;
            });
            if (trackedServersFound.length !== 1) {
                return;
            }
            var isPrivateData = msg.oob;
            var sendingServerId = trackedServersFound[0].serverId;
            var receivedStreamData = function () {
                return {
                    data: msg.data,
                    server: _this.repository.getServerById(sendingServerId).instance,
                    requestArguments: subscription.params.arguments,
                    message: undefined,
                    private: isPrivateData,
                };
            };
            var onDataHandlers = subscription.handlers.onData;
            var queuedData = subscription.queued.data;
            if (onDataHandlers.length > 0) {
                onDataHandlers.forEach(function (callback) {
                    if (typeof callback === "function") {
                        callback(receivedStreamData());
                    }
                });
            }
            else {
                queuedData.push(receivedStreamData());
            }
        };
        this.handleSubscriptionCancelled = function (msg) {
            var subLocalKey = _this.subscriptionIdToLocalKeyMap[msg.subscription_id];
            if (typeof subLocalKey === "undefined") {
                return;
            }
            var subscription = _this.subscriptionsList[subLocalKey];
            if (typeof subscription !== "object") {
                return;
            }
            var expectedNewLength = subscription.trackedServers.length - 1;
            subscription.trackedServers = subscription.trackedServers.filter(function (server) {
                if (server.subscriptionId === msg.subscription_id) {
                    subscription.queued.closers.push(server.serverId);
                    return false;
                }
                else {
                    return true;
                }
            });
            if (subscription.trackedServers.length !== expectedNewLength) {
                return;
            }
            if (subscription.trackedServers.length <= 0) {
                _this.timedCache.add(subscription);
                clearTimeout(subscription.timeoutId);
                _this.callOnClosedHandlers(subscription);
                delete _this.subscriptionsList[subLocalKey];
            }
            delete _this.subscriptionIdToLocalKeyMap[msg.subscription_id];
        };
        session.on("subscribed", this.handleSubscribed);
        session.on("event", this.handleEventData);
        session.on("subscription-cancelled", this.handleSubscriptionCancelled);
    }
    ClientStreaming.prototype.subscribe = function (streamingMethod, params, targetServers, success, error, existingSub) {
        var _this = this;
        if (targetServers.length === 0) {
            error({
                method: streamingMethod,
                called_with: params.arguments,
                message: ERR_MSG_SUB_FAILED + " No available servers matched the target params.",
            });
            return;
        }
        var subLocalKey = this.getNextSubscriptionLocalKey();
        var pendingSub = this.registerSubscription(subLocalKey, streamingMethod, params, success, error, params.methodResponseTimeout || 10000, existingSub);
        if (typeof pendingSub !== "object") {
            error({
                method: streamingMethod,
                called_with: params.arguments,
                message: ERR_MSG_SUB_FAILED + " Unable to register the user callbacks.",
            });
            return;
        }
        targetServers.forEach(function (target) {
            var serverId = target.server.id;
            var method = target.methods.find(function (m) { return m.name === streamingMethod.name; });
            if (!method) {
                _this.logger.error("can not find method ".concat(streamingMethod.name, " for target ").concat(target.server.id));
                return;
            }
            pendingSub.trackedServers.push({
                serverId: serverId,
                subscriptionId: undefined,
            });
            var msg = {
                type: "subscribe",
                server_id: serverId,
                method_id: method.gatewayId,
                arguments_kv: params.arguments,
            };
            _this.session.send(msg, { serverId: serverId, subLocalKey: subLocalKey })
                .then(function (m) { return _this.handleSubscribed(m); })
                .catch(function (err) { return _this.handleErrorSubscribing(err); });
        });
    };
    ClientStreaming.prototype.drainSubscriptions = function () {
        var existing = Object.values(this.subscriptionsList);
        this.subscriptionsList = {};
        this.subscriptionIdToLocalKeyMap = {};
        return existing;
    };
    ClientStreaming.prototype.drainSubscriptionsCache = function () {
        return this.timedCache.flush();
    };
    ClientStreaming.prototype.getNextSubscriptionLocalKey = function () {
        var current = this.nextSubLocalKey;
        this.nextSubLocalKey += 1;
        return current;
    };
    ClientStreaming.prototype.registerSubscription = function (subLocalKey, method, params, success, error, timeout, existingSub) {
        var _this = this;
        var subsInfo = {
            localKey: subLocalKey,
            status: STATUS_AWAITING_ACCEPT,
            method: method,
            params: params,
            success: success,
            error: error,
            trackedServers: [],
            handlers: {
                onData: (existingSub === null || existingSub === void 0 ? void 0 : existingSub.handlers.onData) || [],
                onClosed: (existingSub === null || existingSub === void 0 ? void 0 : existingSub.handlers.onClosed) || [],
                onConnected: (existingSub === null || existingSub === void 0 ? void 0 : existingSub.handlers.onConnected) || [],
            },
            queued: {
                data: [],
                closers: [],
            },
            timeoutId: undefined,
            close: function () { return _this.closeSubscription(subLocalKey); },
            subscription: existingSub === null || existingSub === void 0 ? void 0 : existingSub.subscription
        };
        if (!existingSub) {
            if (params.onData) {
                subsInfo.handlers.onData.push(params.onData);
            }
            if (params.onClosed) {
                subsInfo.handlers.onClosed.push(params.onClosed);
            }
            if (params.onConnected) {
                subsInfo.handlers.onConnected.push(params.onConnected);
            }
        }
        this.subscriptionsList[subLocalKey] = subsInfo;
        subsInfo.timeoutId = setTimeout(function () {
            if (_this.subscriptionsList[subLocalKey] === undefined) {
                return;
            }
            var pendingSub = _this.subscriptionsList[subLocalKey];
            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {
                error({
                    method: method,
                    called_with: params.arguments,
                    message: ERR_MSG_SUB_FAILED + " Subscription attempt timed out after " + timeout + " ms.",
                });
                delete _this.subscriptionsList[subLocalKey];
            }
            else if (pendingSub.status === STATUS_SUBSCRIBED && pendingSub.trackedServers.length > 0) {
                pendingSub.trackedServers = pendingSub.trackedServers.filter(function (server) {
                    return (typeof server.subscriptionId !== "undefined");
                });
                delete pendingSub.timeoutId;
                if (pendingSub.trackedServers.length <= 0) {
                    _this.callOnClosedHandlers(pendingSub);
                    delete _this.subscriptionsList[subLocalKey];
                }
            }
        }, timeout);
        return subsInfo;
    };
    ClientStreaming.prototype.callOnClosedHandlers = function (subscription, reason) {
        var closersCount = subscription.queued.closers.length;
        var closingServerId = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;
        var closingServer;
        if (closingServerId !== undefined && typeof closingServerId === "string") {
            closingServer = this.repository.getServerById(closingServerId).instance;
        }
        subscription.handlers.onClosed.forEach(function (callback) {
            if (typeof callback !== "function") {
                return;
            }
            callback({
                message: reason || ON_CLOSE_MSG_SERVER_INIT,
                requestArguments: subscription.params.arguments || {},
                server: closingServer,
                stream: subscription.method,
            });
        });
    };
    ClientStreaming.prototype.closeSubscription = function (subLocalKey) {
        var _this = this;
        var subscription = this.subscriptionsList[subLocalKey];
        if (typeof subscription !== "object") {
            return;
        }
        subscription.trackedServers.forEach(function (server) {
            if (typeof server.subscriptionId === "undefined") {
                return;
            }
            subscription.queued.closers.push(server.serverId);
            _this.session.sendFireAndForget({
                type: "unsubscribe",
                subscription_id: server.subscriptionId,
                reason_uri: "",
                reason: ON_CLOSE_MSG_CLIENT_INIT,
            });
            delete _this.subscriptionIdToLocalKeyMap[server.subscriptionId];
        });
        subscription.trackedServers = [];
        this.callOnClosedHandlers(subscription, ON_CLOSE_MSG_CLIENT_INIT);
        delete this.subscriptionsList[subLocalKey];
    };
    return ClientStreaming;
}());

var ClientProtocol = (function () {
    function ClientProtocol(session, repository, logger) {
        var _this = this;
        this.session = session;
        this.repository = repository;
        this.logger = logger;
        session.on("peer-added", function (msg) { return _this.handlePeerAdded(msg); });
        session.on("peer-removed", function (msg) { return _this.handlePeerRemoved(msg); });
        session.on("methods-added", function (msg) { return _this.handleMethodsAddedMessage(msg); });
        session.on("methods-removed", function (msg) { return _this.handleMethodsRemovedMessage(msg); });
        this.streaming = new ClientStreaming(session, repository, logger);
    }
    ClientProtocol.prototype.subscribe = function (stream, options, targetServers, success, error, existingSub) {
        this.streaming.subscribe(stream, options, targetServers, success, error, existingSub);
    };
    ClientProtocol.prototype.invoke = function (id, method, args, target) {
        var _this = this;
        var serverId = target.id;
        var methodId = method.gatewayId;
        var msg = {
            type: "call",
            server_id: serverId,
            method_id: methodId,
            arguments_kv: args,
        };
        return this.session.send(msg, { invocationId: id, serverId: serverId })
            .then(function (m) { return _this.handleResultMessage(m); })
            .catch(function (err) { return _this.handleInvocationError(err); });
    };
    ClientProtocol.prototype.drainSubscriptions = function () {
        return this.streaming.drainSubscriptions();
    };
    ClientProtocol.prototype.drainSubscriptionsCache = function () {
        return this.streaming.drainSubscriptionsCache();
    };
    ClientProtocol.prototype.handlePeerAdded = function (msg) {
        var newPeerId = msg.new_peer_id;
        var remoteId = msg.identity;
        var isLocal = msg.meta ? msg.meta.local : true;
        var pid = Number(remoteId.process);
        var serverInfo = {
            machine: remoteId.machine,
            pid: isNaN(pid) ? remoteId.process : pid,
            instance: remoteId.instance,
            application: remoteId.application,
            applicationName: remoteId.applicationName,
            environment: remoteId.environment,
            region: remoteId.region,
            user: remoteId.user,
            windowId: remoteId.windowId,
            peerId: newPeerId,
            api: remoteId.api,
            isLocal: isLocal
        };
        this.repository.addServer(serverInfo, newPeerId);
    };
    ClientProtocol.prototype.handlePeerRemoved = function (msg) {
        var removedPeerId = msg.removed_id;
        var reason = msg.reason;
        this.repository.removeServerById(removedPeerId, reason);
    };
    ClientProtocol.prototype.handleMethodsAddedMessage = function (msg) {
        var _this = this;
        var serverId = msg.server_id;
        var methods = msg.methods;
        methods.forEach(function (method) {
            _this.repository.addServerMethod(serverId, method);
        });
    };
    ClientProtocol.prototype.handleMethodsRemovedMessage = function (msg) {
        var _this = this;
        var serverId = msg.server_id;
        var methodIdList = msg.methods;
        var server = this.repository.getServerById(serverId);
        var serverMethodKeys = Object.keys(server.methods);
        serverMethodKeys.forEach(function (methodKey) {
            var method = server.methods[methodKey];
            if (methodIdList.indexOf(method.gatewayId) > -1) {
                _this.repository.removeServerMethod(serverId, methodKey);
            }
        });
    };
    ClientProtocol.prototype.handleResultMessage = function (msg) {
        var invocationId = msg._tag.invocationId;
        var result = msg.result;
        var serverId = msg._tag.serverId;
        var server = this.repository.getServerById(serverId);
        return {
            invocationId: invocationId,
            result: result,
            instance: server.instance,
            status: InvokeStatus.Success,
            message: ""
        };
    };
    ClientProtocol.prototype.handleInvocationError = function (msg) {
        this.logger.debug("handle invocation error ".concat(JSON.stringify(msg)));
        if ("_tag" in msg) {
            var invocationId = msg._tag.invocationId;
            var serverId = msg._tag.serverId;
            var server = this.repository.getServerById(serverId);
            var message = msg.reason;
            var context_1 = msg.context;
            return {
                invocationId: invocationId,
                result: context_1,
                instance: server.instance,
                status: InvokeStatus.Error,
                message: message
            };
        }
        else {
            return {
                invocationId: "",
                message: msg.message,
                status: InvokeStatus.Error,
                error: msg
            };
        }
    };
    return ClientProtocol;
}());

function gW3ProtocolFactory (instance, connection, clientRepository, serverRepository, libConfig, interop) {
    var logger = libConfig.logger.subLogger("gw3-protocol");
    var resolveReadyPromise;
    var readyPromise = new Promise(function (resolve) {
        resolveReadyPromise = resolve;
    });
    var session = connection.domain("agm", ["subscribed"]);
    var server = new ServerProtocol(session, clientRepository, serverRepository, logger.subLogger("server"));
    var client = new ClientProtocol(session, clientRepository, logger.subLogger("client"));
    function handleReconnect() {
        return __awaiter(this, void 0, void 0, function () {
            var reconnectionPromises, existingSubscriptions, _loop_1, _i, existingSubscriptions_1, sub, registeredMethods, _loop_2, _a, registeredMethods_1, method;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        logger.info("reconnected - will replay registered methods and subscriptions");
                        client.drainSubscriptionsCache().forEach(function (sub) {
                            var methodInfo = sub.method;
                            var params = Object.assign({}, sub.params);
                            logger.info("trying to soft-re-subscribe to method ".concat(methodInfo.name, ", with params: ").concat(JSON.stringify(params)));
                            interop.client.subscribe(methodInfo, params, undefined, undefined, sub).then(function () { return logger.info("soft-subscribing to method ".concat(methodInfo.name, " DONE")); }).catch(function (error) { return logger.warn("subscribing to method ".concat(methodInfo.name, " failed: ").concat(JSON.stringify(error), "}")); });
                        });
                        reconnectionPromises = [];
                        existingSubscriptions = client.drainSubscriptions();
                        _loop_1 = function (sub) {
                            var methodInfo = sub.method;
                            var params = Object.assign({}, sub.params);
                            logger.info("trying to re-subscribe to method ".concat(methodInfo.name, ", with params: ").concat(JSON.stringify(params)));
                            reconnectionPromises.push(interop.client.subscribe(methodInfo, params, undefined, undefined, sub).then(function () { return logger.info("subscribing to method ".concat(methodInfo.name, " DONE")); }));
                        };
                        for (_i = 0, existingSubscriptions_1 = existingSubscriptions; _i < existingSubscriptions_1.length; _i++) {
                            sub = existingSubscriptions_1[_i];
                            _loop_1(sub);
                        }
                        registeredMethods = serverRepository.getList();
                        serverRepository.reset();
                        _loop_2 = function (method) {
                            var def = method.definition;
                            logger.info("re-publishing method ".concat(def.name));
                            if (method.stream) {
                                reconnectionPromises.push(interop.server.createStream(def, method.streamCallbacks, undefined, undefined, method.stream).then(function () { return logger.info("subscribing to method ".concat(def.name, " DONE")); }));
                            }
                            else if (method.theFunction && method.theFunction.userCallback) {
                                reconnectionPromises.push(interop.register(def, method.theFunction.userCallback).then(function () { return logger.info("subscribing to method ".concat(def.name, " DONE")); }));
                            }
                            else if (method.theFunction && method.theFunction.userCallbackAsync) {
                                reconnectionPromises.push(interop.registerAsync(def, method.theFunction.userCallbackAsync).then(function () { return logger.info("subscribing to method ".concat(def.name, " DONE")); }));
                            }
                            logger.info("re-publishing method ".concat(def.name, " DONE"));
                        };
                        for (_a = 0, registeredMethods_1 = registeredMethods; _a < registeredMethods_1.length; _a++) {
                            method = registeredMethods_1[_a];
                            _loop_2(method);
                        }
                        return [4, Promise.all(reconnectionPromises)];
                    case 1:
                        _b.sent();
                        logger.info("Interop is re-announced");
                        return [2];
                }
            });
        });
    }
    function handleInitialJoin() {
        if (resolveReadyPromise) {
            resolveReadyPromise({
                client: client,
                server: server,
            });
            resolveReadyPromise = undefined;
        }
    }
    session.onJoined(function (reconnect) {
        clientRepository.addServer(instance, connection.peerId);
        if (reconnect) {
            handleReconnect().then(function () { return connection.setLibReAnnounced({ name: "interop" }); }).catch(function (error) { return logger.warn("Error while re-announcing interop: ".concat(JSON.stringify(error))); });
        }
        else {
            handleInitialJoin();
        }
    });
    session.onLeft(function () {
        clientRepository.reset();
    });
    session.join();
    return readyPromise;
}

var Interop = (function () {
    function Interop(configuration) {
        var _this = this;
        if (typeof configuration === "undefined") {
            throw new Error("configuration is required");
        }
        if (typeof configuration.connection === "undefined") {
            throw new Error("configuration.connections is required");
        }
        var connection = configuration.connection;
        if (typeof configuration.methodResponseTimeout !== "number") {
            configuration.methodResponseTimeout = 30 * 1000;
        }
        if (typeof configuration.waitTimeoutMs !== "number") {
            configuration.waitTimeoutMs = 30 * 1000;
        }
        this.unwrappedInstance = new InstanceWrapper(this, undefined, connection);
        this.instance = this.unwrappedInstance.unwrap();
        this.clientRepository = new ClientRepository(configuration.logger.subLogger("cRep"), this);
        this.serverRepository = new ServerRepository();
        var protocolPromise;
        if (connection.protocolVersion === 3) {
            protocolPromise = gW3ProtocolFactory(this.instance, connection, this.clientRepository, this.serverRepository, configuration, this);
        }
        else {
            throw new Error("protocol ".concat(connection.protocolVersion, " not supported"));
        }
        this.readyPromise = protocolPromise.then(function (protocol) {
            _this.protocol = protocol;
            _this.client = new Client(_this.protocol, _this.clientRepository, _this.instance, configuration);
            _this.server = new Server(_this.protocol, _this.serverRepository);
            return _this;
        });
    }
    Interop.prototype.ready = function () {
        return this.readyPromise;
    };
    Interop.prototype.serverRemoved = function (callback) {
        return this.client.serverRemoved(callback);
    };
    Interop.prototype.serverAdded = function (callback) {
        return this.client.serverAdded(callback);
    };
    Interop.prototype.serverMethodRemoved = function (callback) {
        return this.client.serverMethodRemoved(callback);
    };
    Interop.prototype.serverMethodAdded = function (callback) {
        return this.client.serverMethodAdded(callback);
    };
    Interop.prototype.methodRemoved = function (callback) {
        return this.client.methodRemoved(callback);
    };
    Interop.prototype.methodAdded = function (callback) {
        return this.client.methodAdded(callback);
    };
    Interop.prototype.methodsForInstance = function (instance) {
        return this.client.methodsForInstance(instance);
    };
    Interop.prototype.methods = function (methodFilter) {
        return this.client.methods(methodFilter);
    };
    Interop.prototype.servers = function (methodFilter) {
        return this.client.servers(methodFilter);
    };
    Interop.prototype.subscribe = function (method, options, successCallback, errorCallback) {
        return this.client.subscribe(method, options, successCallback, errorCallback);
    };
    Interop.prototype.createStream = function (streamDef, callbacks, successCallback, errorCallback) {
        return this.server.createStream(streamDef, callbacks, successCallback, errorCallback);
    };
    Interop.prototype.unregister = function (methodFilter) {
        return this.server.unregister(methodFilter);
    };
    Interop.prototype.registerAsync = function (methodDefinition, callback) {
        return this.server.registerAsync(methodDefinition, callback);
    };
    Interop.prototype.register = function (methodDefinition, callback) {
        return this.server.register(methodDefinition, callback);
    };
    Interop.prototype.invoke = function (methodFilter, argumentObj, target, additionalOptions, success, error) {
        return this.client.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);
    };
    Interop.prototype.waitForMethod = function (name) {
        var pw = new PromiseWrapper();
        var unsubscribe = this.client.methodAdded(function (m) {
            if (m.name === name) {
                unsubscribe();
                pw.resolve(m);
            }
        });
        return pw.promise;
    };
    return Interop;
}());

var successMessages = ["subscribed", "success"];
var MessageBus = (function () {
    function MessageBus(connection, logger) {
        var _this = this;
        this.publish = function (topic, data, options) {
            var _a = options || {}, routingKey = _a.routingKey, target = _a.target;
            var args = _this.removeEmptyValues({
                type: "publish",
                topic: topic,
                data: data,
                peer_id: _this.peerId,
                routing_key: routingKey,
                target_identity: target
            });
            _this.session.send(args);
        };
        this.subscribe = function (topic, callback, options) {
            return new Promise(function (resolve, reject) {
                var _a = options || {}, routingKey = _a.routingKey, target = _a.target;
                var args = _this.removeEmptyValues({
                    type: "subscribe",
                    topic: topic,
                    peer_id: _this.peerId,
                    routing_key: routingKey,
                    source: target
                });
                _this.session.send(args)
                    .then(function (response) {
                    var subscription_id = response.subscription_id;
                    _this.subscriptions.push({ subscription_id: subscription_id, topic: topic, callback: callback, source: target });
                    resolve({
                        unsubscribe: function () {
                            _this.session.send({ type: "unsubscribe", subscription_id: subscription_id, peer_id: _this.peerId });
                            _this.subscriptions = _this.subscriptions.filter(function (s) { return s.subscription_id !== subscription_id; });
                            return Promise.resolve();
                        }
                    });
                })
                    .catch(function (error) { return reject(error); });
            });
        };
        this.watchOnEvent = function () {
            _this.session.on("event", function (args) {
                var data = args.data, subscription_id = args.subscription_id;
                var source = args["publisher-identity"];
                var subscription = _this.subscriptions.find(function (s) { return s.subscription_id === subscription_id; });
                if (subscription) {
                    if (!subscription.source) {
                        subscription.callback(data, subscription.topic, source);
                    }
                    else {
                        if (_this.keysMatch(subscription.source, source)) {
                            subscription.callback(data, subscription.topic, source);
                        }
                    }
                }
            });
        };
        this.connection = connection;
        this.logger = logger;
        this.peerId = connection.peerId;
        this.subscriptions = [];
        this.session = connection.domain("bus", successMessages);
        this.readyPromise = this.session.join();
        this.readyPromise.then(function () {
            _this.watchOnEvent();
        });
    }
    MessageBus.prototype.ready = function () {
        return this.readyPromise;
    };
    MessageBus.prototype.removeEmptyValues = function (obj) {
        var cleaned = {};
        Object.keys(obj).forEach(function (key) {
            if (obj[key] !== undefined && obj[key] !== null) {
                cleaned[key] = obj[key];
            }
        });
        return cleaned;
    };
    MessageBus.prototype.keysMatch = function (obj1, obj2) {
        var keysObj1 = Object.keys(obj1);
        var allMatch = true;
        keysObj1.forEach(function (key) {
            if (obj1[key] !== obj2[key]) {
                allMatch = false;
            }
        });
        return allMatch;
    };
    return MessageBus;
}());

var GlueCore = function (userConfig, ext) {
    var gdVersion = Utils.getGDMajorVersion();
    var glue42gd;
    var preloadPromise = Promise.resolve();
    if (gdVersion) {
        if (gdVersion < 3) {
            throw new Error("GD v2 is not supported. Use v4 of the API to run in that context.");
        }
        else if (gdVersion >= 3) {
            glue42gd = window.glue42gd;
            preloadPromise = window.gdPreloadPromise || preloadPromise;
        }
    }
    var glueInitTimer = timer("glue");
    userConfig = userConfig || {};
    ext = ext || {};
    var internalConfig = prepareConfig(userConfig, ext, glue42gd);
    var _connection;
    var _interop;
    var _logger;
    var _metrics;
    var _contexts;
    var _bus;
    var _allowTrace;
    var libs = {};
    function registerLib(name, inner, t) {
        _allowTrace = _logger.canPublish("trace");
        if (_allowTrace) {
            _logger.trace("registering ".concat(name, " module"));
        }
        var done = function () {
            inner.initTime = t.stop();
            inner.initEndTime = t.endTime;
            inner.marks = t.marks;
            if (_allowTrace) {
                _logger.trace("".concat(name, " is ready - ").concat(t.endTime - t.startTime));
            }
        };
        inner.initStartTime = t.startTime;
        if (inner.ready) {
            inner.ready().then(function () {
                done();
            });
        }
        else {
            done();
        }
        if (!Array.isArray(name)) {
            name = [name];
        }
        name.forEach(function (n) {
            libs[n] = inner;
            GlueCore[n] = inner;
        });
    }
    function setupConnection() {
        var initTimer = timer("connection");
        _connection = new Connection(internalConfig.connection, _logger.subLogger("connection"));
        var authPromise = Promise.resolve(internalConfig.auth);
        if (internalConfig.connection && !internalConfig.auth) {
            if (glue42gd) {
                authPromise = glue42gd.getGWToken()
                    .then(function (token) {
                    return {
                        gatewayToken: token
                    };
                });
            }
            else if (typeof window !== "undefined" && (window === null || window === void 0 ? void 0 : window.glue42electron)) {
                if (typeof window.glue42electron.gwToken === "string") {
                    authPromise = Promise.resolve({
                        gatewayToken: window.glue42electron.gwToken
                    });
                }
            }
            else {
                authPromise = Promise.reject("You need to provide auth information");
            }
        }
        return authPromise
            .then(function (authConfig) {
            initTimer.mark("auth-promise-resolved");
            var authRequest;
            if (Object.prototype.toString.call(authConfig) === "[object Object]") {
                authRequest = authConfig;
            }
            else {
                throw new Error("Invalid auth object - " + JSON.stringify(authConfig));
            }
            return _connection.login(authRequest);
        })
            .then(function () {
            registerLib("connection", _connection, initTimer);
            return internalConfig;
        })
            .catch(function (e) {
            if (_connection) {
                _connection.logout();
            }
            throw e;
        });
    }
    function setupLogger() {
        var _a;
        var initTimer = timer("logger");
        _logger = new Logger("".concat((_a = internalConfig.connection.identity) === null || _a === void 0 ? void 0 : _a.application), undefined, internalConfig.customLogger);
        _logger.consoleLevel(internalConfig.logger.console);
        _logger.publishLevel(internalConfig.logger.publish);
        if (_logger.canPublish("debug")) {
            _logger.debug("initializing glue...");
        }
        registerLib("logger", _logger, initTimer);
        return Promise.resolve(undefined);
    }
    function setupMetrics() {
        var _a, _b, _c, _d, _e;
        var initTimer = timer("metrics");
        var config = internalConfig.metrics;
        var metricsPublishingEnabledFunc = glue42gd === null || glue42gd === void 0 ? void 0 : glue42gd.getMetricsPublishingEnabled;
        var identity = internalConfig.connection.identity;
        var canUpdateMetric = metricsPublishingEnabledFunc ? metricsPublishingEnabledFunc : function () { return true; };
        var disableAutoAppSystem = (_a = (typeof config !== "boolean" && config.disableAutoAppSystem)) !== null && _a !== void 0 ? _a : false;
        _metrics = metrics({
            connection: config ? _connection : undefined,
            logger: _logger.subLogger("metrics"),
            canUpdateMetric: canUpdateMetric,
            system: "Glue42",
            service: (_c = (_b = identity === null || identity === void 0 ? void 0 : identity.service) !== null && _b !== void 0 ? _b : glue42gd === null || glue42gd === void 0 ? void 0 : glue42gd.applicationName) !== null && _c !== void 0 ? _c : internalConfig.application,
            instance: (_e = (_d = identity === null || identity === void 0 ? void 0 : identity.instance) !== null && _d !== void 0 ? _d : identity === null || identity === void 0 ? void 0 : identity.windowId) !== null && _e !== void 0 ? _e : shortid(),
            disableAutoAppSystem: disableAutoAppSystem,
            pagePerformanceMetrics: typeof config !== "boolean" ? config === null || config === void 0 ? void 0 : config.pagePerformanceMetrics : undefined
        });
        registerLib("metrics", _metrics, initTimer);
        return Promise.resolve();
    }
    function setupInterop() {
        var initTimer = timer("interop");
        var agmConfig = {
            connection: _connection,
            logger: _logger.subLogger("interop"),
        };
        _interop = new Interop(agmConfig);
        Logger.Interop = _interop;
        registerLib(["interop", "agm"], _interop, initTimer);
        return Promise.resolve();
    }
    function setupContexts() {
        var hasActivities = (internalConfig.activities && _connection.protocolVersion === 3);
        var needsContexts = internalConfig.contexts || hasActivities;
        if (needsContexts) {
            var initTimer = timer("contexts");
            _contexts = new ContextsModule({
                connection: _connection,
                logger: _logger.subLogger("contexts"),
                trackAllContexts: typeof internalConfig.contexts === "object" ? internalConfig.contexts.trackAllContexts : false,
                reAnnounceKnownContexts: typeof internalConfig.contexts === "object" ? internalConfig.contexts.reAnnounceKnownContexts : false
            });
            registerLib("contexts", _contexts, initTimer);
            return _contexts;
        }
        else {
            var replayer = _connection.replayer;
            if (replayer) {
                replayer.drain(ContextMessageReplaySpec.name);
            }
        }
    }
    function setupBus() {
        return __awaiter(this, void 0, void 0, function () {
            var initTimer;
            return __generator(this, function (_a) {
                if (!internalConfig.bus) {
                    return [2, Promise.resolve()];
                }
                initTimer = timer("bus");
                _bus = new MessageBus(_connection, _logger.subLogger("bus"));
                registerLib("bus", _bus, initTimer);
                return [2, Promise.resolve()];
            });
        });
    }
    function setupExternalLibs(externalLibs) {
        try {
            externalLibs.forEach(function (lib) {
                setupExternalLib(lib.name, lib.create);
            });
            return Promise.resolve();
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    function setupExternalLib(name, createCallback) {
        var initTimer = timer(name);
        var lib = createCallback(libs);
        if (lib) {
            registerLib(name, lib, initTimer);
        }
    }
    function waitForLibs() {
        var libsReadyPromises = Object.keys(libs).map(function (key) {
            var lib = libs[key];
            return lib.ready ?
                lib.ready() : Promise.resolve();
        });
        return Promise.all(libsReadyPromises);
    }
    function constructGlueObject() {
        var feedbackFunc = function (feedbackInfo) {
            if (!_interop) {
                return;
            }
            _interop.invoke("T42.ACS.Feedback", feedbackInfo, "best");
        };
        var info = {
            coreVersion: version,
            version: internalConfig.version
        };
        glueInitTimer.stop();
        var glue = {
            feedback: feedbackFunc,
            info: info,
            logger: _logger,
            interop: _interop,
            agm: _interop,
            connection: _connection,
            metrics: _metrics,
            contexts: _contexts,
            bus: _bus,
            version: internalConfig.version,
            userConfig: userConfig,
            done: function () {
                _logger === null || _logger === void 0 ? void 0 : _logger.info("done called by user...");
                return _connection.logout();
            }
        };
        glue.performance = {
            get glueVer() {
                return internalConfig.version;
            },
            get glueConfig() {
                return JSON.stringify(userConfig);
            },
            get browser() {
                return window.performance.timing.toJSON();
            },
            get memory() {
                return window.performance.memory;
            },
            get initTimes() {
                var all = getAllTimers();
                return Object.keys(all).map(function (key) {
                    var t = all[key];
                    return {
                        name: key,
                        duration: t.endTime - t.startTime,
                        marks: t.marks,
                        startTime: t.startTime,
                        endTime: t.endTime
                    };
                });
            }
        };
        Object.keys(libs).forEach(function (key) {
            var lib = libs[key];
            glue[key] = lib;
        });
        glue.config = {};
        Object.keys(internalConfig).forEach(function (k) {
            glue.config[k] = internalConfig[k];
        });
        if (ext && ext.extOptions) {
            Object.keys(ext.extOptions).forEach(function (k) {
                glue.config[k] = ext === null || ext === void 0 ? void 0 : ext.extOptions[k];
            });
        }
        if (ext === null || ext === void 0 ? void 0 : ext.enrichGlue) {
            ext.enrichGlue(glue);
        }
        if (glue42gd && glue42gd.updatePerfData) {
            glue42gd.updatePerfData(glue.performance);
        }
        if (glue.agm) {
            var deprecatedDecorator = function (fn, wrong, proper) {
                return function () {
                    glue.logger.warn("glue.js - 'glue.agm.".concat(wrong, "' method is deprecated, use 'glue.interop.").concat(proper, "' instead."));
                    return fn.apply(glue.agm, arguments);
                };
            };
            var agmAny = glue.agm;
            agmAny.method_added = deprecatedDecorator(glue.agm.methodAdded, "method_added", "methodAdded");
            agmAny.method_removed = deprecatedDecorator(glue.agm.methodRemoved, "method_removed", "methodRemoved");
            agmAny.server_added = deprecatedDecorator(glue.agm.serverAdded, "server_added", "serverAdded");
            agmAny.server_method_aded = deprecatedDecorator(glue.agm.serverMethodAdded, "server_method_aded", "serverMethodAdded");
            agmAny.server_method_removed = deprecatedDecorator(glue.agm.serverMethodRemoved, "server_method_removed", "serverMethodRemoved");
        }
        return glue;
    }
    function registerInstanceIfNeeded() {
        return __awaiter(this, void 0, void 0, function () {
            var RegisterInstanceMethodName, isMethodAvailable, error_1, typedError;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        RegisterInstanceMethodName = "T42.ACS.RegisterInstance";
                        if (!(Utils.isNode() && typeof process.env._GD_STARTING_CONTEXT_ === "undefined" && typeof (userConfig === null || userConfig === void 0 ? void 0 : userConfig.application) !== "undefined")) return [3, 4];
                        isMethodAvailable = _interop.methods({ name: RegisterInstanceMethodName }).length > 0;
                        if (!isMethodAvailable) return [3, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4, _interop.invoke(RegisterInstanceMethodName, { appName: userConfig === null || userConfig === void 0 ? void 0 : userConfig.application, pid: process.pid })];
                    case 2:
                        _a.sent();
                        return [3, 4];
                    case 3:
                        error_1 = _a.sent();
                        typedError = error_1;
                        _logger.error("Cannot register as an instance: ".concat(JSON.stringify(typedError.message)));
                        return [3, 4];
                    case 4: return [2];
                }
            });
        });
    }
    return preloadPromise
        .then(setupLogger)
        .then(setupConnection)
        .then(function () { return Promise.all([setupMetrics(), setupInterop(), setupContexts(), setupBus()]); })
        .then(function () { return _interop.readyPromise; })
        .then(function () { return registerInstanceIfNeeded(); })
        .then(function () {
        return setupExternalLibs(internalConfig.libs || []);
    })
        .then(waitForLibs)
        .then(constructGlueObject)
        .catch(function (err) {
        return Promise.reject({
            err: err,
            libs: libs
        });
    });
};
if (typeof window !== "undefined") {
    window.GlueCore = GlueCore;
}
GlueCore.version = version;
GlueCore.default = GlueCore;

const glueWebFactory = createFactoryFunction(GlueCore);
if (typeof window !== "undefined") {
    const windowAny = window;
    windowAny.GlueWeb = glueWebFactory;
    delete windowAny.GlueCore;
}
if (!window.glue42gd && !window.glue42core) {
    window.glue42core = { webStarted: false };
}
glueWebFactory.version = version$2;


//# sourceMappingURL=web.es.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@glue42/web/node_modules/ws/browser.js":
/*!*************************************************************!*\
  !*** ./node_modules/@glue42/web/node_modules/ws/browser.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/assign.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/assign.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/promise.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/promise.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/promise */ "./node_modules/core-js/library/fn/promise.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/extends.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/extends.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(/*! ../core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/assign.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.assign */ "./node_modules/core-js/library/modules/es6.object.assign.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.assign;


/***/ }),

/***/ "./node_modules/core-js/library/fn/promise.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/library/fn/promise.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.promise */ "./node_modules/core-js/library/modules/es6.promise.js");
__webpack_require__(/*! ../modules/es7.promise.finally */ "./node_modules/core-js/library/modules/es7.promise.finally.js");
__webpack_require__(/*! ../modules/es7.promise.try */ "./node_modules/core-js/library/modules/es7.promise.try.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Promise;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_a-function.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_a-function.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_add-to-unscopables.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_add-to-unscopables.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-instance.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-instance.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-includes.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_classof.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_classof.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_cof.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_cof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_core.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ctx.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ctx.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_defined.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_defined.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_descriptors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_descriptors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_dom-create.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_dom-create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-bug-keys.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-bug-keys.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/core-js/library/modules/_export.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_export.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_fails.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_for-of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_for-of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/library/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_global.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_global.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/core-js/library/modules/_has.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_has.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_hide.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_hide.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_html.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_html.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_invoke.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_invoke.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iobject.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iobject.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array-iter.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array-iter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-call.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-call.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-create.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-create.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-define.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-define.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-detect.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-detect.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-step.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-step.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_iterators.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iterators.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_library.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_library.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_microtask.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_microtask.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/library/modules/_task.js").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_new-promise-capability.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_new-promise-capability.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-assign.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-assign.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dp.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dp.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dps.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dps.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gops.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gops.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gpo.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gpo.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys-internal.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys-internal.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-pie.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-pie.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/library/modules/_perform.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_perform.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_promise-resolve.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_promise-resolve.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/library/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_property-desc.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_property-desc.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine-all.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine-all.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-species.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-species.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-to-string-tag.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared-key.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared-key.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/_species-constructor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_species-constructor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_string-at.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_string-at.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_task.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_task.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/library/modules/_invoke.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js");
var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-absolute-index.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-absolute-index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-integer.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-integer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-iobject.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-iobject.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-length.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-length.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_uid.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_uid.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/_user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_user-agent.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator-method.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/core.get-iterator-method.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.iterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.iterator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.assign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.assign.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/library/modules/_object-assign.js") });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.to-string.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.to-string.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.promise.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.promise.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/library/modules/_species-constructor.js");
var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/library/modules/_task.js").set;
var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/library/modules/_microtask.js")();
var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/library/modules/_perform.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/library/modules/_user-agent.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/library/modules/_promise-resolve.js");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/library/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js")($Promise, PROMISE);
__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/library/modules/_set-species.js")(PROMISE);
Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/library/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.string.iterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.string.iterator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/library/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.promise.finally.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.promise.finally.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/library/modules/_species-constructor.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/library/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.promise.try.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.promise.try.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/library/modules/_perform.js");

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),

/***/ "./node_modules/core-js/library/modules/web.dom.iterable.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/web.dom.iterable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/objectmodel/dist/object-model.umd.js":
/*!***********************************************************!*\
  !*** ./node_modules/objectmodel/dist/object-model.umd.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// ObjectModel v2.6.4 - http://objectmodel.js.org
//MIT License - Sylvain Pollet-Villard
;(function (globals, factory) {
 if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
 else {} // globals
}(this, function () {
// string constants
var
OBJECT                = "Object",
ARRAY                 = "Array",
FUNCTION              = "Function",
CONVENTION_CONSTANT   = "conventionForConstant",
CONVENTION_PRIVATE    = "conventionForPrivate",
DEFINITION            = "definition",
ASSERTIONS            = "assertions",
DESCRIPTION           = "_description",
VALIDATE              = "validate",
VALIDATOR             = "_validator",
TEST                  = "test",
EXTEND                = "extend",
ASSERT                = "assert",
EXPECTED              = "expected",
RECEIVED              = "received",
PATH                  = "path",
MESSAGE               = "message",
ERROR_STACK           = "errorStack",
ERROR_COLLECTOR       = "errorCollector",
UNSTACK               = "unstack",
PROTO                 = "prototype",
CONSTRUCTOR           = "constructor",
CONSTRUCTOR_PRIVATE   = "_constructor",
DEFAULT               = "default",
DEFAULT_TO            = "defaultTo",
DEFAULTS              = "defaults",
RETURN                = "return",
ARGS                  = "arguments",

ARRAY_MUTATOR_METHODS = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],
STACKTRACE_BLACKBOX_MATCHER = /\n.*object-model(.|\n)*object-model.*/
;
var isProxySupported = typeof Proxy === "function";
var defineProperty = Object.defineProperty;

// shim for Function.name for browsers that don't support it. IE, I'm looking at you.
if (!("name" in Function.prototype && "name" in (function x() {}))) {
	defineProperty(Function.prototype, "name", {
		get: function() {
			var results = Function.prototype.toString.call(this).match(/\s*function\s+([^\(\s]*)\s*/);
			return results && results[1];
		}
	});
}

// shim for Object.setPrototypeOf if __proto__ is supported
if(!Object.setPrototypeOf && is(Array, {__proto__:[]})){
	Object.setPrototypeOf = function (obj, proto) {
		obj.__proto__ = proto
		return obj
	}
}

function getProto(x){
	return Object.getPrototypeOf(x)
}

function is(Constructor, obj){
	return obj instanceof Constructor;
}

function has(o, prop){
	return o.hasOwnProperty(prop)
}

function isFunction(o){
	return typeof o === "function";
}

function isObject(o){
    return typeof o === "object";
}

function isPlainObject(o){
	return o && isObject(o) && getProto(o) === Object.prototype;
}

function bettertypeof(obj){
	return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1];
}

function cloneArray(arr){
	return Array.prototype.slice.call(arr);
}

function defaultTo(defaultVal, val){
	return val === undefined ? defaultVal : val;
}

function merge(target, src, deep, includingProto) {
	for(var key in (src || {})){
		if(includingProto || has(src, key)){
			if(deep && isPlainObject(src[key])){
				var o = {};
				merge(o, target[key], deep);
				merge(o, src[key], deep);
				target[key] = o;
			} else {
				target[key] = src[key]
			}
		}
	}
}

function define(obj, key, val, enumerable) {
	defineProperty(obj, key, {
		value: val,
		enumerable: enumerable,
		writable: true,
		configurable: true
	});
}

function setConstructor(model, constructor){
	Object.setPrototypeOf(model, constructor[PROTO]);
	define(model, CONSTRUCTOR, constructor);
}

function setConstructorProto(constructor, proto){
	constructor[PROTO] = Object.create(proto);
	constructor[PROTO][CONSTRUCTOR] = constructor;
}

function toString(obj, stack){
	stack = stack || [];
	if(stack.length > 15 || stack.indexOf(obj) >= 0){ return '...'; }
	if(obj == null){ return String(obj); }
	if(typeof obj == "string"){ return '"'+obj+'"'; }
	if(is(Model, obj)) return obj.toString(stack);
	stack = [obj].concat(stack);
	if(isFunction(obj)){
		return obj.name || obj.toString(stack);
	}
	if(is(Array, obj)){
		return '[' + obj.map(function(item) {
				return toString(item, stack);
			}).join(', ') + ']';
	}
	if(obj.toString !== Object.prototype.toString){
		return obj.toString();
	}
	if(obj && isObject(obj)){
		var indent = (new Array(stack.length)).join('\t');
		var props = Object.keys(obj);
		return '{' + props.map(function(key){
			return '\n' + indent + '\t' + key + ': ' + toString(obj[key], stack);
		}).join(',') + (props.length ? '\n' + indent : '') + '}';
	}
	return String(obj)
}
function Model(def){
	if(isPlainObject(def)) return Model[OBJECT](def);

	var model = function(obj) {
		obj = defaultTo(model[DEFAULT], obj);
		model[VALIDATE](obj);
		return obj;
	};

	initModel(model, arguments, Model);
	return model;
}

setConstructorProto(Model, Function[PROTO]);
var ModelProto = Model[PROTO];

ModelProto.toString = function(stack){
	return parseDefinition(this[DEFINITION]).map(function(d){
		return toString(d, stack);
	}).join(" or ");
};

ModelProto[ASSERTIONS] = [];

ModelProto[VALIDATE] = function(obj, errorCollector){
	this[VALIDATOR](obj, null, [], this[ERROR_STACK]);
	this[UNSTACK](errorCollector);
};

ModelProto[TEST] = function(obj){
	var model = this;
	while(!has(model, ERROR_COLLECTOR)){
		model = getProto(model)
	}

	var initialErrorCollector = model[ERROR_COLLECTOR],
	    failed;

	model[ERROR_COLLECTOR] = function(){ failed = true };
	new this(obj); // may trigger this.errorCollector
	model[ERROR_COLLECTOR] = initialErrorCollector;
	return !failed;
};

ModelProto[EXTEND] = function(){
	var def, proto,
	    parent = this,
		assertions = cloneArray(this[ASSERTIONS]),
		args = cloneArray(arguments);

	if(is(Model[OBJECT], parent)){
		def = {};
		proto = {};
		merge(def, parent[DEFINITION]);
		merge(proto, parent[PROTO], false, true);
		args.forEach(function(arg){
			if(is(Model, arg)){
				merge(def, arg[DEFINITION], true);
			}
			if(isFunction(arg)){
				merge(proto, arg[PROTO], true, true);
			}
			if(isObject(arg)) {
				merge(def, arg, true, true);
			}
		})
		delete proto.constructor;
	} else {
		def = args
			.reduce(function(def, ext){
				return def.concat(parseDefinition(ext));
			}, parseDefinition(this[DEFINITION]))
			.filter(function(value, index, self) {
				return self.indexOf(value) === index; // remove duplicates
			});
	}

	args.forEach(function(arg){
		if(is(Model, arg)){
			assertions = assertions.concat(arg[ASSERTIONS]);
		}
	});

	var submodel = new parent[CONSTRUCTOR](def);
	setConstructorProto(submodel, parent[PROTO]);
	merge(submodel[PROTO], proto);
	submodel[ASSERTIONS] = assertions;

	if(getProto(parent) !== Model[OBJECT][PROTO]) { // extended class
		submodel[CONSTRUCTOR_PRIVATE] = function(obj){
			var parentInstance = new parent(obj)
			merge(obj, parentInstance, true) // get modified props from parent class constructor
			return obj
		}
	}

	return submodel;
};

ModelProto[ASSERT] = function(assertion, description){
	description = description || toString(assertion);
	define(assertion, DESCRIPTION, description);
	this[ASSERTIONS] = this[ASSERTIONS].concat(assertion);
	return this;
};

ModelProto[DEFAULT_TO] = function(val){
	this[DEFAULT] = val;
	return this;
}

ModelProto[ERROR_COLLECTOR] = function(errors){
	var e = new TypeError(errors.map(function(e){ return e[MESSAGE]; }).join('\n'));
	if(e.stack){
		e.stack = e.stack.replace(STACKTRACE_BLACKBOX_MATCHER, "");
	}
	throw e;
};

Model[CONVENTION_CONSTANT] = function(key){ return key.toUpperCase() === key };
Model[CONVENTION_PRIVATE] = function(key){ return key[0] === "_" };

// private methods
define(ModelProto, VALIDATOR, function(obj, path, callStack, errorStack){
	checkDefinition(obj, this[DEFINITION], path, callStack, errorStack);
	checkAssertions(obj, this, path, errorStack);
});

// throw all errors collected
define(ModelProto, UNSTACK, function(errorCollector){
	if(!this[ERROR_STACK].length){
		return;
	}
	if(!errorCollector){
		errorCollector = this[ERROR_COLLECTOR];
	}
	var errors = this[ERROR_STACK].map(function(err){
		if(!err[MESSAGE]){
			var def = is(Array, err[EXPECTED]) ? err[EXPECTED] : [err[EXPECTED]];
			err[MESSAGE] = ("expecting " + (err[PATH] ? err[PATH] + " to be " : "")
			+ def.map(function(d){ return toString(d); }).join(" or ")
			+ ", got " + (err[RECEIVED] != null ? bettertypeof(err[RECEIVED]) + " " : "")
			+ toString(err[RECEIVED]))
		}
		return err;
	});
	this[ERROR_STACK] = [];
	errorCollector.call(this, errors);
})

function initModel(model, args, constructor){
	if(args.length === 0) throw new Error("Model definition is required");
	setConstructor(model, constructor);
	model[DEFINITION] = args[0];
	model[ASSERTIONS] = model[ASSERTIONS].slice(); // clone from Model.prototype
	define(model, ERROR_STACK, []);
}

function parseDefinition(def){
	if(!isPlainObject(def)){
		if(!is(Array, def)) return [def];
		if(def.length === 1) return def.concat(undefined, null);
	} else {
		Object.keys(def).forEach(function(key) {
			def[key] = parseDefinition(def[key]);
		});
	}
	return def;
}

function checkDefinition(obj, def, path, callStack, errorStack, shouldCast){
	var indexFound = callStack.indexOf(def);
	if(indexFound !== -1 && callStack.slice(indexFound+1).indexOf(def) !== -1){
		return obj; //if found twice in call stack, cycle detected, skip validation
	}

	if(shouldCast) {
		obj = cast(obj, def);
	}

	if(is(Model, def)){
		def[VALIDATOR](obj, path, callStack.concat(def), errorStack);
	}
	else if(isPlainObject(def)) {
		Object.keys(def).forEach(function (key) {
			var val = obj != null ? obj[key] : undefined;
			checkDefinition(val, def[key], path ? path + '.' + key : key, callStack, errorStack);
		});
	} else {
		var pdef = parseDefinition(def);
		for(var i=0, l=pdef.length; i<l; i++){
			if(checkDefinitionPart(obj, pdef[i], path, callStack)){
				return obj;
			}
		}
		var err = {};
		err[EXPECTED] = def;
		err[RECEIVED] = obj;
		err[PATH] = path;
		errorStack.push(err);
	}
	return obj;
}

function checkDefinitionPart(obj, def, path, callStack){
	if(obj == null){
		return obj === def;
	}
	if(isPlainObject(def) || is(Model, def)){ // object or model as part of union type
		var errorStack = [];
		checkDefinition(obj, def, path, callStack, errorStack);
		return !errorStack.length;
	}
	if(is(RegExp, def)){
		return def.test(obj);
	}
	if(def === Number || def === Date){
		return obj[CONSTRUCTOR] === def && !isNaN(obj)
	}

	return obj === def
		|| (isFunction(def) && is(def, obj))
		|| obj[CONSTRUCTOR] === def;
}

function checkAssertions(obj, model, path, errorStack){
	for(var i=0, l=model[ASSERTIONS].length; i<l ; i++){
		var assert = model[ASSERTIONS][i],
			assertionResult,
			description = assert[DESCRIPTION],
		    onFail = isFunction(description) ? description : function (assertionResult, value) {
				return 'assertion "' + description
				     + '" returned ' + toString(assertionResult)
				     + ' for value ' + toString(value);
			};
		try {
			assertionResult = assert.call(model, obj);
		} catch(err){
			assertionResult = err;
		}
		if(assertionResult !== true){
			var err = {};
			err[MESSAGE] = onFail.call(model, assertionResult, obj)
			err[EXPECTED] = assert;
			err[RECEIVED] = obj;
			err[PATH] = path;
			errorStack.push(err);
		}
	}
}

function cast(obj, defNode){
	if(!obj || is(Model, obj[CONSTRUCTOR])){
		return obj; // no value or already a model instance
	}

	var def = parseDefinition(defNode || []),
	    suitableModels = [];

	for(var i=0, l=def.length; i<l; i++){
		var defPart = def[i];
		if(is(Model, defPart) && defPart[TEST](obj)){
			suitableModels.push(defPart);
		}
	}

	var nbSuitableModels = suitableModels.length;
	if(nbSuitableModels === 1) {
		return new suitableModels[0](obj); // automatically cast to the suitable model when explicit
	}
	if(nbSuitableModels > 1){
		console.warn("Ambiguous model for value " + toString(obj)
			+ ", could be " + suitableModels.join(" or "));
	}

	return obj;
}
Model[OBJECT] = function ObjectModel(def){

	var model = function(obj) {
		if(is(model, obj)){
			return obj;
		}
		if(!is(model, this)){
			return new model(obj);
		}

		if(!is(Object, obj) && obj !== undefined){
			var err = {};
			err[EXPECTED] = OBJECT;
			err[RECEIVED] = obj;
			model[ERROR_STACK].push(err);
		}

		obj = defaultTo(model[DEFAULT], obj);
		merge(this, model[CONSTRUCTOR_PRIVATE](obj), true);
		var proxy = getProxy(model, this, model[DEFINITION]);
		model[VALIDATE](proxy);
		return proxy;
	};

	setConstructorProto(model, Object[PROTO]);
	initModel(model, arguments, Model[OBJECT]);
	return model;
};

setConstructorProto(Model[OBJECT], ModelProto);
var ObjectModelProto = Model[OBJECT][PROTO];

ObjectModelProto[DEFAULTS] = function(p){
	merge(this[PROTO], p);
	return this;
};

ObjectModelProto.toString = function(stack){
	return toString(this[DEFINITION], stack);
};

// private methods
define(ObjectModelProto, VALIDATOR, function(obj, path, callStack, errorStack){
	if(!isObject(obj)){
		var err = {};
		err[EXPECTED] = this;
		err[RECEIVED] = obj;
		err[PATH] = path;
		errorStack.push(err);
	} else {
		checkDefinition(obj, this[DEFINITION], path, callStack, errorStack);
	}
	checkAssertions(obj, this, path, errorStack);
});

define(ObjectModelProto, CONSTRUCTOR_PRIVATE, function(o){ return o });

function getProxy(model, obj, defNode, path) {
	if(!isPlainObject(defNode)) {
		return cast(obj, defNode);
	}

	var wrapper = is(Object, obj) ? obj : {};
	var proxy = Object.create(getProto(wrapper));

	for(var key in wrapper){
		if(has(wrapper, key) && !(key in defNode)){
			proxy[key] = wrapper[key]; // properties out of model definition are kept
		}
	}

	Object.keys(defNode).forEach(function(key) {
		var newPath = (path ? path + '.' + key : key);
		var isConstant = Model[CONVENTION_CONSTANT](key);
		var defPart = defNode[key];

		if(!isPlainObject(defPart) && wrapper[key] && !is(Model, wrapper[key][CONSTRUCTOR])) {
			// cast nested models immediately at parent instanciation
			wrapper[key] = cast(wrapper[key], defPart);
		}

		defineProperty(proxy, key, {
			get: function () {
				return getProxy(model, wrapper[key], defPart, newPath);
			},
			set: function (val) {
				if(isConstant && wrapper[key] !== undefined){
					var err = {};
					err[MESSAGE] = "cannot redefine constant " + key;
					model[ERROR_STACK].push(err);
				}
				var newProxy = getProxy(model, val, defPart, newPath);
				checkDefinition(newProxy, defPart, newPath, [], model[ERROR_STACK]);
				var oldValue = wrapper[key];
				wrapper[key] = newProxy;
				checkAssertions(obj, model, newPath, model[ERROR_STACK]);
				if(model[ERROR_STACK].length){
					wrapper[key] = oldValue;
					model[UNSTACK]();
				}
			},
			enumerable: !Model[CONVENTION_PRIVATE](key)
		});
	});
	return proxy;
}
Model[ARRAY] = function ArrayModel(def){

	var model = function(array) {
		array = defaultTo(model[DEFAULT], array);

		var proxy;
		model[VALIDATE](array);
		if(isProxySupported){
			proxy = new Proxy(array, {
				get: function (arr, key) {
					if(key === CONSTRUCTOR){
						return model;
					} else if(ARRAY_MUTATOR_METHODS.indexOf(key) >= 0){
						return proxifyArrayMethod(arr, key, model);
					}
					return arr[key];
				},
				set: function (arr, key, val) {
					setArrayKey(arr, key, val, model);
				},
				getPrototypeOf: function(){
					return model[PROTO];
				}
			});
		} else {
			proxy = Object.create(Array[PROTO]);
			for(var key in array){
				if(has(array, key)){
					proxifyArrayKey(proxy, array, key, model);
				}
			}
			defineProperty(proxy, "length", { get: function() { return array.length; } });
			defineProperty(proxy, "toJSON", { value: function() { return array; } });
			ARRAY_MUTATOR_METHODS.forEach(function (method) {
				define(proxy, method, proxifyArrayMethod(array, method, model, proxy));
			});
			setConstructor(proxy, model);
		}

		return proxy;
	};

	setConstructorProto(model, Array[PROTO]);
	initModel(model, arguments, Model[ARRAY]);
	return model;
};

setConstructorProto(Model[ARRAY], Model[PROTO]);
var ArrayModelProto = Model[ARRAY][PROTO];

ArrayModelProto.toString = function(stack){
	return ARRAY + ' of ' + toString(this[DEFINITION], stack);
};

// private methods
define(ArrayModelProto, VALIDATOR, function(arr, path, callStack, errorStack){
	if(!is(Array, arr)){
		var err = {};
		err[EXPECTED] = this;
		err[RECEIVED] = arr;
		err[PATH] = path;
		errorStack.push(err);
	} else {
		for(var i=0, l=arr.length; i<l; i++){
			arr[i] = checkDefinition(arr[i], this[DEFINITION], (path||ARRAY)+'['+i+']', callStack, errorStack, true);
		}
	}
	checkAssertions(arr, this, path, errorStack);
});

function proxifyArrayKey(proxy, array, key, model){
	defineProperty(proxy, key, {
		enumerable: true,
		get: function () {
			return array[key];
		},
		set: function (val) {
			setArrayKey(array, key, val, model);
		}
	});
}

function proxifyArrayMethod(array, method, model, proxy){
	return function() {
		var testArray = array.slice();
		Array[PROTO][method].apply(testArray, arguments);
		model[VALIDATE](testArray);

		if(!isProxySupported){
			for(var key in testArray){ // proxify new array keys if any after method call
				if(has(testArray, key) && !(key in proxy)){
					proxifyArrayKey(proxy, array, key, model);
				}
			}
		}

		var returnValue = Array[PROTO][method].apply(array, arguments);
		for(var i=0, l=array.length; i<l; i++) {
			array[i] = cast(array[i], model[DEFINITION]);
		}
		return returnValue;
	};
}

function setArrayKey(array, key, value, model){
	var path = ARRAY+'['+key+']';
	if(parseInt(key) === +key && key >= 0){
		value = checkDefinition(value, model[DEFINITION], path, [], model[ERROR_STACK], true);
	}
	var testArray = array.slice();
	testArray[key] = value;
	checkAssertions(testArray, model, path, model[ERROR_STACK]);
	model[UNSTACK]();
	array[key] = value;
}
Model[FUNCTION] = function FunctionModel(){

	var model = function(fn) {
		fn = defaultTo(model[DEFAULT], fn);

		var def = model[DEFINITION];
		var proxyFn = function () {
			var args = [], returnValue;
			merge(args, def[DEFAULTS]);
			merge(args, cloneArray(arguments));
			if (args.length > def[ARGS].length) {
				var err = {};
				err[EXPECTED] = toString(fn) + " to be called with " + def[ARGS].length + " "+ARGS;
				err[RECEIVED] = args.length;
				model[ERROR_STACK].push(err);
			}
			def[ARGS].forEach(function (argDef, i) {
				args[i] = checkDefinition(args[i], argDef, ARGS + '[' + i + ']', [], model[ERROR_STACK], true);
			});
			checkAssertions(args, model, ARGS, model[ERROR_STACK]); //TODO: improve path parameter

			if(!model[ERROR_STACK].length){
				returnValue = fn.apply(this, args);
				if (RETURN in def) {
					returnValue = checkDefinition(returnValue, def[RETURN], RETURN+' value', [], model[ERROR_STACK], true);
				}
			}
			model[UNSTACK]();
			return returnValue;
		};
		setConstructor(proxyFn, model);
		return proxyFn;
	};

	setConstructorProto(model, Function[PROTO]);

	var def = {};
	def[ARGS] = cloneArray(arguments);
	initModel(model, [def], Model[FUNCTION]);
	return model;
};

setConstructorProto(Model[FUNCTION], Model[PROTO]);

var FunctionModelProto = Model[FUNCTION][PROTO];

FunctionModelProto.toString = function(stack){
	var out = FUNCTION + '(' + this[DEFINITION][ARGS].map(function(argDef){
		return toString(argDef, stack);
	}).join(",") +')';
	if(RETURN in this[DEFINITION]) {
		out += " => " + toString(this[DEFINITION][RETURN]);
	}
	return out;
};

FunctionModelProto[RETURN] = function(def){
	this[DEFINITION][RETURN] = def;
	return this;
};

FunctionModelProto[DEFAULTS] = function(){
	this[DEFINITION][DEFAULTS] = cloneArray(arguments);
	return this;
};

// private methods
define(FunctionModelProto, VALIDATOR, function(f, path, callStack, errorStack){
	if(!isFunction(f)){
		var err = {};
		err[EXPECTED] = FUNCTION;
		err[RECEIVED] = f;
		err[PATH] = path;
		errorStack.push(err);
	}
});
return Model;
}));

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, docName, distName, publishConfig, version, description, main, types, scripts, keywords, author, license, devDependencies, peerDependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"tick42-crm\",\"docName\":\"Glue42CRM\",\"distName\":\"Tick42CRM\",\"publishConfig\":{\"registry\":\"https://repo.tick42.com/api/npm/tick42-npm/\"},\"version\":\"2.6.6\",\"description\":\"\",\"main\":\"dist/Tick42CRM.min.js\",\"types\":\"./types/index.d.ts\",\"scripts\":{\"prepublishOnly\":\"npm run build\",\"test\":\"tape ./test/**/*.js\",\"faux-fs\":\"node ./scripts/faux-fs.js\",\"clean\":\"node ./scripts/clean.js\",\"pre:build\":\"npm run clean && npm run faux-fs\",\"file-versionify\":\"node ./scripts/file-versionify.js\",\"build:dev\":\"set NODE_ENV=development && webpack --mode=development && npm run file-versionify\",\"build:prod\":\"set NODE_ENV=production && webpack --mode=production && npm run file-versionify\",\"build\":\"npm run pre:build && npm run build:prod && npm run build:dev\",\"watch\":\"webpack --watch\",\"serve\":\"http-server ./dist-host-app -p 8048 -a 127.0.0.1\",\"generate-docs\":\"glue-js-documentation-builder build-reference --project g4e --modules ./types/index.d.ts,./node_modules/tick42-glue-core/glue.d.ts\",\"generate-docs-new-structure\":\"glue-js-documentation-builder build-reference --project g4e -q reference --modules ./types/index.d.ts,./node_modules/@glue42/core/glue.d.ts --newStructure\"},\"keywords\":[],\"author\":\"Tick42\",\"license\":\"ISC\",\"devDependencies\":{\"@glue42/core\":\"4.8.6\",\"@glue42/desktop\":\"5.5.7\",\"@glue42/gss\":\"^1.46.3\",\"@glue42/web\":\"^2.19.1 \",\"babel-cli\":\"^6.26.0\",\"babel-core\":\"^6.26.0\",\"babel-loader\":\"^7.1.2\",\"babel-plugin-transform-object-assign\":\"^6.22.0\",\"babel-plugin-transform-object-rest-spread\":\"^6.26.0\",\"babel-plugin-transform-runtime\":\"^6.23.0\",\"babel-preset-es2015\":\"^6.24.1\",\"chai\":\"^4.1.2\",\"faux-fs\":\"^0.0.1\",\"fs\":\"^0.0.1-security\",\"objectmodel\":\"^2.6.4\",\"shelljs\":\"^0.8.5\",\"tape\":\"^4.6.3\",\"webpack\":\"^4.46.0\",\"webpack-cli\":\"^4.10.0\"},\"peerDependencies\":{\"@glue42/core\":\"^4.8.6\",\"@glue42/desktop\":\"^5.5.7\",\"@glue42/web\":\"^2.19.1 \",\"objectmodel\":\"^2.6.4\"}}");

/***/ }),

/***/ "./src/Controllers/AccountController.js":
/*!**********************************************!*\
  !*** ./src/Controllers/AccountController.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");
var Account = __webpack_require__(/*! ../models/Account */ "./src/models/Account.js");
var Contact = __webpack_require__(/*! ../models/Contact */ "./src/models/Contact.js");

var AccountContactList = Model({
  account: Account,
  contacts: Model.Array(Contact)
});

function getTarget(config, target) {
  return config.getAgmTarget(target);
}

module.exports = function AccountController(agm, config) {
  return {
    create: function create(args, target) {
      args = args || {};
      target = getTarget(config, target);
      return new _promise2.default(function (resolve, reject) {
        var rawAccount = args.account ? args.account : args;
        Account.validate(rawAccount);
        agm.invoke('T42.CRM.CreateAccount', { account: rawAccount }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    resolve: function resolve(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawAccount = args.account ? args.account : args;
        Account.validate(rawAccount);
        agm.invoke('T42.CRM.ResolveAccount', { account: rawAccount }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    update: function update(args, autoCreateArg, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawAccount = args.account ? args.account : args;
        Account.validate(rawAccount);
        var autoCreate = args.autoCreate ? args.autoCreate : autoCreateArg;
        agm.invoke('T42.CRM.UpdateAccount', { account: rawAccount, autoCreate: autoCreate }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    delete: function _delete(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawAccount = args.account ? args.account : args;
        Account.validate(rawAccount);
        agm.invoke('T42.CRM.DeleteAccount', { account: rawAccount }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    get: function get(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawAccount = args.account ? args.account : args;
        Account.validate(rawAccount);
        agm.invoke('T42.CRM.GetAccount', { account: rawAccount }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    sync: function sync(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawAccount = args.account ? args.account : args;
        Account.validate(rawAccount);
        agm.invoke('T42.CRM.SyncAccount', { account: rawAccount }, config.getAgmTarget(), { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    resolveContactList: function resolveContactList(args, contacts, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawAccount = args.account ? args.account : args;
        var rawContacts = args.contacts ? args.contacts : contacts;
        AccountContactList.validate({ account: rawAccount, contacts: rawContacts });
        agm.invoke('T42.CRM.ResolveAccountContactList', { account: rawAccount, contacts: rawContacts }, 'best', { method_response_timeout: config.timeout }, resolve, reject);
      });
    }
  };
};

/***/ }),

/***/ "./src/Controllers/ContactController.js":
/*!**********************************************!*\
  !*** ./src/Controllers/ContactController.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Contact = __webpack_require__(/*! ../models/Contact */ "./src/models/Contact.js");
var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");

var Call = Model({
    contact: Contact,
    participants: [Model.Array(Contact)],
    subject: [String],
    dueDate: [String],
    description: [String]
});

function getTarget(config, target) {
    return config.getAgmTarget(target);
}

module.exports = function ContactController(agm, config) {
    return {
        create: function create(args, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                var rawContact = args.contact ? args.contact : args;
                Contact.validate(rawContact);
                agm.invoke('T42.CRM.CreateContact', { contact: rawContact }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        resolve: function resolve(args, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                var rawContact = args.contact ? args.contact : args;
                Contact.validate(rawContact);
                agm.invoke('T42.CRM.ResolveContact', { contact: rawContact }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        update: function update(args, autoCreateArg, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                var rawContact = args.contact ? args.contact : args;
                Contact.validate(rawContact);
                var autoCreate = args.autoCreate ? args.autoCreate : autoCreateArg;
                agm.invoke('T42.CRM.UpdateContact', {
                    contact: rawContact,
                    autoCreate: autoCreate
                }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        delete: function _delete(args, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                var rawContact = args.contact ? args.contact : args;
                Contact.validate(rawContact);
                agm.invoke('T42.CRM.DeleteContact', { contact: rawContact }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        get: function get(args, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                var rawContact = args.contact ? args.contact : args;
                Contact.validate(rawContact);
                agm.invoke('T42.CRM.GetContact', { contact: rawContact }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        sync: function sync(args, target) {
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                var rawContact = args.contact ? args.contact : args;
                Contact.validate(rawContact);
                agm.invoke('T42.CRM.SyncContact', { contact: rawContact }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        logCall: function logCall(args, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                Call.validate(args);
                agm.invoke('T42.CRM.LogContactCall', args, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        }
    };
};

/***/ }),

/***/ "./src/Controllers/EventController.js":
/*!********************************************!*\
  !*** ./src/Controllers/EventController.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EventModel = __webpack_require__(/*! ../models/Event */ "./src/models/Event.js");

function getTarget(config, target) {
  return config.getAgmTarget(target);
}

module.exports = function TaskController(agm, config) {
  return {
    create: function create(args, target) {
      args = args || {};
      target = getTarget(config, target);
      return new _promise2.default(function (resolve, reject) {
        var rawEvent = args.event ? args.event : args;
        EventModel.validate(rawEvent);
        agm.invoke('T42.CRM.CreateEvent', { event: rawEvent }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    update: function update(args, autoCreateArg, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawEvent = args.event ? args.event : args;
        EventModel.validate(rawEvent);
        var autoCreate = args.autoCreate ? args.autoCreate : autoCreateArg;
        agm.invoke('T42.CRM.UpdateEvent', { event: rawEvent, autoCreate: autoCreate }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    delete: function _delete(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawEvent = args.event ? args.event : args;
        EventModel.validate(rawEvent);
        agm.invoke('T42.CRM.DeleteEvent', { event: rawEvent }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    get: function get(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawEvent = args.event ? args.event : args;
        EventModel.validate(rawEvent);
        agm.invoke('T42.CRM.GetEvent', { event: rawEvent }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    }
  };
};

/***/ }),

/***/ "./src/Controllers/GenericController.js":
/*!**********************************************!*\
  !*** ./src/Controllers/GenericController.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Lead = __webpack_require__(/*! ../models/Lead */ "./src/models/Lead.js");
var Account = __webpack_require__(/*! ../models/Account */ "./src/models/Account.js");
var Contact = __webpack_require__(/*! ../models/Contact */ "./src/models/Contact.js");
var Event = __webpack_require__(/*! ../models/Event */ "./src/models/Event.js");
var Opportunity = __webpack_require__(/*! ../models/Opportunity */ "./src/models/Opportunity.js");
var Task = __webpack_require__(/*! ../models/Task */ "./src/models/Task.js");

function getTarget(config, target) {
    return config.getAgmTarget(target);
}

var validateObject = function validateObject(args) {
    switch (args.type) {
        case "lead":
        case "Lead":
            var rawLead = args.lead ? args.lead : args.value;
            return Lead.validate(rawLead);
        case "contact":
        case "Contact":
            var rawContact = args.contact ? args.task : args.value;
            return Contact.validate(rawContact);
        case "account":
        case "Account":
            var rawAccount = args.account ? args.lead : args.value;
            return Account.validate(rawAccount);
        case "event":
        case "Event":
            var rawEvent = args.event ? args.event : args.value;
            return Event.validate(rawEvent);
        case "opportunity":
        case "Opportunity":
            var rawOpportunity = args.opportunity ? args.opportunity : args.value;
            return Opportunity.validate(rawOpportunity);
        case "task":
        case "Task":
            var rawTask = args.task ? args.task : args.value;
            return Task.validate(rawTask);
        default:
    }
};
var validateRecord = function validateRecord(args) {
    var recordId = args.recordId,
        type = args.type;

    if (!recordId || !type || !~["lead", "contact", "account", "event", "opportunity", "task"].indexOf(args)) {
        throw Error("wrong record data");
    }
};

module.exports = function GenericController(agm, config) {
    return {
        navigate: function navigate(args, target) {
            args = args || {};
            target = getTarget(config, target);
            return new _promise2.default(function (resolve, reject) {
                validateRecord(args);
                return agm.invoke('T42.CRM.NavigateToRecord', (0, _extends3.default)({}, args), target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        create: function create(args, target) {
            args = args || {};
            target = getTarget(config, target);
            return new _promise2.default(function (resolve, reject) {
                validateObject(args);
                agm.invoke('T42.CRM.Create', (0, _extends3.default)({}, args), target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        update: function update(args, autoCreateArg, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                validateObject(args);
                var autoCreate = args.autoCreate ? args.autoCreate : autoCreateArg;
                agm.invoke('T42.CRM.Update', (0, _extends3.default)({}, args, { autoCreate: autoCreate
                }), target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        delete: function _delete(args, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                validateObject(args);
                agm.invoke('T42.CRM.Delete', (0, _extends3.default)({}, args), target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        get: function get(args, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                validateObject(args);
                agm.invoke('T42.CRM.Get', (0, _extends3.default)({}, args), target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        }
    };
};

/***/ }),

/***/ "./src/Controllers/LeadController.js":
/*!*******************************************!*\
  !*** ./src/Controllers/LeadController.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Lead = __webpack_require__(/*! ../models/Lead */ "./src/models/Lead.js");

function getTarget(config, target) {
    return config.getAgmTarget(target);
}

module.exports = function LeadController(agm, config) {
    return {
        create: function create(args, target) {
            args = args || {};
            target = getTarget(config, target);
            return new _promise2.default(function (resolve, reject) {
                var rawLead = args.lead ? args.lead : args;
                Lead.validate(rawLead);
                agm.invoke('T42.CRM.CreateLead', { lead: rawLead }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        update: function update(args, autoCreateArg, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                var rawLead = args.lead ? args.lead : args;
                Lead.validate(rawLead);
                var autoCreate = args.autoCreate ? args.autoCreate : autoCreateArg;
                agm.invoke('T42.CRM.UpdateLead', { lead: rawLead, autoCreate: autoCreate }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        delete: function _delete(args, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                var rawLead = args.lead ? args.lead : args;
                Lead.validate(rawLead);
                agm.invoke('T42.CRM.DeleteLead', { lead: rawLead }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        },
        get: function get(args, target) {
            args = args || {};
            target = getTarget(config, target);

            return new _promise2.default(function (resolve, reject) {
                var rawLead = args.lead ? args.lead : args;
                Lead.validate(rawLead);
                agm.invoke('T42.CRM.GetLead', { lead: rawLead }, target, { method_response_timeout: config.timeout }, resolve, reject);
            });
        }
    };
};

/***/ }),

/***/ "./src/Controllers/OpportunityController.js":
/*!**************************************************!*\
  !*** ./src/Controllers/OpportunityController.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Opportunity = __webpack_require__(/*! ../models/Opportunity */ "./src/models/Opportunity.js");

function getTarget(config, target) {
  return config.getAgmTarget(target);
}

module.exports = function TaskController(agm, config) {
  return {
    create: function create(args, target) {
      args = args || {};
      target = getTarget(config, target);
      return new _promise2.default(function (resolve, reject) {
        var rawOpportunity = args.opportunity ? args.opportunity : args;
        Opportunity.validate(rawOpportunity);
        agm.invoke('T42.CRM.CreateOpportunity', { opportunity: rawOpportunity }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    update: function update(args, autoCreateArg, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawOpportunity = args.opportunity ? args.opportunity : args;
        Opportunity.validate(rawOpportunity);
        var autoCreate = args.autoCreate ? args.autoCreate : autoCreateArg;
        agm.invoke('T42.CRM.UpdateOpportunity', { opportunity: rawOpportunity, autoCreate: autoCreate }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    delete: function _delete(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawOpportunity = args.opportunity ? args.opportunity : args;
        Opportunity.validate(rawOpportunity);
        agm.invoke('T42.CRM.DeleteOpportunity', { opportunity: rawOpportunity }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    get: function get(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawOpportunity = args.opportunity ? args.opportunity : args;
        Opportunity.validate(rawOpportunity);
        agm.invoke('T42.CRM.GetOpportunity', { opportunity: rawOpportunity }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    }
  };
};

/***/ }),

/***/ "./src/Controllers/TaskController.js":
/*!*******************************************!*\
  !*** ./src/Controllers/TaskController.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Task = __webpack_require__(/*! ../models/Task */ "./src/models/Task.js");

function getTarget(config, target) {
  return config.getAgmTarget(target);
}

module.exports = function TaskController(agm, config) {
  return {
    create: function create(args, target) {
      args = args || {};
      target = getTarget(config, target);
      return new _promise2.default(function (resolve, reject) {
        var rawTask = args.task ? args.task : args;
        Task.validate(rawTask);
        agm.invoke('T42.CRM.CreateTask', { task: rawTask }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    update: function update(args, autoCreateArg, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawTask = args.task ? args.task : args;
        Task.validate(rawTask);
        var autoCreate = args.autoCreate ? args.autoCreate : autoCreateArg;
        agm.invoke('T42.CRM.UpdateTask', { task: rawTask, autoCreate: autoCreate }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    delete: function _delete(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawTask = args.task ? args.task : args;
        Task.validate(rawTask);
        agm.invoke('T42.CRM.DeleteTask', { task: rawTask }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    },
    get: function get(args, target) {
      args = args || {};
      target = getTarget(config, target);

      return new _promise2.default(function (resolve, reject) {
        var rawTask = args.task ? args.task : args;
        Task.validate(rawTask);
        agm.invoke('T42.CRM.GetTask', { task: rawTask }, target, { method_response_timeout: config.timeout }, resolve, reject);
      });
    }
  };
};

/***/ }),

/***/ "./src/GSS/entities/Account.js":
/*!*************************************!*\
  !*** ./src/GSS/entities/Account.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var definition = {
  "name": "T42.Account",
  "properties": [{
    "name": "ids",
    "displayName": "IDs",
    "type": "Composite",
    "isArray": true,
    "properties": [{
      "name": "nativeId",
      "type": "String",
      "displayName": "Native ID",
      "searchType": "Exact"
    }, {
      "name": "systemName",
      "type": "String",
      "displayName": "System Name",
      "searchType": "Exact"
    }]
  }, {
    "name": "displayName",
    "displayName": "Display Name",
    "type": "String",
    "searchType": "Partial",
    "description": "Display Name"
  }, {
    "name": "owner",
    "displayName": "Owner",
    "type": "Composite",
    "properties": [{
      "name": "nativeId",
      "type": "String",
      "displayName": "Native ID",
      "searchType": "Exact"
    }, {
      "name": "systemName",
      "type": "String",
      "displayName": "System Name",
      "searchType": "Exact"
    }]
  }, {
    "name": "subsidiaries",
    "displayName": "Subsidiaries",
    "type": "Composite",
    "isArray": true,
    "properties": [{
      "name": "nativeId",
      "type": "String",
      "displayName": "Native ID",
      "searchType": "Exact"
    }, {
      "name": "systemName",
      "type": "String",
      "displayName": "System Name",
      "searchType": "Exact"
    }]
  }, {
    "name": "name",
    "displayName": "Name",
    "type": "String",
    "searchType": "Partial"
  }, {
    "name": "status",
    "displayName": "Status",
    "type": "String",
    "searchType": "Exact",
    "description": "Status"
  }, {
    "name": "contacts",
    "displayName": "Contacts",
    "type": "Composite",
    "isArray": true,
    "properties": [{
      "name": "nativeId",
      "type": "String",
      "displayName": "Native ID",
      "searchType": "Exact"
    }, {
      "name": "systemName",
      "type": "String",
      "displayName": "System Name",
      "searchType": "Exact"
    }]
  }, {
    "name": "addresses",
    "displayName": "Addresses",
    "type": "Composite",
    "isArray": true,
    "properties": [{
      "name": "streetAddress",
      "type": "String",
      "displayName": "Street Address",
      "searchType": "Partial"
    }, {
      "name": "city",
      "type": "String",
      "displayName": "City",
      "searchType": "Partial"
    }, {
      "name": "stateOrRegion",
      "type": "String",
      "displayName": "State or Region",
      "searchType": "Partial"
    }, {
      "name": "postalCode",
      "type": "String",
      "displayName": "Postal Code",
      "searchType": "Partial"
    }, {
      "name": "country",
      "type": "String",
      "displayName": "Country",
      "searchType": "Partial"
    }, {
      "name": "description",
      "type": "String",
      "displayName": "Description",
      "searchType": "Partial"
    }]
  }, {
    "name": "phones",
    "displayName": "Phones",
    "type": "Composite",
    "isArray": true,
    "properties": [{
      "name": "number",
      "type": "String",
      "displayName": "Number",
      "searchType": "Exact"
    }, {
      "name": "name",
      "type": "String",
      "displayName": "Name",
      "searchType": "Exact"
    }]
  }, {
    "name": "websites",
    "displayName": "Websites",
    "type": "String",
    "isArray": true,
    "searchType": "Partial"
  }, {
    "name": "emailDomains",
    "displayName": "Email Domains",
    "type": "String",
    "isArray": true,
    "searchType": "Partial"
  }, {
    "name": "billingEmailAddress",
    "displayName": "Billing email address",
    "type": "String",
    "searchType": "Partial"
  }]
};

module.exports = definition;

/***/ }),

/***/ "./src/GSS/entities/Contact.js":
/*!*************************************!*\
  !*** ./src/GSS/entities/Contact.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var definition = {
  "name": "T42.Contact",
  "properties": [{
    "name": "ids",
    "displayName": "IDs",
    "type": "Composite",
    "isArray": true,
    "properties": [{
      "name": "nativeId",
      "type": "String",
      "displayName": "Native ID",
      "searchType": "Exact"
    }, {
      "name": "systemName",
      "type": "String",
      "displayName": "System Name",
      "searchType": "Exact"
    }]
  }, {
    "name": "displayName",
    "displayName": "Display Name",
    "type": "String",
    "searchType": "Partial",
    "description": "Display Name"
  }, {
    "name": "name",
    "displayName": "Name",
    "type": "Composite",
    "searchType": "Partial",
    "properties": [{
      "name": "companyName",
      "type": "String",
      "displayName": "Company Name",
      "searchType": "Exact"
    }, {
      "name": "lastName",
      "type": "String",
      "displayName": "Last Name",
      "searchType": "Exact"
    }, {
      "name": "firstName",
      "type": "String",
      "displayName": "First Name",
      "searchType": "Exact"
    }, {
      "name": "otherNames",
      "type": "String",
      "displayName": "Other Names",
      "isArray": true,
      "searchType": "Exact"
    }, {
      "name": "honorific",
      "type": "String",
      "displayName": "Honorific",
      "searchType": "Exact"
    }, {
      "name": "postNominalLetters",
      "type": "String",
      "displayName": "Post-nominal Letters",
      "isArray": true,
      "searchType": "Exact"
    }]
  }, {
    "name": "status",
    "displayName": "Status",
    "type": "String",
    "searchType": "Exact",
    "description": "Status"
  }, {
    "name": "isPerson",
    "displayName": "Is Person",
    "type": "Bool",
    "searchType": "Exact",
    "description": "Is Person"
  }, {
    "name": "account",
    "displayName": "Account",
    "type": "Composite",
    "properties": [{
      "name": "nativeId",
      "type": "String",
      "displayName": "Native ID",
      "searchType": "Exact"
    }, {
      "name": "systemName",
      "type": "String",
      "displayName": "System Name",
      "searchType": "Exact"
    }]
  }, {
    "name": "addresses",
    "displayName": "Addresses",
    "type": "Composite",
    "isArray": true,
    "properties": [{
      "name": "streetAddress",
      "type": "String",
      "displayName": "Street Address",
      "searchType": "Partial"
    }, {
      "name": "city",
      "type": "String",
      "displayName": "City",
      "searchType": "Partial"
    }, {
      "name": "stateOrRegion",
      "type": "String",
      "displayName": "State or Region",
      "searchType": "Partial"
    }, {
      "name": "postalCode",
      "type": "String",
      "displayName": "Postal Code",
      "searchType": "Partial"
    }, {
      "name": "country",
      "type": "String",
      "displayName": "Country",
      "searchType": "Partial"
    }, {
      "name": "description",
      "type": "String",
      "displayName": "Description",
      "searchType": "Partial"
    }]
  }, {
    "name": "phones",
    "displayName": "Phones",
    "type": "Composite",
    "isArray": true,
    "properties": [{
      "name": "number",
      "type": "String",
      "displayName": "Number",
      "searchType": "Exact"
    }, {
      "name": "name",
      "type": "String",
      "displayName": "Name",
      "searchType": "Exact"
    }]
  }, {
    "name": "emails",
    "displayName": "Emails",
    "type": "String",
    "isArray": true,
    "searchType": "Partial"
  }]
};

module.exports = definition;

/***/ }),

/***/ "./src/GSS/entities/Event.js":
/*!***********************************!*\
  !*** ./src/GSS/entities/Event.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var definition = {
    "name": "T42.Event",
    "properties": [{
        "name": "ids",
        "displayName": "IDs",
        "type": "Composite",
        "isArray": true,
        "properties": [{
            "name": "nativeId",
            "type": "String",
            "displayName": "Native ID",
            "searchType": "Exact"
        }, {
            "name": "systemName",
            "type": "String",
            "displayName": "System Name",
            "searchType": "Exact"
        }]
    }, {
        "name": "account",
        "displayName": "Account",
        "type": "Composite",
        "properties": [{
            "name": "nativeId",
            "type": "String",
            "displayName": "Native ID",
            "searchType": "Exact"
        }, {
            "name": "systemName",
            "type": "String",
            "displayName": "System Name",
            "searchType": "Exact"
        }]
    }, {
        "name": "subject",
        "displayName": "Subject",
        "type": "String",
        "isArray": false,
        "searchType": "Partial",
        "description": "Subject line of the event"
    }, {
        "name": "description",
        "displayName": "Description",
        "type": "String",
        "isArray": false,
        "searchType": "Partial",
        "description": "Description of the event"
    }, {
        "name": "budget",
        "displayName": "Budget",
        "type": "Double",
        "isArray": false,
        "searchType": "Partial",
        "description": "Estimated total sale amount"
    }, {
        "name": "duration",
        "displayName": "Duration",
        "type": "Int",
        "isArray": false,
        "searchType": "Exact",
        "description": "Event length in minutes"
    }, {
        "name": "start",
        "displayName": "Start",
        "type": "DateTime",
        "isArray": false,
        "searchType": "Exact",
        "description": "Start date and time of the event"
    }, {
        "name": "end",
        "displayName": "End",
        "type": "DateTime",
        "isArray": false,
        "searchType": "Exact",
        "description": "End date and time of the event"
    }]
};

module.exports = definition;

/***/ }),

/***/ "./src/GSS/entities/Opportunity.js":
/*!*****************************************!*\
  !*** ./src/GSS/entities/Opportunity.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var definition = {
    "name": "T42.Opportunity",
    "properties": [{
        "name": "ids",
        "displayName": "IDs",
        "type": "Composite",
        "isArray": true,
        "properties": [{
            "name": "nativeId",
            "type": "String",
            "displayName": "Native ID",
            "searchType": "Exact"
        }, {
            "name": "systemName",
            "type": "String",
            "displayName": "System Name",
            "searchType": "Exact"
        }]
    }, {
        "name": "account",
        "displayName": "Account",
        "type": "Composite",
        "properties": [{
            "name": "nativeId",
            "type": "String",
            "displayName": "Native ID",
            "searchType": "Exact"
        }, {
            "name": "systemName",
            "type": "String",
            "displayName": "System Name",
            "searchType": "Exact"
        }]
    }, {
        "name": "name",
        "displayName": "Name",
        "type": "String",
        "isArray": false,
        "searchType": "Partial",
        "description": "Name for the opportunity"
    }, {
        "name": "description",
        "displayName": "Description",
        "type": "String",
        "isArray": false,
        "searchType": "Partial",
        "description": "Description of the opportunity"
    }, {
        "name": "budget",
        "displayName": "Budget",
        "type": "Double",
        "isArray": false,
        "searchType": "Partial",
        "description": "Estimated total sale amount"
    }, {
        "name": "currency",
        "displayName": "Currency",
        "type": "String",
        "isArray": false,
        "searchType": "Partial",
        "description": "Iso code for the currency"
    }, {
        "name": "status",
        "displayName": "Status",
        "type": "String",
        "isArray": false,
        "searchType": "Exact",
        "description": "One of 'InProgress', 'OnHold', 'Won', 'Cancelled', 'Out-sold'"
    }, {
        "name": "state",
        "displayName": "State",
        "type": "String",
        "isArray": false,
        "searchType": "Exact",
        "description": "One of 'Open', 'Won', 'Lost'"
    }, {
        "name": "closeDate",
        "displayName": "CloseDate",
        "type": "DateTime",
        "isArray": false,
        "searchType": "Exact",
        "description": "Date when the opportunity is expected to close"
    }, {
        "name": "probability",
        "displayName": "Probability",
        "type": "Double",
        "isArray": false,
        "searchType": "Exact",
        "description": "% estimated confidence in closing the opportunity"
    }]
};

module.exports = definition;

/***/ }),

/***/ "./src/GSS/entities/Task.js":
/*!**********************************!*\
  !*** ./src/GSS/entities/Task.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var definition = {
    "name": "T42.Task",
    "properties": [{
        "name": "ids",
        "displayName": "IDs",
        "type": "Composite",
        "isArray": true,
        "properties": [{
            "name": "nativeId",
            "type": "String",
            "displayName": "Native ID",
            "searchType": "Exact"
        }, {
            "name": "systemName",
            "type": "String",
            "displayName": "System Name",
            "searchType": "Exact"
        }]
    }, {
        "name": "description",
        "displayName": "Description",
        "type": "String",
        "searchType": "Partial",
        "description": "Description of the task"
    }, {
        "name": "subject",
        "displayName": "Subject",
        "type": "Composite",
        "searchType": "Partial",
        "description": "Subject of the task"
    }, {
        "name": "status",
        "displayName": "Status",
        "type": "String",
        "searchType": "Exact",
        "description": "One of 'Not Started', 'In Progress', 'Waiting on someone else', 'Completed', 'Cancelled', 'Deferred'"
    }, {
        "name": "priority",
        "displayName": "Priority",
        "type": "String",
        "searchType": "Exact",
        "description": "One of 'Low', 'Normal', 'High'"
    }, {
        "name": "assignedTo",
        "displayName": "AssignedTo",
        "type": "Composite",
        "description": "Represents the ID of the related Account or Contact",
        "isArray": true,
        "properties": [{
            "name": "nativeId",
            "type": "String",
            "displayName": "Native ID",
            "searchType": "Exact"
        }, {
            "name": "systemName",
            "type": "String",
            "displayName": "System Name",
            "searchType": "Exact"
        }]
    }, {
        "name": "dueDate",
        "displayName": "DueDate",
        "type": "DateTime",
        "isArray": false,
        "searchType": "Exact",
        "description": "Represents the due date of the task - (UTC) time zone."
    }, {
        "name": "estimatedTime",
        "displayName": "EstimatedTime",
        "type": "Double",
        "searchType": "Exact",
        "isArray": false
    }, {
        "name": "reminder",
        "displayName": "Reminder",
        "type": "Bool",
        "isArray": false,
        "searchType": "Exact"
    }, {
        "name": "reminderMinutes",
        "displayName": "ReminderMinutes",
        "type": "Double",
        "isArray": false,
        "searchType": "Exact"
    }]
};

module.exports = definition;

/***/ }),

/***/ "./src/GSS/entities/index.js":
/*!***********************************!*\
  !*** ./src/GSS/entities/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var contact = __webpack_require__(/*! ./Contact */ "./src/GSS/entities/Contact.js");
var account = __webpack_require__(/*! ./Account */ "./src/GSS/entities/Account.js");

var task = __webpack_require__(/*! ./Task */ "./src/GSS/entities/Task.js");
var event = __webpack_require__(/*! ./Event */ "./src/GSS/entities/Event.js");
var opportunity = __webpack_require__(/*! ./Opportunity */ "./src/GSS/entities/Opportunity.js");

module.exports = {
  'T42.Contact': contact,
  'T42.Account': account,
  'T42.Task': task,
  'T42.Event': event,
  'T42.Opportunity': opportunity
};

/***/ }),

/***/ "./src/GSS/index.js":
/*!**************************!*\
  !*** ./src/GSS/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

__webpack_require__(/*! @glue42/gss */ "./node_modules/@glue42/gss/dist/web/@glue42/gss.min.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var entitiesDefinitions = __webpack_require__(/*! ./entities */ "./src/GSS/entities/index.js");
function GSS(agm, options) {
  var searchProvider = null;
  var searchProviderReady = null;
  var allEntityTypes;
  var searchService = null;

  var isGssEnabled = options.searchProviders && options.searchProviders.length > 0 || options.provider;

  if (!isGssEnabled) {
    return {
      search: function search() {
        console.log('GSS isn\'t enabled.');
      },
      addEntityType: function addEntityType() {
        console.log('GSS isn\'t enabled.');
      }
    };
  }

  if (options.side === 'helper' && typeof gss !== "undefined") {
    var manager = gss.createDesktopManager(agm, {
      debug: false
    });
    manager.start();

    if (options.searchProviders && options.searchProviders.length > 0) {
      options.searchProviders.forEach(function (providerName) {
        manager.add({
          name: providerName,
          type: 'agm',
          application: providerName
        });
      });
    }

    searchService = searchService || new gss.GlueSearchService(agm, {
      target: {
        application: options.target
      }
    });
    var searchReady = searchService.ready();

    searchReady.then(function (api) {
      api.onEntityTypes(function (err, entityTypes) {
        if (err) {
          throw new Error(err);
        }
        allEntityTypes = entityTypes;
      });
    });
  }

  function addEntityType(name, handler) {
    return new _promise2.default(function (resolve, reject) {
      if (typeof name !== 'string') {
        throw Error('A entity name is required to register a search provider');
      }

      if (entitiesDefinitions[name] === undefined) {
        throw Error('Unsupported entity: "' + name + '"');
      }

      if (typeof handler !== 'function') {
        throw Error('A search handler is required to register a search provider');
      }

      if (!searchProvider) {
        searchProvider = new gss.GlueSearchProvider(agm, {
          debug: false,
          measureLatency: false,
          target: {
            application: options.target
          }
        });

        searchProviderReady = searchProvider.start();
      }

      searchProviderReady.then(function () {
        var entity = gss.GssEntityType.fromJS(entitiesDefinitions[name]);
        searchProvider.addEntityType(entity, handler);
        resolve();
      }).catch(reject);
    });
  }

  function search(name, query) {
    return new _promise2.default(function (resolve, reject) {
      searchProviderReady.then(function () {
        var response = [];
        var entityType = allEntityTypes && allEntityTypes.get(name);
        if (!entityType) {
          return reject('Search provider not found');
        }
        var currentQuery = searchService.createQuery(entityType);

        currentQuery.onData(function (result) {
          response = response.concat(result.entities);
          if (result.isLast) {
            resolve(response);
          }
        }).search(query);
      }).catch(reject);
    });
  }

  return {
    addEntityType: addEntityType,
    search: search
  };
}

module.exports = GSS;

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  side: 'crm',
  glue: {
    gateway: {
      ws: 'ws://localhost:8385',
      http: 'https://demo.tick42.com:50112',
      protocolVersion: 3,
      reconnectAttempts: 3,
      reconnectInterval: 6000
    }
  },
  timeout: 3000
};

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  CRM_PREFIX: 'T42.CRM.',
  SIGNATURES: {
    CONTACT: 'Composite { Composite { String? city, String? country, String? description, String? postalCode, String? stateOrRegion, String? streetAddress }[]? addresses, String? displayName, String[]? emails, Bool? isPerson, Composite { String? companyName, String? firstName, String? honorific, String? lastName, String[]? otherNames, String[]? postNominalLetters }? name, Composite { String name, String number }[]? phones, String? status } contact',
    ACCOUNT: 'Composite { Composite { String? city, String? country, String? description, String? postalCode, String? stateOrRegion, String? streetAddress }[]? addresses, String? billingEmailAddress, Composite { String nativeId, String systemName }[]? contacts, String? displayName, String[]? emailDomains, Composite { String nativeId, String systemName }[] ids, String? name, Composite { String nativeId, String systemName }? owner, Composite { String name, String number }[]? phones, String? status, Composite { String nativeId, String systemName }[]? subsidiaries, String[]? website } account',
    CONTACTS: 'Composite { Composite { String? city, String? country, String? description, String? postalCode, String? stateOrRegion, String? streetAddress }[]? addresses, String? displayName, String[]? emails, Bool? isPerson, Composite { String? companyName, String? firstName, String? honorific, String? lastName, String[]? otherNames, String[]? postNominalLetters }? name, Composite { String name, String number }[]? phones, String? status }[] contacts'
  }
};

/***/ }),

/***/ "./src/crm.js":
/*!********************!*\
  !*** ./src/crm.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var methods = __webpack_require__(/*! ./methods */ "./src/methods.js");
var constants = __webpack_require__(/*! ./constants */ "./src/constants.js");
var GSSCreator = __webpack_require__(/*! ./GSS */ "./src/GSS/index.js");
var packageJson = __webpack_require__(/*! ../package.json */ "./package.json");

function CRM(agm, config) {
    config.getAgmTarget = getAgmTarget;
    var ContactController = __webpack_require__(/*! ./Controllers/ContactController.js */ "./src/Controllers/ContactController.js")(agm, config);
    var AccountController = __webpack_require__(/*! ./Controllers/AccountController.js */ "./src/Controllers/AccountController.js")(agm, config);
    var TaskController = __webpack_require__(/*! ./Controllers/TaskController.js */ "./src/Controllers/TaskController.js")(agm, config);
    var EventController = __webpack_require__(/*! ./Controllers/EventController.js */ "./src/Controllers/EventController.js")(agm, config);
    var OpportunityController = __webpack_require__(/*! ./Controllers/OpportunityController.js */ "./src/Controllers/OpportunityController.js")(agm, config);
    var LeadController = __webpack_require__(/*! ./Controllers/LeadController.js */ "./src/Controllers/LeadController.js")(agm, config);
    var GenericController = __webpack_require__(/*! ./Controllers/GenericController.js */ "./src/Controllers/GenericController.js")(agm, config);
    var availableMethods = getMethods(config);

    var GSS = GSSCreator(agm, config);

    function getAgmTarget(target) {
        return target || 'skipMine';
        // OLD
        return typeof target !== 'undefined' ? typeof target === 'string' ? { application: target } : target : config.getAgmTarget();
    }

    return {
        GetContact: ContactController.get,
        CreateContact: ContactController.create,
        ResolveContact: ContactController.resolve,
        UpdateContact: ContactController.update,
        DeleteContact: ContactController.delete,
        SyncContact: ContactController.sync,
        LogContactCall: ContactController.logCall,

        CreateAccount: AccountController.create,
        GetAccount: AccountController.get,
        ResolveAccount: AccountController.resolve,
        UpdateAccount: AccountController.update,
        DeleteAccount: AccountController.delete,
        SyncAccount: AccountController.sync,

        GetTask: TaskController.get,
        CreateTask: TaskController.create,
        UpdateTask: TaskController.update,
        DeleteTask: TaskController.delete,

        GetEvent: EventController.get,
        CreateEvent: EventController.create,
        UpdateEvent: EventController.update,
        DeleteEvent: EventController.delete,

        GetOpportunity: OpportunityController.get,
        CreateOpportunity: OpportunityController.create,
        UpdateOpportunity: OpportunityController.update,
        DeleteOpportunity: OpportunityController.delete,

        GetLead: LeadController.get,
        CreateLead: LeadController.create,
        UpdateLead: LeadController.update,
        DeleteLead: LeadController.delete,

        Get: GenericController.get,
        Create: GenericController.create,
        Update: GenericController.update,
        Delete: GenericController.delete,
        NavigateToRecord: GenericController.navigate,

        QueryAccount: function QueryAccount(query) {
            return GSS.search('T42.Account', query);
        },
        QueryContact: function QueryContact(query) {
            return GSS.search('T42.Contact', query);
        },
        QueryTask: function QueryTask(query) {
            return GSS.search('T42.Task', query);
        },
        QueryEvent: function QueryEvent(query) {
            return GSS.search('T42.Event', query);
        },
        QueryOpportunity: function QueryOpportunity(query) {
            return GSS.search('T42.Opportunity', query);
        },
        QueryLead: function QueryLead(query) {
            return GSS.search('T42.Lead', query);
        },
        ResolveAccountContactList: AccountController.resolveContactList,
        on: function on(name, handler) {
            var method = availableMethods.find(function (m) {
                return m.name === constants.CRM_PREFIX + name;
            });
            if (!method) throw new Error('Unsupported method: ' + name);

            var internalHandler = function internalHandler(args, caller, success, error) {
                config.application = caller.application;
                try {
                    handler(args, caller, success, error);
                } catch (error) {
                    console.warn('Error in handler ' + name, error);
                }
            };
            agm.registerAsync(method, internalHandler);
        },

        onSearch: GSS.addEntityType,
        version: packageJson.version
    };
}

function getMethods(config) {
    // new Promise(async (res, rej) => {
    //     try {
    //         await glue.agm.register('OnBBGRequestData', console.warn);
    //     } catch (e) {
    //         console.info(e)
    //     }
    //     ;res(true);
    // }).then(() => glue.agm.invoke('T42.MDFApi.CreateRequest', {
    //     requestCorrelationId: Date.now(),
    //     settings: { 'sessionOptions': { 'serverHost': 'localhost', 'serverPort': 8194 }, 'sessionName': 'sessionOne' },
    //     service: '//blp/refdata',
    //     operation: 'ReferenceDataRequest',
    //     operationArgs: [{ 'securities': ['US4592001014 ISIN'] }, { 'fields': ['TICKER_AND_EXCH_CODE'] }, { 'returnEids': true },],
    //     callbackMethod: 'OnBBGRequestData'
    // }).then(console.info))
    //
    // new Promise(async (res, rej) => {
    //     try {
    //         await glue.agm.register('OnBBGRequestData', console.warn);
    //     } catch (e) {
    //         console.info(e)
    //     }
    //     res(true);
    // }).then(() => glue.agm.invoke('T42.MDFApi.CreateRequest', {
    //     requestCorrelationId: Date.now(),
    //     settings: { 'sessionOptions': { 'serverHost': 'localhost', 'serverPort': 8194 }, 'sessionName': 'sessionOne' },
    //     service: '//blp/refdata',
    //     operation: 'ReferenceDataRequest',
    //     operationArgs: [{ 'securities': ['US4592001014 ISIN'] }, { 'fields': ['PARSEKYABLE_DES'] }, { 'returnEids': true },],
    //     callbackMethod: 'OnBBGRequestData'
    // }).then(console.info))

    return methods.filter(function (method) {
        return method.side === 'both' || method.side === config.side;
    });
}

module.exports = CRM;

/***/ }),

/***/ "./src/glue-connection.js":
/*!********************************!*\
  !*** ./src/glue-connection.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _desktop = __webpack_require__(/*! @glue42/desktop */ "./node_modules/@glue42/desktop/dist/desktop.browser.js");

var _desktop2 = _interopRequireDefault(_desktop);

var _web = __webpack_require__(/*! @glue42/web */ "./node_modules/@glue42/web/dist/web.es.js");

var _web2 = _interopRequireDefault(_web);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Connect to any Glue GD/Core Platform
 * @param {Glue42.Config>} config 
 * @returns Promise
 */
var GlueConnection = async function GlueConnection(config) {
    var glue = config.glue;

    if (glue) {
        return glue;
    }
    try {
        glue = await (0, _web2.default)();
    } catch (e) {
        /** Note:
         * The GlueWeb() initialization requires the parent
         * window to be opened by one of the Glue platforms
         */
        glue = await (0, _desktop2.default)(config);
    }
    return glue;
};
module.exports = GlueConnection;

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = __webpack_require__(/*! babel-runtime/helpers/extends */ "./node_modules/babel-runtime/helpers/extends.js");

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultConfig = __webpack_require__(/*! ./config.js */ "./src/config.js");
var CRMCreator = __webpack_require__(/*! ./crm.js */ "./src/crm.js");
var GlueConnection = __webpack_require__(/*! ./glue-connection.js */ "./src/glue-connection.js");

exports.default = async function Tick42CRM(options) {
    var crmConfig = {
        side: options.side || defaultConfig.side,
        timeout: options.timeout || defaultConfig.timeout,
        target: options.application || 'CRMGssDesktopManager',
        searchProviders: options.searchProviders || [],
        provider: options.provider
    };

    var glueConfig = (0, _extends3.default)({}, defaultConfig.glue, options);
    glueConfig.auth = glueConfig.authentication || glueConfig.auth;

    var glue = await GlueConnection(glueConfig);
    var CRM = CRMCreator(glue.agm, crmConfig);
    return {
        CRM: CRM,
        glue: glue
    };
};

/***/ }),

/***/ "./src/methods.js":
/*!************************!*\
  !*** ./src/methods.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var constants = __webpack_require__(/*! ./constants */ "./src/constants.js");

module.exports = [{
    side: 'crm',
    name: constants.CRM_PREFIX + 'CreateContact',
    accepts: constants.SIGNATURES.CONTACT,
    description: '',
    displayName: 'Create Contact',
    objectTypes: []
}, {
    side: 'both',
    name: constants.CRM_PREFIX + 'GetContact',
    accepts: constants.SIGNATURES.CONTACT,
    description: '',
    displayName: 'Get Contact',
    objectTypes: []
}, {
    side: 'helper',
    name: constants.CRM_PREFIX + 'ResolveContact',
    accepts: constants.SIGNATURES.CONTACT,
    description: '',
    displayName: 'Resolve Contact',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'UpdateContact',
    accepts: 'Bool? autoCreate, ' + constants.SIGNATURES.CONTACT,
    description: '',
    displayName: 'Update Contact',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'DeleteContact',
    accepts: constants.SIGNATURES.CONTACT,
    description: '',
    displayName: 'Delete Contact',
    objectTypes: []
}, {
    side: 'both',
    name: constants.CRM_PREFIX + 'SyncContact',
    accepts: constants.SIGNATURES.CONTACT,
    description: '',
    displayName: 'Sync Contact',
    objectTypes: []
}, {
    side: 'both',
    name: constants.CRM_PREFIX + 'GetAccount',
    accepts: constants.SIGNATURES.ACCOUNT,
    description: '',
    displayName: 'Get Account',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'CreateAccount',
    accepts: constants.SIGNATURES.ACCOUNT,
    description: '',
    displayName: 'Create Account',
    objectTypes: []
}, {
    side: 'helper',
    name: constants.CRM_PREFIX + 'ResolveAccount',
    accepts: constants.SIGNATURES.ACCOUNT,
    description: '',
    displayName: 'Resolve Contact',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'UpdateAccount',
    accepts: 'Bool? autoCreate, ' + constants.SIGNATURES.ACCOUNT,
    description: '',
    displayName: 'Update Account',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'DeleteAccount',
    accepts: constants.SIGNATURES.ACCOUNT,
    description: '',
    displayName: 'Delete Account',
    objectTypes: []
}, {
    side: 'both',
    name: constants.CRM_PREFIX + 'SyncAccount',
    accepts: constants.SIGNATURES.ACCOUNT,
    description: '',
    displayName: 'Sync Account',
    objectTypes: []
}, {
    side: 'helper',
    name: constants.CRM_PREFIX + 'ResolveAccountContactList',
    accepts: constants.SIGNATURES.CONTACTS + ", " + constants.SIGNATURES.ACCOUNT,
    description: '',
    displayName: 'Resolve Account Contact List',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'LogContactCall',
    accepts: '',
    description: '',
    displayName: 'Log contact call',
    objectTypes: []
}, {
    side: 'both',
    name: constants.CRM_PREFIX + 'SearchContact',
    accepts: '',
    description: '',
    displayName: 'Search a contact',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'GetTask',
    accepts: '',
    description: '',
    displayName: 'Get a task',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'UpdateTask',
    accepts: '',
    description: '',
    displayName: 'Update a task',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'DeleteTask',
    accepts: '',
    description: '',
    displayName: 'Delete a task',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'CreateTask',
    accepts: '',
    description: '',
    displayName: 'Create a task',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'GetEvent',
    accepts: '',
    description: '',
    displayName: 'Get an event',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'UpdateEvent',
    accepts: '',
    description: '',
    displayName: 'Update an event',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'DeleteEvent',
    accepts: '',
    description: '',
    displayName: 'Delete an event',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'CreateEvent',
    accepts: '',
    description: '',
    displayName: 'Create an event',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'GetOpportunity',
    accepts: '',
    description: '',
    displayName: 'Get a opportunity',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'UpdateOpportunity',
    accepts: '',
    description: '',
    displayName: 'Update a opportunity',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'DeleteOpportunity',
    accepts: '',
    description: '',
    displayName: 'Delete a opportunity',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'CreateOpportunity',
    accepts: '',
    description: '',
    displayName: 'Create a opportunity',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'GetLead',
    accepts: '',
    description: '',
    displayName: 'Get a lead',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'UpdateLead',
    accepts: '',
    description: '',
    displayName: 'Update a lead',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'DeleteLead',
    accepts: '',
    description: '',
    displayName: 'Delete a lead',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'CreateLead',
    accepts: '',
    description: '',
    displayName: 'Create a lead',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'Create',
    accepts: '',
    description: '',
    displayName: 'Create Object',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'Update',
    accepts: '',
    description: '',
    displayName: 'Update Object',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'Delete',
    accepts: '',
    description: '',
    displayName: 'Delete Object',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'Get',
    accepts: '',
    description: '',
    displayName: 'Get Object',
    objectTypes: []
}, {
    side: 'crm',
    name: constants.CRM_PREFIX + 'NavigateToRecord',
    accepts: '',
    description: '',
    displayName: 'Navigate To Record',
    objectTypes: []
}];

/***/ }),

/***/ "./src/models/Account.js":
/*!*******************************!*\
  !*** ./src/models/Account.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");
var Id = __webpack_require__(/*! ./Id */ "./src/models/Id.js");
var Address = __webpack_require__(/*! ./Address */ "./src/models/Address.js");
var Phone = __webpack_require__(/*! ./Phone */ "./src/models/Phone.js");

module.exports = Model({
  ids: Model.Array(Id),
  displayName: [String],
  owner: [Id],
  subsidiaries: [Model.Array(Id)],
  name: [String],
  status: [String],
  contacts: [Model.Array(Id)],
  addresses: [Model.Array(Address)],
  phones: [Model.Array(Phone)],
  websites: [Model.Array(String)],
  emailDomains: [Model.Array(String)],
  billingEmailAddress: [String]
});

/***/ }),

/***/ "./src/models/Address.js":
/*!*******************************!*\
  !*** ./src/models/Address.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");

module.exports = Model({
  streetAddress: [String],
  city: [String],
  stateOrRegion: [String],
  postalCode: [String],
  country: [String],
  description: [String]
});

/***/ }),

/***/ "./src/models/Contact.js":
/*!*******************************!*\
  !*** ./src/models/Contact.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");
var Id = __webpack_require__(/*! ./Id */ "./src/models/Id.js");
var Name = __webpack_require__(/*! ./Name */ "./src/models/Name.js");
var Address = __webpack_require__(/*! ./Address */ "./src/models/Address.js");
var Phone = __webpack_require__(/*! ./Phone */ "./src/models/Phone.js");

module.exports = Model({
  ids: Model.Array(Id),
  displayName: [String],
  name: [Name],
  status: [String],
  isPerson: [Boolean],
  account: [Id],
  addresses: [Model.Array(Address)],
  phones: [Model.Array(Phone)],
  emails: [Model.Array(String)]
});

/***/ }),

/***/ "./src/models/Event.js":
/*!*****************************!*\
  !*** ./src/models/Event.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");
var Id = __webpack_require__(/*! ./Id */ "./src/models/Id.js");

module.exports = Model({
  ids: Model.Array(Id),
  account: Model.Array(Id),
  subject: String,
  description: [String],
  duration: [Number],
  start: Number,
  end: Number,
  customFields: [Object]
});

/***/ }),

/***/ "./src/models/Id.js":
/*!**************************!*\
  !*** ./src/models/Id.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");

module.exports = Model({
  nativeId: String,
  systemName: String
});

/***/ }),

/***/ "./src/models/Lead.js":
/*!****************************!*\
  !*** ./src/models/Lead.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");
var Id = __webpack_require__(/*! ./Id */ "./src/models/Id.js");
var Name = __webpack_require__(/*! ./Name */ "./src/models/Name.js");
var Address = __webpack_require__(/*! ./Address */ "./src/models/Address.js");
var Phone = __webpack_require__(/*! ./Phone */ "./src/models/Phone.js");

module.exports = Model({
    ids: Model.Array(Id),
    name: [Name],
    displayName: [String],
    emails: [Model.Array(String)],
    status: [String],
    account: [Id],
    website: [String],
    addresses: [Model.Array(Address)],
    phones: [Model.Array(Phone)]
});

/***/ }),

/***/ "./src/models/Name.js":
/*!****************************!*\
  !*** ./src/models/Name.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");

module.exports = Model({
  companyName: [String],
  lastName: [String],
  firstName: [String],
  otherNames: [Model.Array(String)],
  honorific: [String],
  postNominalLetters: [Model.Array(String)]
});

/***/ }),

/***/ "./src/models/Opportunity.js":
/*!***********************************!*\
  !*** ./src/models/Opportunity.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");
var Id = __webpack_require__(/*! ./Id */ "./src/models/Id.js");

module.exports = Model({
  ids: Model.Array(Id),
  account: Model.Array(Id),
  name: String,
  description: [String],
  budget: Number,
  currency: String,
  status: ["InProgress", "OnHold", "Won", "Cancelled", "Out-sold"],
  state: ["Open", "Won", "Lost"],
  closedDate: Number,
  probability: Number,
  customFields: [Object]
});

/***/ }),

/***/ "./src/models/Phone.js":
/*!*****************************!*\
  !*** ./src/models/Phone.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");

module.exports = Model({
  number: String,
  name: String
});

/***/ }),

/***/ "./src/models/Task.js":
/*!****************************!*\
  !*** ./src/models/Task.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Model = __webpack_require__(/*! objectmodel */ "./node_modules/objectmodel/dist/object-model.umd.js");
var Id = __webpack_require__(/*! ./Id */ "./src/models/Id.js");

module.exports = Model({
  ids: Model.Array(Id),
  description: [String],
  subject: String,
  status: ["NotStarted", "InProgress", "WaitingOnSomeoneElse", "Completed", "Cancelled", "Deferred"],
  priority: ["Low", "Normal", "High"],
  assignedTo: Model.Array(Id),
  dueDate: Number,
  estimatedTime: [Number],
  reminder: [Boolean],
  reminderMinutes: [Number],
  customFields: [Object]
});

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=Tick42CRM.js.map